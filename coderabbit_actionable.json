[
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Remove console.log of user info (PII) and use logger in DEV only**\n\nLogging user objects to the console risks leaking PII. Use logger.debug and gate behind DEV.\n\n\nApply this diff:\n\n```diff\n-        const userInfo = await authService.getUserInfo();\n-        console.log('useAuth: Valid token - setting user info', { userInfo });\n+        const userInfo = await authService.getUserInfo();\n+        if (import.meta.env.DEV) {\n+          logger.debug('useAuth: Valid token - setting user info', { hasUserInfo: !!userInfo }, LOG_CATEGORIES.AUTH);\n+        }\n         setUser(userInfo);\n```\n\n```diff\n-            const userInfo = await authService.getUserInfo();\n-            console.log('useAuth: Offline mode - setting user info', { userInfo });\n+            const userInfo = await authService.getUserInfo();\n+            if (import.meta.env.DEV) {\n+              logger.debug('useAuth: Offline mode - setting user info', { hasUserInfo: !!userInfo }, LOG_CATEGORIES.AUTH);\n+            }\n             setUser(userInfo);\n```\n\n\nAlso applies to: 335-337\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/features/auth/hooks/useAuth.js around lines 311-313 and 335-337, remove\nthe console.log that prints the userInfo object (PII). Replace it by calling the\nproject's logger.debug (or a passed-in logger) and wrap that call in a DEV-only\nguard (e.g., if (process.env.NODE_ENV === 'development') logger.debug(...)) so\nPII is not printed in production; ensure you do not change setUser(userInfo)\nbehavior and do not log the full user object in non-DEV environments.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 322,
    "path": "src/features/auth/hooks/useAuth.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Ensure manual refresh updates displayed attendance data.**\n\n`handleRefreshAttendance` calls `attendanceDataService.getAttendanceData(true)` but never pushes the returned data back into the hook state, so the UI keeps showing the cached array. Please invoke the hook‚Äôs refresh/load helper (or set the hook‚Äôs state directly) so the refreshed dataset is rendered. For example:\n\n```diff\n-      const refreshedData = await attendanceDataService.getAttendanceData(true);\n-\n-      // Update last refresh time\n-      setLastAttendanceRefresh(attendanceDataService.getLastFetchTime());\n+      const refreshedData = await loadAttendanceData?.(true) ?? await attendanceDataService.getAttendanceData(true);\n+\n+      // Update hook state when falling back to direct service call\n+      if (!loadAttendanceData && Array.isArray(refreshedData)) {\n+        setAttendanceData(refreshedData);\n+      }\n+\n+      setLastAttendanceRefresh(attendanceDataService.getLastFetchTime());\n```\n\nAdjust the exact helper names to match `useAttendanceData`. Without this, users see stale records even after a ‚Äúsuccessful‚Äù refresh.\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/features/events/components/attendance/EventAttendance.jsx around lines\n497-537, the refreshed array returned from\nattendanceDataService.getAttendanceData(true) is never fed back into the\ncomponent hook/state so the UI stays stale; after receiving refreshedData, call\nthe useAttendanceData hook‚Äôs refresh/load helper (or directly set the hook\nstate) to replace the cached attendance array (e.g., invoke the hook‚Äôs\nrefreshAttendance/loadAttendance or call setAttendanceData(refreshedData)), keep\nthe existing setLastAttendanceRefresh call, and only then log/notify success so\nthe component re-renders with the new dataset.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 537,
    "path": "src/features/events/components/attendance/EventAttendance.jsx"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Prevent double-invocation: add an internal pending guard and wire it to UI state.**\n\nCurrently, a fast double-click can trigger concurrent onRefresh calls before the parent sets loading. Add local isPending to guard re-entrancy, drive the spinner/text, and disable the button during the awaited call.\n\n\nApply this diff:\n\n```diff\n@@\n function RefreshButton({\n@@\n }) {\n-  const [hasError, setHasError] = useState(false);\n+  const [hasError, setHasError] = useState(false);\n+  const [isPending, setIsPending] = useState(false);\n@@\n   const handleClick = async () => {\n-    if (loading || !onRefresh) return;\n+    if (loading || isPending || !onRefresh) return;\n \n     try {\n+      setIsPending(true);\n       setHasError(false);\n       await onRefresh();\n     } catch (error) {\n       setHasError(true);\n       if (showErrorNotification) {\n         handleScoutError(error, 'refresh data');\n       }\n     }\n+    finally {\n+      setIsPending(false);\n+    }\n   };\n@@\n   const getIcon = () => {\n-    if (loading) {\n+    if (loading || isPending) {\n       return <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2\"></div>;\n     }\n@@\n   const getText = () => {\n-    if (loading) return 'Refreshing...';\n+    if (loading || isPending) return 'Refreshing...';\n     if (hasError) return 'Try Again';\n     return 'Refresh Data';\n   };\n@@\n     <button\n       onClick={handleClick}\n-      disabled={loading}\n+      disabled={loading || isPending}\n       className={combinedClasses}\n       type=\"button\"\n       title={hasError ? 'An error occurred. Click to try again.' : undefined}\n     >\n```\n\n\nAlso applies to: 48-52, 67-71, 81-90, 13-13\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/components/ui/RefreshButton.jsx around lines 33-45 (and also apply\nthe same change at 48-52, 67-71, 81-90, and line 13), add a local isPending\nstate to prevent re-entrancy: initialize isPending via useState(false), in each\nclick/submit handler return early if loading || isPending || !onRefresh, set\nisPending(true) before awaiting onRefresh(), and clear it in a finally block\n(setIsPending(false)); update the button disabled prop and spinner/text logic to\nuse (loading || isPending) so a fast double-click cannot trigger concurrent\nonRefresh calls and the UI reflects the pending state.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 45,
    "path": "src/shared/components/ui/RefreshButton.jsx"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\n**Fix broken import path (case-sensitive) for CurrentActiveTermsService**\n\nThe pipeline can‚Äôt resolve the module. The file is `currentActiveTermsService.js` (lowercase initial ‚Äúc‚Äù).\n\nApply this diff:\n\n```diff\n-import { CurrentActiveTermsService } from '../../storage/CurrentActiveTermsService.js';\n+import { CurrentActiveTermsService } from '../../storage/currentActiveTermsService.js';\n```\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/usr/bin/env bash\n# Locate case-insensitive and case-sensitive file names for CurrentActiveTermsService\nfind src/shared/services/storage -type f -iname 'currentactivetermsservice.js'\nfind src/shared/services/storage -type f -name 'currentActiveTermsService.js'\nfind src/shared/services/storage -type f -name 'CurrentActiveTermsService.js'\n```\n\nLength of output: 113\n\n---\n\n\n\n</details>\n\n**Fix import path case for CurrentActiveTermsService in src/shared/services/api/api/members.js**  \n\n```diff\n-import { CurrentActiveTermsService } from '../../storage/CurrentActiveTermsService.js';\n+import { CurrentActiveTermsService } from '../../storage/currentActiveTermsService.js';\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nimport { CurrentActiveTermsService } from '../../storage/currentActiveTermsService.js';\nimport { getTerms } from './terms.js';\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>üß∞ Tools</summary>\n\n<details>\n<summary>ü™õ GitHub Actions: CI/CD Pipeline</summary>\n\n[error] 14-14: Failed to resolve import '../../storage/CurrentActiveTermsService.js' from 'src/shared/services/api/api/members.js'. Does the file exist?\n\n</details>\n\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/api/api/members.js around lines 14-15, the import path\nfor CurrentActiveTermsService has incorrect letter casing; update the import\npath so it exactly matches the filesystem filename and exported module name in\n../../storage (e.g., change to the exact-cased\n../../storage/CurrentActiveTermsService.js if that is the file) and ensure the\nimported identifier matches the export, then save and run the build/tests to\nverify the import is resolved.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 15,
    "path": "src/shared/services/api/api/members.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix case-sensitive import for CurrentActiveTermsService**\n\nOn case-sensitive environments (our CI/Linux build), the current path `../storage/CurrentActiveTermsService.js` fails to resolve because the file on disk is `currentActiveTermsService.js`. This will break bundling/runtime immediately. Please align the import casing with the actual filename.\n\n```diff\n-import { CurrentActiveTermsService } from '../storage/CurrentActiveTermsService.js';\n+import { CurrentActiveTermsService } from '../storage/currentActiveTermsService.js';\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nimport { CurrentActiveTermsService } from '../storage/currentActiveTermsService.js';\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/data/pageDataManager.js around line 20, the import uses\nincorrect casing: it imports ../storage/CurrentActiveTermsService.js but the\nactual file on disk is currentActiveTermsService.js; update the import path to\nmatch the exact filename casing (../storage/currentActiveTermsService.js) so it\nresolves correctly on case-sensitive filesystems and rebuilds without error.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": null,
    "path": "src/shared/services/data/pageDataManager.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Guard against `navigator` being undefined**\n\nBoth `fallbackToWebStatus` and `detectWebConnectionType` dereference `navigator` without first confirming you are in a browser environment. In SSR/tests/Node execution this throws a ReferenceError, preventing the manager from initialising. Please add a `typeof navigator !== 'undefined'` check before accessing its properties. \n\n```diff\n-    if (navigator.onLine !== undefined) {\n+    if (typeof navigator !== 'undefined' && navigator.onLine !== undefined) {\n       this.updateStatus(navigator.onLine ? NetworkStatus.ONLINE : NetworkStatus.OFFLINE);\n       this.updateConnectionType(this.detectWebConnectionType());\n@@\n-    if (navigator.connection) {\n+    if (typeof navigator !== 'undefined' && navigator.connection) {\n       const connection = navigator.connection;\n```\n\n\nAlso applies to: 226-240\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/network/NetworkStatusManager.js around lines 87-99 (and\nsimilarly at lines 226-240), the code dereferences navigator directly which\nthrows in non-browser environments; add a guard using typeof navigator !==\n'undefined' before accessing navigator or navigator.onLine, and if navigator is\nundefined fall back to UNKNOWN status/connection type or skip connection-type\ndetection. Update both fallbackToWebStatus and detectWebConnectionType to check\ntypeof navigator !== 'undefined' before using navigator and return appropriate\ndefaults when absent.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 99,
    "path": "src/shared/services/network/NetworkStatusManager.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Provide explicit mocks for logger and IndexedDBService (include STORES)**\n\nAuto-mocking may not supply logger methods or STORES, causing TypeErrors or failing schema assertions. Replace these mocks with factories that define the needed shape.\n\n```diff\n-vi.mock('../indexedDBService.js');\n-vi.mock('../unifiedStorageService.js');\n-vi.mock('../../utils/logger.js');\n+vi.mock('../indexedDBService.js', () => ({\n+  IndexedDBService: {\n+    STORES: { CURRENT_ACTIVE_TERMS: 'current_active_terms' },\n+    getDB: vi.fn(),\n+    getByIndex: vi.fn(),\n+    delete: vi.fn(),\n+  },\n+}));\n+vi.mock('../unifiedStorageService.js');\n+vi.mock('../../utils/logger.js', () => ({\n+  default: {\n+    trace: vi.fn(),\n+    debug: vi.fn(),\n+    info: vi.fn(),\n+    warn: vi.fn(),\n+    error: vi.fn(),\n+    fatal: vi.fn(),\n+    fmt: vi.fn(),\n+  },\n+  LOG_CATEGORIES: {\n+    ERROR: 'error',\n+    DATABASE: 'database',\n+    SYNC: 'sync',\n+    OFFLINE: 'offline',\n+  },\n+}));\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nvi.mock('../indexedDBService.js', () => ({\n  IndexedDBService: {\n    STORES: { CURRENT_ACTIVE_TERMS: 'current_active_terms' },\n    getDB: vi.fn(),\n    getByIndex: vi.fn(),\n    delete: vi.fn(),\n  },\n}));\nvi.mock('../unifiedStorageService.js');\nvi.mock('../../utils/logger.js', () => ({\n  default: {\n    trace: vi.fn(),\n    debug: vi.fn(),\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n    fatal: vi.fn(),\n    fmt: vi.fn(),\n  },\n  LOG_CATEGORIES: {\n    ERROR: 'error',\n    DATABASE: 'database',\n    SYNC: 'sync',\n    OFFLINE: 'offline',\n  },\n}));\nvi.mock('../../../../config/demoMode.js', () => ({\n  isDemoMode: () => false,\n}));\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 19,
    "path": "src/shared/services/storage/__tests__/currentActiveTermsService.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix test failures - mockDB methods not returning expected promises**\n\nThe tests are failing because the mock implementations don't properly simulate the async behaviour of IndexedDBService methods. The service expects the database methods to return promises that resolve to specific data structures.\n\n\nThe test setup needs to ensure that `IndexedDBService.getDB()` returns a properly configured mock. Apply these fixes:\n\n```diff\n// At the beginning of 'Current Active Terms Store Operations' describe block, after line 280:\n+    // Import the service to spy on getDB\n+    const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n+    \n+    // Mock getDB to return our mockDB\n+    vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n```\n\nThis ensures that when the service calls `getDB()`, it gets the properly configured mock database instance.\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBService.test.js around lines\n282 to 310, the test fails because the mocked database instance isn't returned\nby IndexedDBService.getDB() and its methods must resolve promises matching the\nservice expectations; ensure the test sets IndexedDBService.getDB =\njest.fn().mockResolvedValue(mockDB) (or spy and return mockDB) and configure\nmockDB methods (get, put, delete, getAll, etc.) with\nmockResolvedValue(mockReturnValue) or mockRejectedValue for errors so each async\ncall returns the expected resolved promise shape used by the service (e.g., put\nresolves undefined, get resolves the stored object, getAll resolves an array),\nthen run the test to verify the service receives the properly shaped async\nresponses.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:armadillo -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 310,
    "path": "src/shared/services/storage/__tests__/indexedDBService.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix mock return value structure for get operation**\n\nThe test expects the IndexedDBService to unwrap the data property, but the mock isn't being called due to the getDB issue.\n\n\nOnce the getDB mock is fixed as suggested above, ensure the test properly validates the mock was called:\n\n```diff\n    it('should successfully get data from current_active_terms store', async () => {\n+      // Import the service\n+      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n+      \n+      // Mock getDB to return our mockDB\n+      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n+      \n       const testData = {\n         sectionId: '999901',\n         currentTermId: '12345',\n         termName: 'Autumn Term 2025',\n         startDate: '2025-09-01',\n         endDate: '2025-12-15',\n         lastUpdated: 1737765123456,\n       };\n\n       // Setup mock to return wrapped data structure\n       const mockRecord = {\n         key: '999901',\n         data: testData,\n         timestamp: Date.now(),\n       };\n\n       mockDB.get.mockResolvedValue(mockRecord);\n\n-      const result = await IndexedDBService.get(\n+      const result = await ServiceToTest.get(\n         IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n         '999901',\n       );\n\n       expect(result).toEqual(testData);\n       expect(mockDB.get).toHaveBeenCalledWith('current_active_terms', '999901');\n     });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    it('should successfully get data from current_active_terms store', async () => {\n      // Import the service\n      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n      \n      // Mock getDB to return our mockDB\n      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n\n      const testData = {\n        sectionId: '999901',\n        currentTermId: '12345',\n        termName: 'Autumn Term 2025',\n        startDate: '2025-09-01',\n        endDate: '2025-12-15',\n        lastUpdated: 1737765123456,\n      };\n\n      // Setup mock to return wrapped data structure\n      const mockRecord = {\n        key: '999901',\n        data: testData,\n        timestamp: Date.now(),\n      };\n\n      mockDB.get.mockResolvedValue(mockRecord);\n\n      const result = await ServiceToTest.get(\n        IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n        '999901',\n      );\n\n      expect(result).toEqual(testData);\n      expect(mockDB.get).toHaveBeenCalledWith('current_active_terms', '999901');\n    });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>üß∞ Tools</summary>\n\n<details>\n<summary>ü™õ GitHub Check: unit-tests</summary>\n\n[failure] 336-336: src/shared/services/storage/__tests__/indexedDBService.test.js > IndexedDBService Database Upgrade and Store Creation > Current Active Terms Store Operations > should successfully get data from current_active_terms store\nAssertionError: expected null to deeply equal { sectionId: '999901', ‚Ä¶(5) }\n\n- Expected: \n{\n  \"currentTermId\": \"12345\",\n  \"endDate\": \"2025-12-15\",\n  \"lastUpdated\": 1737765123456,\n  \"sectionId\": \"999901\",\n  \"startDate\": \"2025-09-01\",\n  \"termName\": \"Autumn Term 2025\",\n}\n\n+ Received: \nnull\n\n ‚ùØ src/shared/services/storage/__tests__/indexedDBService.test.js:336:22\n\n\n\n</details>\n<details>\n<summary>ü™õ GitHub Actions: CI/CD Pipeline</summary>\n\n[error] 336-336: AssertionError: expected null to deeply equal { sectionId: '999901', ‚Ä¶(5) }\n\n</details>\n\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBService.test.js around lines\n312 to 339, the test's mock for the get operation returns an object shape that\nthe service unwraps (data property) but the test isn't hitting the mock because\ngetDB is mis-mocked; fix the getDB mock to return the mockDB object that exposes\nget, then ensure mockDB.get resolves to an object with the same wrapped shape\nthe service expects (e.g., { key, data: testData, timestamp }), call\nIndexedDBService.get as written, and finally assert both that the returned value\nequals testData and that mockDB.get was called with 'current_active_terms' and\n'999901'.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:armadillo -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 339,
    "path": "src/shared/services/storage/__tests__/indexedDBService.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix delete operation test to properly mock getDB**\n\nThe delete test is failing because the mock setup doesn't properly connect to the IndexedDBService.\n\n\nApply this fix:\n\n```diff\n    it('should successfully delete data from current_active_terms store', async () => {\n+      // Import the service\n+      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n+      \n+      // Mock getDB to return our mockDB\n+      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n+      \n       // Setup mock to resolve successfully\n       mockDB.delete.mockResolvedValue(undefined);\n\n-      const result = await IndexedDBService.delete(\n+      const result = await ServiceToTest.delete(\n         IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n         '999901',\n       );\n\n       expect(result).toBe(true);\n       expect(mockDB.delete).toHaveBeenCalledWith('current_active_terms', '999901');\n     });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    it('should successfully delete data from current_active_terms store', async () => {\n      // Import the service\n      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n      \n      // Mock getDB to return our mockDB\n      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n      \n      // Setup mock to resolve successfully\n      mockDB.delete.mockResolvedValue(undefined);\n\n      const result = await ServiceToTest.delete(\n        IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n        '999901',\n      );\n\n      expect(result).toBe(true);\n      expect(mockDB.delete).toHaveBeenCalledWith('current_active_terms', '999901');\n    });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>üß∞ Tools</summary>\n\n<details>\n<summary>ü™õ GitHub Check: unit-tests</summary>\n\n[failure] 361-361: src/shared/services/storage/__tests__/indexedDBService.test.js > IndexedDBService Database Upgrade and Store Creation > Current Active Terms Store Operations > should successfully delete data from current_active_terms store\nAssertionError: expected \"spy\" to be called with arguments: [ 'current_active_terms', '999901' ]\n\nNumber of calls: 0\n\n ‚ùØ src/shared/services/storage/__tests__/indexedDBService.test.js:361:29\n\n\n\n</details>\n<details>\n<summary>ü™õ GitHub Actions: CI/CD Pipeline</summary>\n\n[error] 361-361: AssertionError: expected \"spy\" to have been called with arguments: [ 'current_active_terms', '999901' ]\n\n</details>\n\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBService.test.js around lines\n351 to 362, the delete test fails because IndexedDBService.delete calls getDB\nbut the test never mocks getDB to return the mockDB; update the test to spy/mock\nIndexedDBService.getDB (e.g., jest.spyOn or mockResolvedValue) so it resolves to\nthe existing mockDB before calling IndexedDBService.delete, keep\nmockDB.delete.mockResolvedValue(undefined) as-is, and optionally restore the\ngetDB spy after the test.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:armadillo -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 362,
    "path": "src/shared/services/storage/__tests__/indexedDBService.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix getByIndex test to handle array mapping properly**\n\nThe test is failing because the IndexedDBService expects to map over the results array, but the mock setup isn't properly connected.\n\n\nApply this fix to properly mock the service:\n\n```diff\n    it('should query by lastUpdated index', async () => {\n+      // Import the service\n+      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n+      \n+      // Mock getDB to return our mockDB\n+      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n+      \n       const mockTerms = [\n         {\n           key: '999901',\n           data: { sectionId: '999901', lastUpdated: 1737765123456 },\n         },\n         {\n           key: '999902',\n           data: { sectionId: '999902', lastUpdated: 1737765234567 },\n         },\n       ];\n\n       // Ensure mock returns array\n       mockDB.getAllFromIndex.mockResolvedValue(mockTerms);\n\n       const timestamp = 1737765000000;\n       const keyRange = { lower: timestamp, lowerOpen: false };\n\n-      const result = await IndexedDBService.getByIndex(\n+      const result = await ServiceToTest.getByIndex(\n         IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n         'lastUpdated',\n         keyRange,\n       );\n\n       expect(result).toEqual([\n         { sectionId: '999901', lastUpdated: 1737765123456 },\n         { sectionId: '999902', lastUpdated: 1737765234567 },\n       ]);\n\n       expect(mockDB.getAllFromIndex).toHaveBeenCalledWith(\n         'current_active_terms',\n         'lastUpdated',\n         keyRange,\n       );\n     });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    it('should query by lastUpdated index', async () => {\n      // Import the service\n      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n      \n      // Mock getDB to return our mockDB\n      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n\n      const mockTerms = [\n        {\n          key: '999901',\n          data: { sectionId: '999901', lastUpdated: 1737765123456 },\n        },\n        {\n          key: '999902',\n          data: { sectionId: '999902', lastUpdated: 1737765234567 },\n        },\n      ];\n\n      // Ensure mock returns array\n      mockDB.getAllFromIndex.mockResolvedValue(mockTerms);\n\n      const timestamp = 1737765000000;\n      const keyRange = { lower: timestamp, lowerOpen: false };\n\n      const result = await ServiceToTest.getByIndex(\n        IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n        'lastUpdated',\n        keyRange,\n      );\n\n      expect(result).toEqual([\n        { sectionId: '999901', lastUpdated: 1737765123456 },\n        { sectionId: '999902', lastUpdated: 1737765234567 },\n      ]);\n\n      expect(mockDB.getAllFromIndex).toHaveBeenCalledWith(\n        'current_active_terms',\n        'lastUpdated',\n        keyRange,\n      );\n    });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>üß∞ Tools</summary>\n\n<details>\n<summary>ü™õ GitHub Actions: CI/CD Pipeline</summary>\n\n[error] 382-382: TypeError: Cannot read properties of undefined (reading 'map')\n\n</details>\n\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBService.test.js around lines\n364 to 398, the mock for mockDB.getAllFromIndex returns objects with {key, data}\nbut IndexedDBService.getByIndex maps over results expecting the raw data\nobjects; update the mock to return an array of data objects instead (e.g.,\nmockDB.getAllFromIndex.mockResolvedValue(mockTerms.map(t => t.data))) so the\nservice mapping works and the test assertions remain valid.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:armadillo -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 398,
    "path": "src/shared/services/storage/__tests__/indexedDBService.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix error handling test to properly simulate database errors**\n\nThe error handling test expects a rejection but the mock isn't properly connected to the service.\n\n\nApply this fix:\n\n```diff\n    it('should handle database operation errors gracefully', async () => {\n       // Clear any existing mock setup first\n       vi.clearAllMocks();\n+      \n+      // Import the service\n+      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n\n       const error = new Error('Database connection failed');\n       mockDB.get.mockRejectedValue(error);\n\n-      // Reset the openDB mock to use our error-throwing mockDB\n-      const { openDB } = await import('idb');\n-      openDB.mockResolvedValue(mockDB);\n+      // Mock getDB to return our mockDB\n+      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n\n       await expect(\n-        IndexedDBService.get(IndexedDBService.STORES.CURRENT_ACTIVE_TERMS, '999901'),\n+        ServiceToTest.get(ServiceToTest.STORES.CURRENT_ACTIVE_TERMS, '999901'),\n       ).rejects.toThrow('Database connection failed');\n\n       // Verify error was logged and sent to Sentry\n       const logger = (await import('../../utils/logger.js')).default;\n       const { sentryUtils } = await import('../../utils/sentry.js');\n\n       expect(logger.error).toHaveBeenCalledWith(\n         'IndexedDB get failed',\n         expect.objectContaining({\n           storeName: 'current_active_terms',\n           key: '999901',\n           error: 'Database connection failed',\n         }),\n         'ERROR',\n       );\n\n       expect(sentryUtils.captureException).toHaveBeenCalledWith(\n         error,\n         expect.objectContaining({\n           tags: {\n             operation: 'indexeddb_get',\n             store: 'current_active_terms',\n           },\n         }),\n       );\n     });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    it('should handle database operation errors gracefully', async () => {\n      // Clear any existing mock setup first\n      vi.clearAllMocks();\n\n      // Import the service\n      const { IndexedDBService: ServiceToTest } = await import('../indexedDBService.js');\n\n      const error = new Error('Database connection failed');\n      mockDB.get.mockRejectedValue(error);\n\n      // Mock getDB to return our mockDB\n      vi.spyOn(ServiceToTest, 'getDB').mockResolvedValue(mockDB);\n\n      await expect(\n        ServiceToTest.get(ServiceToTest.STORES.CURRENT_ACTIVE_TERMS, '999901'),\n      ).rejects.toThrow('Database connection failed');\n\n      // Verify error was logged and sent to Sentry\n      const logger = (await import('../../utils/logger.js')).default;\n      const { sentryUtils } = await import('../../utils/sentry.js');\n\n      expect(logger.error).toHaveBeenCalledWith(\n        'IndexedDB get failed',\n        expect.objectContaining({\n          storeName: 'current_active_terms',\n          key: '999901',\n          error: 'Database connection failed',\n        }),\n        'ERROR',\n      );\n\n      expect(sentryUtils.captureException).toHaveBeenCalledWith(\n        error,\n        expect.objectContaining({\n          tags: {\n            operation: 'indexeddb_get',\n            store: 'current_active_terms',\n          },\n        }),\n      );\n    });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>üß∞ Tools</summary>\n\n<details>\n<summary>ü™õ GitHub Check: unit-tests</summary>\n\n[failure] 449-449: src/shared/services/storage/__tests__/indexedDBService.test.js > IndexedDBService Database Upgrade and Store Creation > Error Handling > should handle database operation errors gracefully\nAssertionError: promise resolved \"null\" instead of rejecting\n\n- Expected: \nError {\n  \"message\": \"rejected promise\",\n}\n\n+ Received: \nnull\n\n ‚ùØ src/shared/services/storage/__tests__/indexedDBService.test.js:449:8\n\n\n\n</details>\n<details>\n<summary>ü™õ GitHub Actions: CI/CD Pipeline</summary>\n\n[error] 449-449: Promise rejection expectation failed: expected rejection with 'Database connection failed' but got null\n\n</details>\n\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBService.test.js around lines\n436 to 474, the test fails to wire the mocked idb.openDB to the service because\nthe service module is imported before the openDB mock is applied; reset the\nmodule registry (vi.resetModules()) and mock idb.openDB to resolve to mockDB\n(with mockDB.get mockedRejectedValue(error)) before importing IndexedDBService\nso the service uses the error-throwing mock connection, then import the service\nand run the expect/rejection assertions and verify logger/sentry calls.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:armadillo -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 474,
    "path": "src/shared/services/storage/__tests__/indexedDBService.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\n**Fix ESM mock ordering to make the idb mock effective and set actualUpgradeHandler**\n\n`IndexedDBService` is imported before `vi.mock('idb')`, so the service binds to the real `openDB`. This prevents your spy from being called and leaves `actualUpgradeHandler` unset, causing multiple test failures. Convert the service import to a dynamic import after mocks and reset modules per test.\n\nApply this diff:\n\n```diff\n-import { IndexedDBService } from '../indexedDBService.js';\n+// Defer importing the service until after mocks are in place\n+let IndexedDBService;\n@@\n-beforeEach(() => {\n-  vi.clearAllMocks();\n-  mockDB = null;\n-  actualUpgradeHandler = null;\n-});\n+beforeEach(async () => {\n+  vi.resetModules();\n+  vi.clearAllMocks();\n+  mockDB = null;\n+  actualUpgradeHandler = null;\n+  ({ IndexedDBService } = await import('../indexedDBService.js'));\n+});\n```\n\n\n\n\nAlso applies to: 91-96\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Locate the test file and preview import and mock ordering\ntest_file=$(fd --exclude node_modules 'indexedDBStoreCreation.test.js')\necho \"Test file: $test_file\"\nsed -n '1,100p' \"$test_file\"\n```\n\nLength of output: 2709\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Display the implementation of IndexedDBService to verify import and upgrade handler behaviour\nfile=$(fd --exclude node_modules 'indexedDBService.js')\necho \"Service file: $file\"\nsed -n '1,200p' \"$file\"\n```\n\nLength of output: 6735\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Locate Vitest configuration and inspect mock hoisting settings\nconfig=$(fd --max-depth 2 'vitest.config.*' || echo \"\")\nif [ -n \"$config\" ]; then\n  echo \"Found config: $config\"\n  sed -n '1,200p' \"$config\"\nelse\n  echo \"No vitest.config.* found\"\nfi\n```\n\nLength of output: 24\n\n---\n\n\n\n</details>\n\n**Defer `IndexedDBService` import until after `vi.mock('idb')`**\n\nMove the static import into an async `beforeEach` with `vi.resetModules()` and dynamic `import(...)` so the `idb` mock replaces `openDB`.\n\n```diff\n-import { IndexedDBService } from '../indexedDBService.js';\n+let IndexedDBService;\n‚Ä¶\n-beforeEach(() => {\n+beforeEach(async () => {\n   vi.resetModules();\n   vi.clearAllMocks();\n   mockDB = null;\n   actualUpgradeHandler = null;\n+  ({ IndexedDBService } = await import('../indexedDBService.js'));\n});\n```\nApplies also to lines 91‚Äì96.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBStoreCreation.test.js around\nlines 2 and 91‚Äì96, the test statically imports IndexedDBService before\nvi.mock('idb'), preventing the idb mock from replacing openDB; to fix, remove\nthe top-level import and instead call vi.resetModules() and vi.mock('idb') in a\nbeforeEach (or beforeAll as appropriate), then dynamically import\nIndexedDBService with await import('../indexedDBService.js') inside that setup\nso the mocked idb module is loaded and used by the service; apply the same\npattern to the code referenced at lines 91‚Äì96.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 2,
    "path": "src/shared/services/storage/__tests__/indexedDBStoreCreation.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Make objectStoreNames iterable to avoid Array.from crash in upgrade logging**\n\n`upgrade` logs `Array.from(db.objectStoreNames)`. Your mock only implements `contains`, so `Array.from` throws. Implement an iterator over the store names.\n\nApply this diff:\n\n```diff\n-      objectStoreNames: {\n-        contains: (storeName) => mockDB._stores.has(storeName),\n-      },\n+      objectStoreNames: {\n+        contains: (storeName) => mockDB._stores.has(storeName),\n+        [Symbol.iterator]: function* () {\n+          yield* mockDB._stores.keys();\n+        },\n+      },\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n      // Mock the contains method\n      objectStoreNames: {\n        contains: (storeName) => mockDB._stores.has(storeName),\n        [Symbol.iterator]: function* () {\n          yield* mockDB._stores.keys();\n        },\n      },\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/__tests__/indexedDBStoreCreation.test.js around\nlines 51-55, the mocked objectStoreNames only implements contains, causing\nArray.from(db.objectStoreNames) to throw; update the mock to be iterable by\nadding a [Symbol.iterator]() that yields each store name from mockDB._stores\n(and optionally implement length/item to more closely mimic DOMStringList),\nwhile preserving the contains method so upgrade logging using Array.from works\nwithout errors.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 55,
    "path": "src/shared/services/storage/__tests__/indexedDBStoreCreation.test.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix incorrect logger import (named vs default).**\n\nlogger is a named export; default import will be undefined at runtime.\n\nApply this diff:\n\n```diff\n-import logger, { LOG_CATEGORIES } from '../utils/logger.js';\n+import { logger, LOG_CATEGORIES } from '../utils/logger.js';\n```\n\nBased on learnings\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nimport { logger, LOG_CATEGORIES } from '../utils/logger.js';\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/currentActiveTermsService.js around line 3, the\nfile currently uses a default import for logger but logger is a named export;\nreplace the default import with a named import so both logger and LOG_CATEGORIES\nare imported as named bindings from '../utils/logger.js' (i.e., change the\nimport statement to use curly braces for the exported identifiers).\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 3,
    "path": "src/shared/services/storage/currentActiveTermsService.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix incompatible use of IndexedDBService.getByIndex (drops raw records).**\n\nIndexedDBService.getByIndex maps results to .data, which will return undefined for this store (you‚Äôre storing raw objects via db.put). Query the index directly via the DB and fall back to filtering if IDBKeyRange is unavailable.\n\nApply this diff:\n\n```diff\n-  static async getTermsUpdatedSince(timestamp) {\n-    try {\n-      const keyRange = typeof IDBKeyRange !== 'undefined'\n-        ? IDBKeyRange.lowerBound(timestamp)\n-        : { lower: timestamp, lowerOpen: false };\n-\n-      const recentTerms = await IndexedDBService.getByIndex(\n-        IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n-        'lastUpdated',\n-        keyRange,\n-      );\n-\n-      logger.debug('Retrieved terms updated since timestamp', {\n-        timestamp,\n-        count: recentTerms.length,\n-      }, LOG_CATEGORIES.DATABASE);\n-\n-      return recentTerms;\n-    } catch (error) {\n-      logger.error('Failed to get terms updated since timestamp', {\n-        timestamp,\n-        error: error.message,\n-      }, LOG_CATEGORIES.ERROR);\n-      throw error;\n-    }\n-  }\n+  static async getTermsUpdatedSince(timestamp) {\n+    try {\n+      const db = await IndexedDBService.getDB();\n+      let results = [];\n+\n+      if (db?.getAllFromIndex && typeof IDBKeyRange !== 'undefined') {\n+        results = await db.getAllFromIndex(\n+          IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n+          'lastUpdated',\n+          IDBKeyRange.lowerBound(timestamp),\n+        );\n+      } else {\n+        // Fallback when IDBKeyRange or index APIs are unavailable\n+        const all = await this.getAllCurrentActiveTerms();\n+        results = all.filter(t => (t?.lastUpdated ?? 0) >= timestamp);\n+      }\n+\n+      logger.debug('Retrieved terms updated since timestamp', {\n+        timestamp,\n+        count: results.length,\n+      }, LOG_CATEGORIES.DATABASE);\n+\n+      // Normalise potential wrapped records\n+      return results.map(r => r?.data || r);\n+    } catch (error) {\n+      logger.error('Failed to get terms updated since timestamp', {\n+        timestamp,\n+        error: error.message,\n+      }, LOG_CATEGORIES.ERROR);\n+      throw error;\n+    }\n+  }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  static async getTermsUpdatedSince(timestamp) {\n    try {\n      const db = await IndexedDBService.getDB();\n      let results = [];\n\n      if (db?.getAllFromIndex && typeof IDBKeyRange !== 'undefined') {\n        results = await db.getAllFromIndex(\n          IndexedDBService.STORES.CURRENT_ACTIVE_TERMS,\n          'lastUpdated',\n          IDBKeyRange.lowerBound(timestamp),\n        );\n      } else {\n        // Fallback when IDBKeyRange or index APIs are unavailable\n        const all = await this.getAllCurrentActiveTerms();\n        results = all.filter(t => (t?.lastUpdated ?? 0) >= timestamp);\n      }\n\n      logger.debug('Retrieved terms updated since timestamp', {\n        timestamp,\n        count: results.length,\n      }, LOG_CATEGORIES.DATABASE);\n\n      // Normalise potential wrapped records\n      return results.map(r => r?.data || r);\n    } catch (error) {\n      logger.error('Failed to get terms updated since timestamp', {\n        timestamp,\n        error: error.message,\n      }, LOG_CATEGORIES.ERROR);\n      throw error;\n    }\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/currentActiveTermsService.js around lines 80 to\n98, IndexedDBService.getByIndex is inappropriate because it maps to .data (which\nis undefined for this store); instead open the underlying DB and query the\nCURRENT_ACTIVE_TERMS store‚Äôs 'lastUpdated' index directly using\nIDBKeyRange.lowerBound(timestamp) (or index.getAll(keyRange) / openCursor to\ncollect record values) and return the raw objects; if IDBKeyRange is\nunavailable, fall back to reading all records from the store and filter by\nrecord.lastUpdated >= timestamp before returning.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 98,
    "path": "src/shared/services/storage/currentActiveTermsService.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Preserve conflict and local-mod flags when rewriting attendance rows.**\n\nDeleting and reinserting rows resets conflict_resolution_needed and is_locally_modified unless explicitly preserved. Also include these fields in the pre-fetch.\n\nApply this diff:\n\n```diff\n-    // Begin transaction for atomic updates\n+    // Begin transaction for atomic updates\n     await this.db.execute('BEGIN TRANSACTION');\n@@\n-      const existingQuery = 'SELECT eventid, scoutid, version, local_version, last_sync_version FROM attendance WHERE eventid = ?';\n+      const existingQuery = 'SELECT eventid, scoutid, version, local_version, last_sync_version, is_locally_modified, conflict_resolution_needed FROM attendance WHERE eventid = ?';\n       const existingResult = await this.db.query(existingQuery, [eventId]);\n       const existingRecords = new Map();\n@@\n-        let version = person.version || 1;\n-        let localVersion = person.local_version || 1;\n-        let lastSyncVersion = person.last_sync_version || 0;\n+        let version = person.version || 1;\n+        let localVersion = person.local_version || 1;\n+        let lastSyncVersion = person.last_sync_version || 0;\n+        let conflictNeeded = !!person.conflict_resolution_needed;\n+        let locallyModifiedFlag = isLocalMod ? 1 : 0;\n@@\n         if (existing) {\n           if (isLocalMod) {\n             // Local modification - increment local version\n             localVersion = existing.local_version + 1;\n             version = Math.max(existing.version, version);\n+            // Preserve existing conflict flag on local edits\n+            conflictNeeded = existing.conflict_resolution_needed === 1 || conflictNeeded;\n+            locallyModifiedFlag = 1;\n           } else if (fromSync) {\n             // Sync from server - update version tracking\n             version = options.remoteVersion || version;\n             lastSyncVersion = version;\n+            // Clear conflict and local flags on successful sync\n+            conflictNeeded = false;\n+            locallyModifiedFlag = 0;\n           } else {\n             // Preserve existing versions\n             version = existing.version;\n             localVersion = existing.local_version;\n             lastSyncVersion = existing.last_sync_version;\n+            // Preserve existing flags when not explicitly changing them\n+            conflictNeeded = existing.conflict_resolution_needed === 1 || conflictNeeded;\n+            locallyModifiedFlag = existing.is_locally_modified === 1 ? 1 : locallyModifiedFlag;\n           }\n         }\n@@\n           INSERT INTO attendance (\n             eventid, scoutid, firstname, lastname, attending, patrol, notes,\n             version, local_version, last_sync_version, is_locally_modified,\n             updated_at, last_synced_at, conflict_resolution_needed\n           )\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n@@\n-          isLocalMod ? 1 : 0,\n+          locallyModifiedFlag,\n           currentTime,\n           fromSync ? currentTime : null,\n-          person.conflict_resolution_needed ? 1 : 0,\n+          conflictNeeded ? 1 : 0,\n         ]);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    // Begin transaction for atomic updates\n    await this.db.execute('BEGIN TRANSACTION');\n\n    const existingQuery = \n      'SELECT eventid, scoutid, version, local_version, last_sync_version, is_locally_modified, conflict_resolution_needed FROM attendance WHERE eventid = ?';\n    const existingResult = await this.db.query(existingQuery, [eventId]);\n    const existingRecords = new Map();\n\n    if (existingResult.values) {\n      for (const record of existingResult.values) {\n        existingRecords.set(record.scoutid, record);\n      }\n    }\n\n    // Delete existing attendance for this event\n    const deleteOld = 'DELETE FROM attendance WHERE eventid = ?';\n    await this.db.run(deleteOld, [eventId]);\n\n    for (const person of attendanceData) {\n      const existing = existingRecords.get(person.scoutid);\n\n      let version = person.version || 1;\n      let localVersion = person.local_version || 1;\n      let lastSyncVersion = person.last_sync_version || 0;\n      let conflictNeeded = !!person.conflict_resolution_needed;\n      let locallyModifiedFlag = isLocalMod ? 1 : 0;\n\n      if (existing) {\n        if (isLocalMod) {\n          // Local modification - increment local version\n          localVersion = existing.local_version + 1;\n          version = Math.max(existing.version, version);\n          // Preserve existing conflict flag on local edits\n          conflictNeeded = existing.conflict_resolution_needed === 1 || conflictNeeded;\n          locallyModifiedFlag = 1;\n        } else if (fromSync) {\n          // Sync from server - update version tracking\n          version = options.remoteVersion || version;\n          lastSyncVersion = version;\n          // Clear conflict and local flags on successful sync\n          conflictNeeded = false;\n          locallyModifiedFlag = 0;\n        } else {\n          // Preserve existing versions\n          version = existing.version;\n          localVersion = existing.local_version;\n          lastSyncVersion = existing.last_sync_version;\n          // Preserve existing flags when not explicitly changing them\n          conflictNeeded = existing.conflict_resolution_needed === 1 || conflictNeeded;\n          locallyModifiedFlag = existing.is_locally_modified === 1 ? 1 : locallyModifiedFlag;\n        }\n      }\n\n      const insert = `\n        INSERT INTO attendance (\n          eventid, scoutid, firstname, lastname, attending, patrol, notes,\n          version, local_version, last_sync_version, is_locally_modified,\n          updated_at, last_synced_at, conflict_resolution_needed\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n\n      await this.db.run(insert, [\n        eventId,\n        person.scoutid,\n        person.firstname,\n        person.lastname,\n        person.attending,\n        person.patrol,\n        person.notes,\n        version,\n        localVersion,\n        lastSyncVersion,\n        locallyModifiedFlag,\n        currentTime,\n        fromSync ? currentTime : null,\n        conflictNeeded ? 1 : 0,\n      ]);\n    }\n\n    await this.db.execute('COMMIT');\n    await this.updateSyncStatus('attendance');\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/database.js around lines 601 to 703, the code\ndeletes and reinserts attendance rows but does not preserve the existing\nconflict_resolution_needed and is_locally_modified flags; update the SELECT to\nalso fetch conflict_resolution_needed and is_locally_modified into\nexistingRecords, and when building the INSERT values compute those two fields by\npreferring the incoming person values if provided, otherwise falling back to the\nexisting record (and for is_locally_modified also set to 1 when\noptions.isLocalModification is true); ensure you use the existing flags when\nperson.* is undefined so rewriting rows does not reset those flags.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 703,
    "path": "src/shared/services/storage/database.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Harden dynamic SQL against injection by whitelisting table names.**\n\nMethods build SQL with ${tableName}. Restrict to known tables before interpolation.\n\nApply this diff:\n\n```diff\n   async getConflictRecords(tableName = 'attendance') {\n@@\n-    const query = `SELECT * FROM ${tableName} WHERE conflict_resolution_needed = 1`;\n+    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n+    const query = `SELECT * FROM ${table} WHERE conflict_resolution_needed = 1`;\n@@\n   async getLocallyModifiedRecords(tableName = 'attendance') {\n@@\n-    const query = `SELECT * FROM ${tableName} WHERE is_locally_modified = 1 AND local_version > last_sync_version`;\n+    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n+    const query = `SELECT * FROM ${table} WHERE is_locally_modified = 1 AND local_version > last_sync_version`;\n@@\n   async markConflict(tableName, recordId, hasConflict = true) {\n@@\n-    const query = `UPDATE ${tableName} SET conflict_resolution_needed = ? WHERE id = ?`;\n+    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n+    const query = `UPDATE ${table} SET conflict_resolution_needed = ? WHERE id = ?`;\n@@\n   async getRecordVersions(tableName, recordId) {\n@@\n-    const query = `\n+    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n+    const query = `\n       SELECT version, local_version, last_sync_version, is_locally_modified,\n              updated_at, last_synced_at, conflict_resolution_needed\n-      FROM ${tableName} WHERE id = ?\n+      FROM ${table} WHERE id = ?\n     `;\n@@\n   async updateRecordVersions(tableName, recordId, versions) {\n@@\n-    const query = `\n+    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n+    const query = `\n-      UPDATE ${tableName} SET\n+      UPDATE ${table} SET\n         version = ?,\n         local_version = ?,\n         last_sync_version = ?,\n         is_locally_modified = ?,\n         conflict_resolution_needed = ?,\n         last_synced_at = CURRENT_TIMESTAMP,\n         updated_at = CURRENT_TIMESTAMP\n       WHERE id = ?\n     `;\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  /**\n   * Get records with conflicts that need resolution\n   */\n  async getConflictRecords(tableName = 'attendance') {\n    await this.initialize();\n\n    if (!this.isNative || !this.db) {\n      return [];\n    }\n\n    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n    const query = `SELECT * FROM ${table} WHERE conflict_resolution_needed = 1`;\n    const result = await this.db.query(query);\n    return result.values || [];\n  }\n\n  /**\n   * Get locally modified records that haven't been synced\n   */\n  async getLocallyModifiedRecords(tableName = 'attendance') {\n    await this.initialize();\n\n    if (!this.isNative || !this.db) {\n      return [];\n    }\n\n    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n    const query = `SELECT * FROM ${table} WHERE is_locally_modified = 1 AND local_version > last_sync_version`;\n    const result = await this.db.query(query);\n    return result.values || [];\n  }\n\n  /**\n   * Mark record as having a conflict\n   */\n  async markConflict(tableName, recordId, hasConflict = true) {\n    await this.initialize();\n\n    if (!this.isNative || !this.db) {\n      return;\n    }\n\n    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n    const query = `UPDATE ${table} SET conflict_resolution_needed = ? WHERE id = ?`;\n    await this.db.run(query, [hasConflict ? 1 : 0, recordId]);\n  }\n\n  /**\n   * Get version information for a record\n   */\n  async getRecordVersions(tableName, recordId) {\n    await this.initialize();\n\n    if (!this.isNative || !this.db) {\n      return null;\n    }\n\n    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n    const query = `\n      SELECT version, local_version, last_sync_version, is_locally_modified,\n             updated_at, last_synced_at, conflict_resolution_needed\n      FROM ${table} WHERE id = ?\n    `;\n    const result = await this.db.query(query, [recordId]);\n    return result.values?.[0] || null;\n  }\n\n  /**\n   * Update record versions after sync\n   */\n  async updateRecordVersions(tableName, recordId, versions) {\n    await this.initialize();\n\n    if (!this.isNative || !this.db) {\n      return;\n    }\n\n    const {\n      version,\n      localVersion,\n      lastSyncVersion,\n      isLocallyModified = false,\n      conflictResolutionNeeded = false,\n    } = versions;\n\n    const table = ['attendance', 'members'].includes(tableName) ? tableName : 'attendance';\n    const query = `\n      UPDATE ${table} SET\n        version = ?,\n        local_version = ?,\n        last_sync_version = ?,\n        is_locally_modified = ?,\n        conflict_resolution_needed = ?,\n        last_synced_at = CURRENT_TIMESTAMP,\n        updated_at = CURRENT_TIMESTAMP\n      WHERE id = ?\n    `;\n\n    await this.db.run(query, [\n      version,\n      localVersion,\n      lastSyncVersion,\n      isLocallyModified ? 1 : 0,\n      conflictResolutionNeeded ? 1 : 0,\n      recordId,\n    ]);\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/database.js around lines 1219 to 1319 the SQL\nstrings interpolate tableName directly which risks SQL injection; validate\ntableName against a whitelist of allowed table names (e.g., an array or Set of\nknown table names used by the app) and either map incoming names to those safe\nvalues or throw an error when the name is not allowed before using it in the\nquery; keep all other query parameters parameterized as-is and replace direct\ninterpolation only after confirming the tableName is in the whitelist so all\nmethods (getConflictRecords, getLocallyModifiedRecords, markConflict,\ngetRecordVersions, updateRecordVersions) use the safe table identifier.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 1319,
    "path": "src/shared/services/storage/database.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Prevent false ‚Äúsync complete‚Äù state when attendance fails**\n\nIf `refreshAllEventAttendance()` throws or reports `success: false`, we still set the last-sync timestamp and broadcast `dashboard_complete` with ‚ÄúAll data loaded including attendance‚Äù. That contradicts the earlier `attendance_sync_failed` notification and causes the dashboard to believe it is fully up to date. Please gate the completion flow (and the timestamp write) on the attendance step actually succeeding.\n\n```diff\n-      try {\n+      let attendanceSyncSucceeded = true;\n+      try {\n         logger.info('Starting attendance sync using EventSyncService', {\n           hasToken: !!token,\n           timestamp: Date.now(),\n         }, LOG_CATEGORIES.SYNC);\n \n         this.notifyListeners({\n           status: 'syncing',\n           message: 'Loading attendance data...',\n           timestamp: Date.now(),\n         });\n \n         const attendanceSyncResult = await eventSyncService.refreshAllEventAttendance();\n \n         logger.info('EventSyncService attendance sync completed', {\n           success: attendanceSyncResult.success,\n           message: attendanceSyncResult.message,\n           details: attendanceSyncResult.details,\n         }, LOG_CATEGORIES.SYNC);\n \n         if (!attendanceSyncResult.success) {\n+          attendanceSyncSucceeded = false;\n           logger.warn('Attendance sync completed with errors', {\n             message: attendanceSyncResult.message,\n           }, LOG_CATEGORIES.SYNC);\n         }\n \n       } catch (attendanceError) {\n         logger.error('EventSyncService attendance sync failed', {\n           error: attendanceError.message,\n         }, LOG_CATEGORIES.SYNC);\n \n         this.notifyListeners({\n           status: 'attendance_sync_failed',\n           message: `Attendance sync failed: ${attendanceError.message}`,\n           timestamp: Date.now(),\n         });\n+        attendanceSyncSucceeded = false;\n       }\n \n+      if (!attendanceSyncSucceeded) {\n+        return;\n+      }\n+\n       const completionTimestamp = Date.now();\n       try {\n         await UnifiedStorageService.setLastSync(String(completionTimestamp));\n       } catch (e) {\n         logger.warn('Failed to persist last sync timestamp', { error: e.message }, LOG_CATEGORIES.SYNC);\n       }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n      // Sync attendance data using simplified EventSyncService\n      let attendanceSyncSucceeded = true;\n      try {\n        logger.info('Starting attendance sync using EventSyncService', {\n          hasToken: !!token,\n          timestamp: Date.now(),\n        }, LOG_CATEGORIES.SYNC);\n\n        this.notifyListeners({\n          status: 'syncing',\n          message: 'Loading attendance data...',\n          timestamp: Date.now(),\n        });\n\n        const attendanceSyncResult = await eventSyncService.refreshAllEventAttendance();\n\n        logger.info('EventSyncService attendance sync completed', {\n          success: attendanceSyncResult.success,\n          message: attendanceSyncResult.message,\n          details: attendanceSyncResult.details,\n        }, LOG_CATEGORIES.SYNC);\n\n        if (!attendanceSyncResult.success) {\n          attendanceSyncSucceeded = false;\n          logger.warn('Attendance sync completed with errors', {\n            message: attendanceSyncResult.message,\n          }, LOG_CATEGORIES.SYNC);\n        }\n\n      } catch (attendanceError) {\n        logger.error('EventSyncService attendance sync failed', {\n          error: attendanceError.message,\n        }, LOG_CATEGORIES.SYNC);\n\n        this.notifyListeners({\n          status: 'attendance_sync_failed',\n          message: `Attendance sync failed: ${attendanceError.message}`,\n          timestamp: Date.now(),\n        });\n        attendanceSyncSucceeded = false;\n      }\n\n      if (!attendanceSyncSucceeded) {\n        return;\n      }\n\n      const completionTimestamp = Date.now();\n      try {\n        await UnifiedStorageService.setLastSync(String(completionTimestamp));\n      } catch (e) {\n        logger.warn('Failed to persist last sync timestamp', { error: e.message }, LOG_CATEGORIES.SYNC);\n      }\n\n      // NOW notify dashboard data is complete - attendance is fully synced\n      this.notifyListeners({\n        status: 'dashboard_complete',\n        message: 'All data loaded including attendance',\n        timestamp: completionTimestamp,\n      });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/services/storage/sync.js around lines 225 to 276, the code always\nwrites the last-sync timestamp and emits the 'dashboard_complete' notification\neven when refreshAllEventAttendance() throws or returns success: false; declare\na variable (e.g. attendanceSyncResult or attendanceSucceeded) before the try,\nset it to true only when the attendance try block completes with success ===\ntrue, set it to false in the catch or when attendanceSyncResult.success is\nfalse, and then wrap the UnifiedStorageService.setLastSync(...) call and the\nfinal this.notifyListeners({ status: 'dashboard_complete', ... }) inside a\nconditional that runs only when attendanceSucceeded === true; ensure failures\nkeep the existing attendance_sync_failed notification and do not persist\nlast-sync or emit dashboard_complete.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": null,
    "path": "src/shared/services/storage/sync.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Missing fallback when no current term exists (logic gap)**\n\nIf CurrentActiveTermsService returns null/undefined (no record) without throwing, termId stays null and the API path returns no events despite having a token.\n\nApply:\n\n```diff\n-      let termId = null;\n-      try {\n-        const currentTerm = await CurrentActiveTermsService.getCurrentActiveTerm(section.sectionid);\n-        termId = currentTerm?.currentTermId || null;\n-        if (termId) {\n-          // Term ID found, can be used for future operations\n-        }\n-      } catch (tableError) {\n-        logger.warn('Table lookup failed, using API fallback', {\n-          sectionId: section.sectionid, error: tableError.message,\n-        }, LOG_CATEGORIES.APP);\n-        // Fallback to individual API call (will refresh the table)\n-        termId = await fetchMostRecentTermId(section.sectionid, token);\n-      }\n+      let termId = null;\n+      try {\n+        const currentTerm = await CurrentActiveTermsService.getCurrentActiveTerm(section.sectionid);\n+        termId = currentTerm?.currentTermId || null;\n+      } catch (tableError) {\n+        logger.warn('Table lookup failed, using API fallback', {\n+          sectionId: section.sectionid, error: tableError.message,\n+        }, LOG_CATEGORIES.APP);\n+      }\n+      // Fallback if not found in table\n+      if (!termId) {\n+        termId = await fetchMostRecentTermId(section.sectionid, token);\n+      }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n      let termId = null;\n      try {\n        const currentTerm = await CurrentActiveTermsService.getCurrentActiveTerm(section.sectionid);\n        termId = currentTerm?.currentTermId || null;\n      } catch (tableError) {\n        logger.warn(\n          'Table lookup failed, using API fallback',\n          { sectionId: section.sectionid, error: tableError.message },\n          LOG_CATEGORIES.APP\n        );\n      }\n      // Fallback if not found in table\n      if (!termId) {\n        termId = await fetchMostRecentTermId(section.sectionid, token);\n      }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/utils/eventDashboardHelpers.js around lines 65 to 78,\nCurrentActiveTermsService may return null/undefined without throwing, leaving\ntermId null and skipping the API fallback; update the logic so that after\nassigning termId = currentTerm?.currentTermId || null you check if termId is\nfalsy and, if so, call await fetchMostRecentTermId(section.sectionid, token) to\npopulate termId (same as the catch path), and add minimal logging/try-catch\naround that fallback call to surface errors while preserving existing behavior.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": null,
    "path": "src/shared/utils/eventDashboardHelpers.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Match real localStorage semantics in the mock**\n\nThe new mock diverges from the browser behaviour: `getItem` now returns `null` when the stored value is an empty string and `setItem` keeps non-string values as-is, whereas the real API always returns the exact string that was persisted (and stringifies inputs). This will mask bugs and can break code that legitimately stores empty strings or relies on string coercion. Please align the mock with the platform contract.\n\n```diff\n-  getItem: vi.fn((key) => localStorageMock.storage.get(key) || null),\n-  setItem: vi.fn((key, value) => localStorageMock.storage.set(key, value)),\n+  getItem: vi.fn((key) => (\n+    localStorageMock.storage.has(key)\n+      ? localStorageMock.storage.get(key)\n+      : null\n+  )),\n+  setItem: vi.fn((key, value) => localStorageMock.storage.set(key, String(value))),\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  storage: new Map(),\n  getItem: vi.fn((key) => (\n    localStorageMock.storage.has(key)\n      ? localStorageMock.storage.get(key)\n      : null\n  )),\n  setItem: vi.fn((key, value) => localStorageMock.storage.set(key, String(value))),\n  removeItem: vi.fn((key) => localStorageMock.storage.delete(key)),\n  clear: vi.fn(() => localStorageMock.storage.clear()),\n  get length() { return localStorageMock.storage.size; },\n  key: vi.fn((index) => Array.from(localStorageMock.storage.keys())[index] || null),\n};\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/test/setup.js around lines 14 to 21, the localStorage mock diverges from\nreal browser semantics: getItem returns null for stored empty strings and\nsetItem preserves non-string values. Fix it by ensuring the internal storage\nonly holds string values (coerce inputs with String(value) in setItem), have\ngetItem return the stored string exactly (including empty string) or null only\nwhen the key is absent, and keep other methods (removeItem, clear, key, length)\noperating against that string-only Map so behavior matches the platform\ncontract.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 21,
    "path": "src/test/setup.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üî¥ Critical_\n\n**Fix event filtering: endDate argument missing**\n\n`filterEventsByDateRange` expects both start and end dates. Passing only `oneWeekAgo` means the helper compares each event date to `undefined`, which evaluates to `false` and drops every event. The overview therefore renders no cards even when cache data exists. Please pass the `now` value as the end date.  \n\n```diff\n-    const filteredEvents = filterEventsByDateRange(allEvents, oneWeekAgo);\n+    const filteredEvents = filterEventsByDateRange(allEvents, oneWeekAgo, now);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const filteredEvents = filterEventsByDateRange(allEvents, oneWeekAgo, now);\n\n    // Fetch attendance data for filtered events from IndexedDB only\n    const attendanceMap = new Map();\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/features/events/components/EventsOverview.jsx around lines 81 to 84,\nfilterEventsByDateRange is called with only oneWeekAgo as the start date so the\nhelper receives an undefined endDate and filters out all events; update the call\nto pass both dates by adding the current time variable (now) as the endDate\nargument (e.g., filterEventsByDateRange(allEvents, oneWeekAgo, now)) so events\nwithin the week are correctly retained.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 84,
    "path": "src/features/events/components/EventsOverview.jsx"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Guard against null sections before dereferencing**\n\nAt the top of `fetchSectionEvents` we immediately read `section.sectionid`, so if an upstream caller ever passes `null`/`undefined` (or a section that was GC‚Äôd from state), the function throws before the defensive check, and the `catch` then repeats the same dereference, triggering another `TypeError`. The net effect is an unhandled rejection that bubbles up and causes `Promise.all` in `fetchAllSectionEvents` to fail, rather than gracefully skipping the bad section. Please short-circuit when `section` itself is falsy and use safe property access in the log payload so the fallback path actually returns `[]` as intended. A minimal fix looks like:\n\n```diff\n-    if (section.sectionid === null || section.sectionid === undefined) {\n-      logger.warn('Skipping section with invalid ID in fetchSectionEvents', {\n-        sectionid: section.sectionid,\n-        sectionname: section.sectionname,\n-        sectiontype: section.sectiontype,\n-        section: section.section,\n-      }, LOG_CATEGORIES.COMPONENT);\n+    if (!section || section.sectionid === null || section.sectionid === undefined) {\n+      logger.warn('Skipping section with invalid ID in fetchSectionEvents', {\n+        sectionid: section?.sectionid ?? null,\n+        sectionname: section?.sectionname ?? null,\n+        sectiontype: section?.sectiontype ?? null,\n+        section: section?.section ?? null,\n+      }, LOG_CATEGORIES.COMPONENT);\n       return []; // Return empty array for invalid section\n     }\n‚Ä¶\n-    logger.error('Error fetching events for section {sectionId}', {\n-      error: err,\n-      sectionId: section.sectionid,\n-      sectionName: section.sectionname,\n-    }, LOG_CATEGORIES.COMPONENT);\n+    logger.error('Error fetching events for section {sectionId}', {\n+      error: err,\n+      sectionId: section?.sectionid ?? null,\n+      sectionName: section?.sectionname ?? null,\n+    }, LOG_CATEGORIES.COMPONENT);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  try {\n    // Defensive check for section ID (allows valid falsy values like 0)\n    if (!section || section.sectionid === null || section.sectionid === undefined) {\n      logger.warn('Skipping section with invalid ID in fetchSectionEvents', {\n        sectionid: section?.sectionid ?? null,\n        sectionname: section?.sectionname ?? null,\n        sectiontype: section?.sectiontype ?? null,\n        section: section?.section ?? null,\n      }, LOG_CATEGORIES.COMPONENT);\n      return []; // Return empty array for invalid section\n    }\n\n    // Load from IndexedDB cache only\n    const cachedEvents = (await databaseService.getEvents(section.sectionid)) || [];\n\n    const events = cachedEvents.map(event => ({\n      ...event,\n      sectionid: section.sectionid,\n      sectionname: section.sectionname,\n      termid: event.termid, // Keep existing termid from cache\n    }));\n\n    return events;\n  } catch (err) {\n    logger.error('Error fetching events for section {sectionId}', {\n      error: err,\n      sectionId: section?.sectionid ?? null,\n      sectionName: section?.sectionname ?? null,\n    }, LOG_CATEGORIES.COMPONENT);\n    return [];\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/shared/utils/eventDashboardHelpers.js around lines 43 to 72, the function\ndereferences section.sectionid before ensuring section itself is not\nnull/undefined which can throw; update the start of the function to\nshort-circuit when section is falsy (return []) and change all places that\naccess section properties (both in the initial guard, cached load, mapping and\nthe catch logger) to use safe checks/optional chaining (or read values into\nlocal vars after the falsy check) so we never dereference a null section and the\ncatch block can safely log sectionId/sectionName without causing another\nTypeError.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 72,
    "path": "src/shared/utils/eventDashboardHelpers.js"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Correct the `referenceResults` property access.**\n\n`referenceResults` already contains the data returned from `loadInitialReferenceData`, so `referenceResults.results.userRoles` will be `undefined`. Adjust the example to use `referenceResults.userRoles` (or whatever the actual shape is) to keep the code path accurate.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn docs/architecture/data-management.md around lines 92 to 99, the example\nincorrectly accesses referenceResults.results.userRoles which will be undefined\nbecause referenceResults already contains the returned data; update the example\nto read the correct property (e.g., referenceResults.userRoles or the actual\nshape returned by loadInitialReferenceData) and adjust any surrounding comments\nor variable names to match that shape so the code path is accurate.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:triton:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 99,
    "path": "docs/architecture/data-management.md"
  },
  {
    "body": "_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Fix the `userRoles` reference in the sample.**\n\nIn the `ReferenceDataService` example, `getListOfMembers(userRoles, token)` is called before `userRoles` has been declared, so anyone copying the snippet will hit a ReferenceError. Please pull the `userRoles` resolution out into its own `const` before composing the `results` object (or otherwise adjust the example) so the sample reflects a working pattern.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn docs/architecture/simplified-sync-architecture.md around lines 61 to 69, the\nsample calls getListOfMembers(userRoles, token) before userRoles is defined\nwhich will cause a ReferenceError; extract the userRoles resolution into its own\nconst (e.g., const userRoles = await getUserRoles(token)) before building the\nresults object and then use that const when calling getListOfMembers and\nloadFlexiRecordMetadata so the snippet shows a correct, working ordering.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:triton:sabertoothed -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "line": 69,
    "path": "docs/architecture/simplified-sync-architecture.md"
  }
]
