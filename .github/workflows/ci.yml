name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # Unit Tests
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:run

      - name: Run linter
        run: npm run lint

  # Build Test
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set build environment variables
        run: |
          # Use git describe to get current version, fallback to package.json version
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "1.1.0")
          echo "SENTRY_RELEASE=vikings-eventmgmt-mobile@$VERSION" >> $GITHUB_ENV
          echo "Building with Sentry release: vikings-eventmgmt-mobile@$VERSION"

      - name: Build application
        env:
          SENTRY_RELEASE: ${{ env.SENTRY_RELEASE }}
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 7

  # E2E Tests with Cypress Cloud - DISABLED (needs configuration fixes)
  # e2e-tests:
  #   runs-on: ubuntu-latest
  #   needs: [unit-tests, build]
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       browser: [chrome, firefox, edge]
  #       containers: [1, 2] # Parallel execution
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'

  #     - name: Install dependencies
  #       run: npm ci

  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: build-files
  #         path: dist/

  #     - name: Run Cypress tests
  #       uses: cypress-io/github-action@v6
  #       with:
  #         start: npm run dev
  #         wait-on: 'http://localhost:3001'
  #         wait-on-timeout: 120
  #         browser: ${{ matrix.browser }}
  #         record: true
  #         parallel: true
  #         group: 'E2E Tests - ${{ matrix.browser }}'
  #         tag: '${{ github.event_name }}'
  #       env:
  #         CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         CYPRESS_PROJECT_ID: ${{ secrets.CYPRESS_PROJECT_ID }}
  #         # Force API mocking in CI/CD to prevent real API calls
  #         CYPRESS_ENABLE_API_MOCKING: 'true'
  #         CYPRESS_CI: 'true'
  #         # Use test environment variables to prevent real API access
  #         VITE_API_URL: 'http://localhost:3001/mock-api'
  #         NODE_ENV: 'test'

  # Mobile Build Test (iOS)
  mobile-build:
    runs-on: macos-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set build environment variables
        run: |
          # Use git describe to get current version, fallback to package.json version
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "1.1.0")
          echo "SENTRY_RELEASE=vikings-eventmgmt-mobile@$VERSION" >> $GITHUB_ENV
          echo "Building mobile assets with Sentry release: vikings-eventmgmt-mobile@$VERSION"

      - name: Build web assets
        env:
          SENTRY_RELEASE: ${{ env.SENTRY_RELEASE }}
        run: npm run build

      - name: Setup Capacitor
        run: |
          npx cap sync ios
          # Note: Full iOS build would require Apple Developer certificates

  # Deployment (if needed)
  deploy:
    runs-on: ubuntu-latest
    needs: [unit-tests, build]
    # Run for PRs targeting main (preview) and pushes to main (production)
    if: ${{ github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-files
          path: dist/

      - name: üìù Set environment-aware version for Sentry tracking
        run: |
          echo "üî¢ Setting version based on deployment environment..."
          set -Eeuo pipefail

          # Function to safely escape shell input
          escape_shell_input() {
            local input="$1"
            # Escape potentially dangerous characters, strip CR/LF, and limit length
            printf '%s' "$input" \
              | tr -d '\r\n' \
              | sed -e 's/[;&|`$(){}]/\\&/g' \
              | head -c 200
          }

          # Function to detect version type from raw (unescaped) PR title
          detect_version_type() {
            local raw_title="$1"
            local version_type="patch"  # Default to patch
            local title_lc="${raw_title,,}"  # Convert to lowercase

            # Check for explicit version type tags and patterns (case-insensitive)
            case "$title_lc" in
              *"[major]"*)
                version_type="major"
                echo "üî¥ [major] tag detected in PR title" >&2
                ;;
              *"[minor]"*)
                version_type="minor"
                echo "üü° [minor] tag detected in PR title" >&2
                ;;
              *"[patch]"*)
                version_type="patch"
                echo "üü¢ [patch] tag detected in PR title" >&2
                ;;
              *"breaking change"*|*"breaking-change"*|*"!:"*)
                version_type="major"
                echo "üî¥ BREAKING CHANGE detected in PR title" >&2
                ;;
              *"feat:"*|*"feature:"*|*"feat("*|*"feature("*)
                version_type="minor"
                echo "üü° feat: conventional commit detected in PR title" >&2
                ;;
              *"fix:"*|*"bugfix:"*|*"hotfix:"*|*"fix("*|*"bugfix("*|*"hotfix("*)
                version_type="patch"
                echo "üü¢ fix: conventional commit detected in PR title" >&2
                ;;
              *"perf:"*|*"refactor:"*|*"style:"*|*"chore:"*|*"docs:"*|*"test:"*|*"ci:"*|*"build:"*|*"perf("*|*"refactor("*|*"style("*)
                version_type="patch"
                echo "üü¢ performance/refactor/style change detected in PR title" >&2
                ;;
              *)
                echo "üü¢ No semantic versioning patterns detected, defaulting to patch" >&2
                ;;
            esac

            echo "$version_type"
          }

          # Export GH_TOKEN for gh CLI commands
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # Get the actual PR title (not commit message) with input validation
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PR events, use the PR title directly
            RAW_PR_TITLE="${{ github.event.pull_request.title }}"
            # Detect version type from raw title before escaping
            VERSION_TYPE=$(detect_version_type "$RAW_PR_TITLE")
            # Then escape for safe shell export
            PR_TITLE=$(escape_shell_input "$RAW_PR_TITLE")
            echo "üìã Using PR title from pull_request event: $PR_TITLE"
          else
            # For push events, find associated PR via GitHub API
            echo "üîç Push event detected, searching for associated PR..."
            COMMIT_SHA="${{ github.sha }}"

            # Use GitHub API to find PRs associated with this commit (with error handling)
            API_RESPONSE=$(curl -s -f --connect-timeout 5 --max-time 10 \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/commits/${COMMIT_SHA}/pulls" \
              2>/dev/null | jq -r '.[0].title // empty' 2>/dev/null || echo "")

            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "null" ]; then
              # Detect version type from raw API response before escaping
              VERSION_TYPE=$(detect_version_type "$API_RESPONSE")
              # Then escape for safe shell export
              PR_TITLE=$(escape_shell_input "$API_RESPONSE")
              echo "üìã Found associated PR title: $PR_TITLE"
            else
              # Fallback to commit message if no PR found
              RAW_COMMIT_MSG="${{ github.event.head_commit.message }}"
              # Detect version type from raw commit message before escaping
              VERSION_TYPE=$(detect_version_type "$RAW_COMMIT_MSG")
              # Then escape for safe shell export
              PR_TITLE=$(escape_shell_input "$RAW_COMMIT_MSG")
              echo "üìã No associated PR found, using commit message: $PR_TITLE"
            fi
          fi

          # Final fallback if still empty
          if [ -z "$PR_TITLE" ]; then
            PR_TITLE="(no title)"
            VERSION_TYPE="patch"  # Default for empty titles
          fi

          # Export PR_TITLE for use in subsequent steps using safe block syntax
          {
            printf 'PR_TITLE<<__EOF__\n'
            printf '%s\n' "$PR_TITLE"
            printf '__EOF__\n'
          } >> "$GITHUB_ENV"

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # Preview deployment - calculate upcoming version that will be created on merge
            echo "üîç Preview deployment detected"
            echo "üìã Using PR title: $PR_TITLE"

            # Get current production version from latest git tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
            BASE_VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
            echo "üè∑Ô∏è Latest production tag: $LATEST_TAG (base: $BASE_VERSION)"

            # Look for explicit version pattern like v1.2.3 in raw PR title
            RAW_PR_TITLE_FOR_EXPLICIT="${{ github.event.pull_request.title }}"
            EXPLICIT_VERSION=$(echo "$RAW_PR_TITLE_FOR_EXPLICIT" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' || echo "")

            if [ -n "$EXPLICIT_VERSION" ]; then
              # Explicit version found - use it as the upcoming version
              UPCOMING_VERSION=$(echo "$EXPLICIT_VERSION" | sed 's/v//')
              echo "üìå Explicit version specified in PR title: $EXPLICIT_VERSION"
              echo "Upcoming version: $UPCOMING_VERSION"
            else
              # Use the VERSION_TYPE already detected from raw title
              echo "üîç Using detected version type: $VERSION_TYPE"

              # Calculate upcoming version using semantic versioning rules
              BASE_SEMVER=$(echo "$BASE_VERSION" | sed -E 's/^([0-9]+)\.([0-9]+)\.([0-9]+).*/\1.\2.\3/')
              IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_SEMVER"
              echo "üî¢ Current version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"

              # Compute upcoming version based on already-detected bump type
              if [ "$VERSION_TYPE" = "major" ]; then
                NEXT_MAJOR=$((MAJOR + 1))
                UPCOMING_VERSION="${NEXT_MAJOR}.0.0"
                echo "üî¥ Computing major version bump: $BASE_VERSION ‚Üí $UPCOMING_VERSION"
              elif [ "$VERSION_TYPE" = "minor" ]; then
                NEXT_MINOR=$((MINOR + 1))
                UPCOMING_VERSION="${MAJOR}.${NEXT_MINOR}.0"
                echo "üü° Computing minor version bump: $BASE_VERSION ‚Üí $UPCOMING_VERSION"
              else
                # patch bump (default)
                NEXT_PATCH=$((PATCH + 1))
                UPCOMING_VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}"
                echo "üü¢ Computing patch version bump: $BASE_VERSION ‚Üí $UPCOMING_VERSION"
              fi
            fi

            # Create preview version with upcoming version + PR info
            SHORT_SHA="${{ github.event.pull_request.head.sha }}"
            # Fallback in case head.sha is empty
            [ -z "$SHORT_SHA" ] && SHORT_SHA="${{ github.sha }}"
            SHORT_SHA="${SHORT_SHA:0:7}"
            NEW_VERSION="${UPCOMING_VERSION}-pr-${{ github.event.number }}-${SHORT_SHA}"
            DEPLOYMENT_TYPE="preview"

            echo "‚úÖ Preview version set: $NEW_VERSION"
            echo "   ‚Üí This represents what version $UPCOMING_VERSION will look like when merged"
          else
            # Production deployment (main branch) - bump version properly
            echo "üöÄ Production deployment detected"

            # Configure git for automated commits (only for production)
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"

            # Use the PR title that was extracted and exported earlier
            echo "üìã Using extracted PR title: $PR_TITLE"

            # Look for version pattern like v1.2.3 in PR title
            EXPLICIT_VERSION=$(echo "$PR_TITLE" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' || echo "")

            if [ -n "$EXPLICIT_VERSION" ]; then
              # Explicit version found in PR title - use it directly
              CLEAN_VERSION=$(echo "$EXPLICIT_VERSION" | sed 's/v//')
              echo "üìå Explicit version specified in PR title: $EXPLICIT_VERSION"
              echo "Setting version directly to: $CLEAN_VERSION"

              # Set NEW_VERSION immediately for explicit versions
              NEW_VERSION="$CLEAN_VERSION"
              VERSION_TYPE="explicit"

              # Update package.json to match explicit version
              npm version "$CLEAN_VERSION" --no-git-tag-version --allow-same-version

              # Commit package.json changes for explicit versions
              git add package.json package-lock.json 2>/dev/null || true
              git commit -m "chore(release): v${CLEAN_VERSION} [explicit]" || echo "No changes to commit"

              echo "‚úÖ Explicit version set: $NEW_VERSION"
            else
              # No explicit version - apply semantic versioning rules
              echo "üìù No explicit version in PR title, applying semantic versioning rules"
              echo "PR titles can include version like: 'feat: new feature v1.2.0'"
              echo "Or version tags like: 'Add new feature [minor]' or 'Breaking change [major]'"
              echo "Or conventional commits like: 'feat:', 'fix:', 'BREAKING CHANGE:'"

              # Get base version from latest git tag (more reliable than package.json)
              LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
              # Remove only a leading 'v'
              BASE_VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
              echo "üè∑Ô∏è Latest git tag: $LATEST_TAG (base: $BASE_VERSION)"

              # Parse base version into components (strip any pre-release/build suffixes)
              BASE_SEMVER=$(echo "$BASE_VERSION" | sed -E 's/^([0-9]+)\.([0-9]+)\.([0-9]+).*/\1.\2.\3/')
              IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_SEMVER"
              echo "üî¢ Current version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"

              # Use the VERSION_TYPE already computed by detect_version_type() from raw PR title
              # This ensures consistent pattern matching between preview and production deployments
              echo "üîç Using pre-computed version type: $VERSION_TYPE (from raw PR title analysis)"

              # Compute new version based on bump type
              if [ "$VERSION_TYPE" = "major" ]; then
                NEXT_MAJOR=$((MAJOR + 1))
                NEW_VERSION="${NEXT_MAJOR}.0.0"
                echo "üî¥ Computing major version bump: $BASE_VERSION ‚Üí $NEW_VERSION"
              elif [ "$VERSION_TYPE" = "minor" ]; then
                NEXT_MINOR=$((MINOR + 1))
                NEW_VERSION="${MAJOR}.${NEXT_MINOR}.0"
                echo "üü° Computing minor version bump: $BASE_VERSION ‚Üí $NEW_VERSION"
              else
                # patch bump (default)
                NEXT_PATCH=$((PATCH + 1))
                NEW_VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}"
                echo "üü¢ Computing patch version bump: $BASE_VERSION ‚Üí $NEW_VERSION"
              fi

              echo "‚úÖ Semantic versioning result: $NEW_VERSION (type: $VERSION_TYPE)"

              # Update package.json to computed version
              npm version "$NEW_VERSION" --no-git-tag-version --allow-same-version

              # Commit package.json changes for semantic versions
              git add package.json package-lock.json 2>/dev/null || true
              git commit -m "chore(release): v${NEW_VERSION} [${VERSION_TYPE}]" || echo "No changes to commit"
            fi

            DEPLOYMENT_TYPE="production"
            echo "Production version: $NEW_VERSION"
          fi

          # Export version and deployment type for subsequent steps using safe syntax
          {
            echo "NEW_VERSION=$NEW_VERSION"
            echo "DEPLOYMENT_TYPE=$DEPLOYMENT_TYPE"
          } >> "$GITHUB_ENV"
          echo "‚úÖ Version set: $NEW_VERSION (${DEPLOYMENT_TYPE})"

          # Create tags and releases only for production deployments
          if [ "$DEPLOYMENT_TYPE" = "production" ]; then
            # Check if tag already exists and retry with incremented version if needed (with remote awareness)
            FINAL_VERSION="$NEW_VERSION"
            RETRY_COUNT=0
            MAX_RETRIES=10
            # Ensure we see the latest remote tags before starting
            git fetch --tags --force >/dev/null 2>&1 || true
            while git rev-parse --verify "refs/tags/v${FINAL_VERSION}" >/dev/null 2>&1; do
              echo "üè∑Ô∏è Tag v${FINAL_VERSION} already exists, calculating next available version..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ "$RETRY_COUNT" -ge "$MAX_RETRIES" ]; then
                echo "‚ùå Max retries ($MAX_RETRIES) reached, unable to find available version"
                exit 1
              fi
              # Re-fetch actual latest tag from remote and increment appropriately
              git fetch --tags --force >/dev/null 2>&1 || true
              ACTUAL_LATEST=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
              ACTUAL_BASE=$(echo "$ACTUAL_LATEST" | sed 's/^v//')
              echo "üîç Actual latest tag found: $ACTUAL_LATEST (base: $ACTUAL_BASE)"
              # Parse and increment based on original VERSION_TYPE
              ACTUAL_SEMVER=$(echo "$ACTUAL_BASE" | sed -E 's/^([0-9]+)\.([0-9]+)\.([0-9]+).*/\1.\2.\3/')
              IFS='.' read -r A_MAJOR A_MINOR A_PATCH <<< "$ACTUAL_SEMVER"
              if [ "$VERSION_TYPE" = "major" ]; then
                NEXT_A_MAJOR=$((A_MAJOR + 1))
                FINAL_VERSION="${NEXT_A_MAJOR}.0.0"
              elif [ "$VERSION_TYPE" = "minor" ]; then
                NEXT_A_MINOR=$((A_MINOR + 1))
                FINAL_VERSION="${A_MAJOR}.${NEXT_A_MINOR}.0"
              else
                # patch bump (default)
                NEXT_A_PATCH=$((A_PATCH + 1))
                FINAL_VERSION="${A_MAJOR}.${A_MINOR}.${NEXT_A_PATCH}"
              fi
              echo "üîÑ Retry $RETRY_COUNT: Trying version v${FINAL_VERSION}"
            done
            # Create and push git tag for Sentry tracking (with bounded retry loop)
            echo "üè∑Ô∏è Creating new tag v${FINAL_VERSION}"
            TAG_CREATED="false"
            PUSH_RETRY_COUNT=0
            MAX_PUSH_RETRIES=5
            
            while [ "$PUSH_RETRY_COUNT" -lt "$MAX_PUSH_RETRIES" ]; do
              git tag "v${FINAL_VERSION}" || true
              if git push origin "v${FINAL_VERSION}"; then
                echo "‚úÖ Successfully pushed tag v${FINAL_VERSION}"
                TAG_CREATED="true"
                break
              else
                echo "‚ö†Ô∏è Push failed (attempt $((PUSH_RETRY_COUNT + 1))/$MAX_PUSH_RETRIES). Checking remote..."
                git fetch --tags --force >/dev/null 2>&1 || true
                
                # Check if remote already has this tag
                if git ls-remote --tags origin "v${FINAL_VERSION}" | grep -q "v${FINAL_VERSION}"; then
                  echo "‚úÖ Tag v${FINAL_VERSION} already exists on remote"
                  TAG_CREATED="true"
                  # Clean up local tag since remote has it
                  git tag -d "v${FINAL_VERSION}" >/dev/null 2>&1 || true
                  break
                fi
                
                # Clean up failed local tag
                git tag -d "v${FINAL_VERSION}" >/dev/null 2>&1 || true
                
                # Recompute FINAL_VERSION based on latest remote tags
                ACTUAL_LATEST=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
                ACTUAL_BASE=$(echo "$ACTUAL_LATEST" | sed 's/^v//')
                ACTUAL_SEMVER=$(echo "$ACTUAL_BASE" | sed -E 's/^([0-9]+)\.([0-9]+)\.([0-9]+).*/\1.\2.\3/')
                IFS='.' read -r A_MAJOR A_MINOR A_PATCH <<< "$ACTUAL_SEMVER"
                
                if [ "$VERSION_TYPE" = "major" ]; then
                  NEXT_A_MAJOR=$((A_MAJOR + 1))
                  FINAL_VERSION="${NEXT_A_MAJOR}.0.0"
                elif [ "$VERSION_TYPE" = "minor" ]; then
                  NEXT_A_MINOR=$((A_MINOR + 1))
                  FINAL_VERSION="${A_MAJOR}.${NEXT_A_MINOR}.0"
                else
                  NEXT_A_PATCH=$((A_PATCH + 1))
                  FINAL_VERSION="${A_MAJOR}.${A_MINOR}.${NEXT_A_PATCH}"
                fi
                
                PUSH_RETRY_COUNT=$((PUSH_RETRY_COUNT + 1))
                echo "üîÑ Push retry $PUSH_RETRY_COUNT: Recomputed version v${FINAL_VERSION}"
              fi
            done
            
            if [ "$TAG_CREATED" != "true" ]; then
              echo "‚ùå Failed to create tag after $MAX_PUSH_RETRIES push attempts"
              exit 1
            fi
            # Update NEW_VERSION for subsequent steps
            NEW_VERSION="$FINAL_VERSION"
            echo "NEW_VERSION=$NEW_VERSION" >> "$GITHUB_ENV"
            echo "‚úÖ Git tag v${NEW_VERSION} created and pushed"

            # Create GitHub releases based on version type (only if tag was created)
            if [ "$TAG_CREATED" = "true" ]; then
              # Guard GitHub CLI usage
              if ! command -v gh >/dev/null 2>&1 || [ -z "${GH_TOKEN:-}" ]; then
                echo "‚ö†Ô∏è gh CLI not available or GH_TOKEN missing; skipping GitHub release creation"
              else
                if [ "$VERSION_TYPE" = "patch" ]; then
                  # Patch versions: Just tag for Sentry tracking (no GitHub release)
                  echo "‚úÖ Production version tagged: v${NEW_VERSION} (patch)"
                elif [ "$VERSION_TYPE" = "minor" ]; then
                  # Minor versions: Create GitHub Release for new features
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION} - Minor Update" \
                    --notes "Minor release v${NEW_VERSION} with new features or enhancements. This release includes backward-compatible functionality additions. PR: ${PR_TITLE}. Sentry tracking: v${NEW_VERSION}, type: Minor. Notes auto-generated by CI/CD." \
                    --latest

                  echo "‚úÖ Production version released: v${NEW_VERSION} (minor - new features)"
                elif [ "$VERSION_TYPE" = "major" ]; then
                  # Major versions: Create GitHub Release for breaking changes
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION} - Major Update" \
                    --notes "Major release v${NEW_VERSION} with breaking changes. This release may require migration or configuration updates. PR: ${PR_TITLE}. Sentry tracking: v${NEW_VERSION}, type: Major. Notes auto-generated by CI/CD." \
                    --latest

                  echo "‚úÖ Production version released: v${NEW_VERSION} (major - breaking changes)"
                elif [ "$VERSION_TYPE" = "explicit" ]; then
                  # Explicit versions: Create GitHub Release for visibility
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION}" \
                    --notes "Explicit version release v${NEW_VERSION}. This release was created with an explicit version specified in the PR title. PR: ${PR_TITLE}. Sentry tracking: v${NEW_VERSION}, type: Explicit. Notes auto-generated by CI/CD." \
                    --latest

                  echo "‚úÖ Production version released: v${NEW_VERSION} (explicit from PR title)"
                else
                  # Other version types: Create GitHub Release with generic notes
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION}" \
                    --notes "Auto-generated release v${NEW_VERSION}. PR: ${PR_TITLE}. Sentry tracking: v${NEW_VERSION}, type: ${VERSION_TYPE}. Notes auto-generated by CI/CD." \
                    --latest

                  echo "‚úÖ Production version released: v${NEW_VERSION} (${VERSION_TYPE})"
                fi
              fi
            else
              echo "‚ÑπÔ∏è Tag already exists, skipping GitHub release creation"
            fi
          else
            echo "üîç Preview deployment - no tags or releases created"
          fi

      - name: üì§ Create Sentry release for error tracking
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: walton-vikings
          SENTRY_PROJECT: viking-event-mgmt
        run: |
          set -Eeuo pipefail
          # Use the environment-aware version set in previous step
          RELEASE="vikings-eventmgmt-mobile@$NEW_VERSION"
          ENVIRONMENT="$DEPLOYMENT_TYPE"

          echo "üìä Creating Sentry release: $RELEASE"
          echo "üåç Environment: $ENVIRONMENT"

          if [ -n "$SENTRY_AUTH_TOKEN" ]; then
            # Create Sentry release with environment
            npx @sentry/cli releases new "$RELEASE" || echo "Release may already exist"

            # Upload source maps if they exist
            if [ -d "./dist" ] && [ "$(find "./dist" -name '*.map' | wc -l)" -gt 0 ]; then
              echo "üìÇ Uploading source maps for error tracking..."
              npx @sentry/cli sourcemaps inject ./dist
              npx @sentry/cli sourcemaps upload --release "$RELEASE" --url-prefix "~/" ./dist
            fi

            # Set commits and finalize
            npx @sentry/cli releases set-commits "$RELEASE" --auto || { echo "‚ö†Ô∏è Sentry: failed to set commits (non-fatal). Check repo integration/token scopes." >&2; }
            npx @sentry/cli releases finalize "$RELEASE" || { echo "‚ö†Ô∏è Sentry: finalize failed or already finalized (non-fatal)." >&2; }

            # Mark deployment in the appropriate environment
            npx @sentry/cli releases deploys "$RELEASE" new -e "$ENVIRONMENT"

            echo "‚úÖ Sentry release $RELEASE created for $ENVIRONMENT environment"
          else
            echo "‚ö†Ô∏è SENTRY_AUTH_TOKEN not configured, skipping Sentry release"
          fi

      - name: Deploy to production
        if: env.DEPLOYMENT_TYPE == 'production'
        env:
          RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: |
          echo "üöÄ Deploying to production..."

          # Deploy to Render.com via webhook
          if [ -n "$RENDER_DEPLOY_HOOK" ]; then
            echo "Triggering Render deployment via webhook..."
            attempts=0
            max_attempts=3
            backoff=2
            while :; do
              response=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$RENDER_DEPLOY_HOOK")
              if [ "$response" = "200" ] || [ "$response" = "201" ]; then
                break
              fi
              attempts=$((attempts+1))
              if [ "$attempts" -ge "$max_attempts" ]; then
                break
              fi
              echo "‚è≥ Attempt $attempts failed with status $response, retrying in ${backoff}s..."
              sleep "$backoff"
              backoff=$((backoff*2))
            done
            if [ "$response" = "200" ] || [ "$response" = "201" ]; then
              echo "‚úÖ Render deployment triggered successfully"
            else
              echo "‚ùå Render deployment failed with status: $response after $max_attempts attempts"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è RENDER_DEPLOY_HOOK not configured, skipping deployment"
            echo "Please configure RENDER_DEPLOY_HOOK secret in GitHub repository settings"
          fi