name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # Unit Tests
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:run

      - name: Run linter
        run: npm run lint

  # Documentation Quality Check
  documentation:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Validate JSDoc syntax
        run: npm run docs:validate

      - name: Generate documentation
        run: npm run docs:generate

      - name: Check documentation coverage
        run: |
          echo "üîç Checking JSDoc documentation coverage..."
          
          # Count total JavaScript/JSX files
          TOTAL_FILES=$(find src -name "*.js" -o -name "*.jsx" | wc -l)
          
          # Count files with JSDoc comments (simple heuristic)
          FILES_WITH_JSDOC=$(find src -name "*.js" -o -name "*.jsx" | xargs grep -l "/\*\*" | wc -l)
          
          # Calculate coverage percentage
          if [ "$TOTAL_FILES" -gt 0 ]; then
            COVERAGE=$((FILES_WITH_JSDOC * 100 / TOTAL_FILES))
          else
            COVERAGE=0
          fi
          
          echo "üìä Documentation Coverage Report:"
          echo "   Total files: $TOTAL_FILES"
          echo "   Files with JSDoc: $FILES_WITH_JSDOC"
          echo "   Coverage: $COVERAGE%"
          
          # Set minimum coverage threshold
          MIN_COVERAGE=20
          
          if [ "$COVERAGE" -lt "$MIN_COVERAGE" ]; then
            echo "‚ùå Documentation coverage ($COVERAGE%) is below minimum threshold ($MIN_COVERAGE%)"
            echo "üí° Please add JSDoc comments to more functions and components"
            exit 1
          else
            echo "‚úÖ Documentation coverage ($COVERAGE%) meets minimum threshold ($MIN_COVERAGE%)"
          fi

      - name: Upload documentation artifacts
        uses: actions/upload-artifact@v4
        with:
          name: documentation
          path: docs/api/
          retention-days: 7

  # Build Test
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set build environment variables
        run: |
          # Get highest semantic version tag, not just reachable ones
          LATEST_TAG=$(git tag -l "v*.*.*" | sort -V | tail -1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v1.1.0"
          fi
          VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
          echo "SENTRY_RELEASE=vikings-eventmgmt-mobile@$VERSION" >> $GITHUB_ENV
          echo "Building with Sentry release: vikings-eventmgmt-mobile@$VERSION"

      - name: Build application
        env:
          SENTRY_RELEASE: ${{ env.SENTRY_RELEASE }}
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 7

  # E2E Tests with Cypress Cloud - DISABLED (needs configuration fixes)
  # e2e-tests:
  #   runs-on: ubuntu-latest
  #   needs: [unit-tests, build]
  #   strategy:
  #     fail-fast: false
  #     matrix:
  #       browser: [chrome, firefox, edge]
  #       containers: [1, 2] # Parallel execution
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'

  #     - name: Install dependencies
  #       run: npm ci

  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: build-files
  #         path: dist/

  #     - name: Run Cypress tests
  #       uses: cypress-io/github-action@v6
  #       with:
  #         start: npm run dev
  #         wait-on: 'http://localhost:3001'
  #         wait-on-timeout: 120
  #         browser: ${{ matrix.browser }}
  #         record: true
  #         parallel: true
  #         group: 'E2E Tests - ${{ matrix.browser }}'
  #         tag: '${{ github.event_name }}'
  #       env:
  #         CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         CYPRESS_PROJECT_ID: ${{ secrets.CYPRESS_PROJECT_ID }}
  #         # Force API mocking in CI/CD to prevent real API calls
  #         CYPRESS_ENABLE_API_MOCKING: 'true'
  #         CYPRESS_CI: 'true'
  #         # Use test environment variables to prevent real API access
  #         VITE_API_URL: 'http://localhost:3001/mock-api'
  #         NODE_ENV: 'test'

  # Mobile Build Test (iOS)
  mobile-build:
    runs-on: macos-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Set build environment variables
        run: |
          # Get highest semantic version tag, not just reachable ones
          LATEST_TAG=$(git tag -l "v*.*.*" | sort -V | tail -1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v1.1.0"
          fi
          VERSION=$(echo "$LATEST_TAG" | sed 's/^v//')
          echo "SENTRY_RELEASE=vikings-eventmgmt-mobile@$VERSION" >> $GITHUB_ENV
          echo "Building mobile assets with Sentry release: vikings-eventmgmt-mobile@$VERSION"

      - name: Build web assets
        env:
          SENTRY_RELEASE: ${{ env.SENTRY_RELEASE }}
        run: npm run build

      - name: Setup Capacitor
        run: |
          npx cap sync ios
          # Note: Full iOS build would require Apple Developer certificates

  # Deployment (if needed)
  deploy:
    runs-on: ubuntu-latest
    needs: [unit-tests, build]
    # Run for PRs targeting main (preview) and pushes to main (production)
    if: ${{ github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # NOTE: Don't download old build artifacts - we'll rebuild after version update

      - name: üìù Get PR title for version detection
        id: pr-info
        run: |
          set -Eeuo pipefail

          # Export GH_TOKEN for gh CLI commands
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # Get the actual PR title (not commit message)
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            echo "üìã Using PR title from pull_request event: $PR_TITLE"
          else
            # For push events, find associated PR via GitHub API
            echo "üîç Push event detected, searching for associated PR..."
            COMMIT_SHA="${{ github.sha }}"

            API_RESPONSE=$(curl -s -f --connect-timeout 5 --max-time 10 \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/commits/${COMMIT_SHA}/pulls" \
              2>/dev/null | jq -r '.[0].title // empty' 2>/dev/null || echo "")

            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "null" ]; then
              PR_TITLE="$API_RESPONSE"
              echo "üìã Found associated PR title: $PR_TITLE"
            else
              PR_TITLE="${{ github.event.head_commit.message }}"
              echo "üìã No associated PR found, using commit message: $PR_TITLE"
            fi
          fi

          # Fallback if still empty
          if [ -z "$PR_TITLE" ]; then
            PR_TITLE="(no title)"
          fi

          # Export PR_TITLE for use in subsequent steps
          {
            printf 'PR_TITLE<<__EOF__\n'
            printf '%s\n' "$PR_TITLE"
            printf '__EOF__\n'
          } >> "$GITHUB_ENV"
          echo "pr-title=$PR_TITLE" >> $GITHUB_OUTPUT

      - name: üìå Get current version tag
        id: get-tag
        run: |
          LATEST_TAG=$(git tag -l "v*.*.*" | sort -V | tail -1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v1.0.0"
          fi
          echo "current-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "üìå Current version tag: $LATEST_TAG"

      - name: üî¢ Determine version bump
        id: version
        uses: ./.github/actions/determine-version
        with:
          pr-title: ${{ steps.pr-info.outputs.pr-title }}
          current-tag: ${{ steps.get-tag.outputs.current-tag }}

      - name: üìù Set environment-aware version for Sentry tracking
        run: |
          set -Eeuo pipefail

          echo "üî¢ Setting version based on deployment environment..."
          VERSION_TYPE="${{ steps.version.outputs.version-type }}"
          NEW_VERSION="${{ steps.version.outputs.new-version }}"

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # Preview deployment
            echo "üîç Preview deployment detected"
            SHORT_SHA="${{ github.event.pull_request.head.sha }}"
            [ -z "$SHORT_SHA" ] && SHORT_SHA="${{ github.sha }}"
            SHORT_SHA="${SHORT_SHA:0:7}"
            NEW_VERSION="${NEW_VERSION}-pr-${{ github.event.number }}-${SHORT_SHA}"
            DEPLOYMENT_TYPE="preview"
            echo "‚úÖ Preview version set: $NEW_VERSION"
          else
            # Production deployment (main branch) - bump version properly
            echo "üöÄ Production deployment detected"

            # Note: We don't push package.json changes back to repo
            # Render will build from the current commit and use the git tag for versioning
            # The Vite build process reads version from package.json at build time

            DEPLOYMENT_TYPE="production"
            echo "Production version: $NEW_VERSION"
            echo "‚ÑπÔ∏è  Version will be embedded during Render build process"

            # Create and push git tag for Sentry tracking
            echo "üè∑Ô∏è Creating new tag v${NEW_VERSION}"
            git tag "v${NEW_VERSION}" || true
            if git push origin "v${NEW_VERSION}"; then
              echo "‚úÖ Successfully pushed tag v${NEW_VERSION}"
            else
              echo "‚ö†Ô∏è Tag push failed or already exists"
            fi

            # Create GitHub release
            export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
            if command -v gh >/dev/null 2>&1 && [ -n "${GH_TOKEN:-}" ]; then
              case "$VERSION_TYPE" in
                patch)
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION} - Patch Update" \
                    --notes "Patch release v${NEW_VERSION} with bug fixes and improvements. PR: ${PR_TITLE}. Notes auto-generated by CI/CD." \
                    --latest
                  ;;
                minor)
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION} - Feature Release" \
                    --notes "Feature release v${NEW_VERSION} with new features or enhancements. PR: ${PR_TITLE}. Notes auto-generated by CI/CD." \
                    --latest
                  ;;
                major)
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION} - Major Update" \
                    --notes "Major release v${NEW_VERSION} with breaking changes. PR: ${PR_TITLE}. Notes auto-generated by CI/CD." \
                    --latest
                  ;;
                *)
                  gh release create "v${NEW_VERSION}" \
                    --title "Release v${NEW_VERSION}" \
                    --notes "Auto-generated release v${NEW_VERSION}. PR: ${PR_TITLE}. Notes auto-generated by CI/CD." \
                    --latest
                  ;;
              esac
              echo "‚úÖ Production version released: v${NEW_VERSION} (${VERSION_TYPE})"
            fi
          fi

          # Export version and deployment type
          {
            echo "NEW_VERSION=$NEW_VERSION"
            echo "DEPLOYMENT_TYPE=$DEPLOYMENT_TYPE"
            echo "VERSION_TYPE=$VERSION_TYPE"
          } >> "$GITHUB_ENV"
          echo "‚úÖ Version set: $NEW_VERSION (${DEPLOYMENT_TYPE})"

      - name: üì§ Create Sentry release for error tracking
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: walton-vikings
          SENTRY_PROJECT: viking-event-mgmt
        run: |
          set -Eeuo pipefail
          # Use the environment-aware version set in previous step
          RELEASE="vikings-eventmgmt-mobile@$NEW_VERSION"
          ENVIRONMENT="$DEPLOYMENT_TYPE"

          echo "üìä Creating Sentry release: $RELEASE"
          echo "üåç Environment: $ENVIRONMENT"

          if [ -n "$SENTRY_AUTH_TOKEN" ]; then
            # Create Sentry release with environment
            npx @sentry/cli releases new "$RELEASE" || echo "Release may already exist"

            # Upload source maps if they exist
            if [ -d "./dist" ] && [ "$(find "./dist" -name '*.map' | wc -l)" -gt 0 ]; then
              echo "üìÇ Uploading source maps for error tracking..."
              npx @sentry/cli sourcemaps inject ./dist
              npx @sentry/cli sourcemaps upload --release "$RELEASE" --url-prefix "~/" ./dist
            fi

            # Set commits and finalize
            npx @sentry/cli releases set-commits "$RELEASE" --auto || { echo "‚ö†Ô∏è Sentry: failed to set commits (non-fatal). Check repo integration/token scopes." >&2; }
            npx @sentry/cli releases finalize "$RELEASE" || { echo "‚ö†Ô∏è Sentry: finalize failed or already finalized (non-fatal)." >&2; }

            # Mark deployment in the appropriate environment
            npx @sentry/cli releases deploys "$RELEASE" new -e "$ENVIRONMENT"

            echo "‚úÖ Sentry release $RELEASE created for $ENVIRONMENT environment"
          else
            echo "‚ö†Ô∏è SENTRY_AUTH_TOKEN not configured, skipping Sentry release"
          fi

      - name: Deploy to production
        if: env.DEPLOYMENT_TYPE == 'production'
        env:
          RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: |
          echo "üöÄ Deploying to production..."

          # Deploy to Render.com via webhook
          if [ -n "$RENDER_DEPLOY_HOOK" ]; then
            echo "Triggering Render deployment via webhook..."
            echo "Deploying version: $NEW_VERSION"
            echo "‚ÑπÔ∏è  Render will sync version from git tag during build (via prebuild script)"
            attempts=0
            max_attempts=3
            backoff=2
            while :; do
              response=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$RENDER_DEPLOY_HOOK")
              if [ "$response" = "200" ] || [ "$response" = "201" ]; then
                break
              fi
              attempts=$((attempts+1))
              if [ "$attempts" -ge "$max_attempts" ]; then
                break
              fi
              echo "‚è≥ Attempt $attempts failed with status $response, retrying in ${backoff}s..."
              sleep "$backoff"
              backoff=$((backoff*2))
            done
            if [ "$response" = "200" ] || [ "$response" = "201" ]; then
              echo "‚úÖ Render deployment triggered successfully"
            else
              echo "‚ùå Render deployment failed with status: $response after $max_attempts attempts"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è RENDER_DEPLOY_HOOK not configured, skipping deployment"
            echo "Please configure RENDER_DEPLOY_HOOK secret in GitHub repository settings"
          fi