<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/services/storage/sync.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/services/storage/sync.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import databaseService from './database.js';
import { getUserRoles, getEvents, getEventAttendance, fetchMostRecentTermId, getTerms, getMembersGrid } from '../api/api.js';
import { getToken, generateOAuthUrl, validateToken } from '../auth/tokenService.js';
import logger, { LOG_CATEGORIES } from '../utils/logger.js';
import { Capacitor } from '@capacitor/core';
import { Network } from '@capacitor/network';
import { checkNetworkStatus } from '../../utils/networkUtils.js';

class SyncService {
  constructor() {
    this.isSyncing = false;
    this.syncListeners = [];
    this.loginPromptCallbacks = [];
  }

  // Add listener for sync status changes
  addSyncListener(callback) {
    this.syncListeners.push(callback);
  }

  // Remove sync listener
  removeSyncListener(callback) {
    this.syncListeners = this.syncListeners.filter(cb => cb !== callback);
  }

  // Add listener for login prompt requests
  addLoginPromptListener(callback) {
    this.loginPromptCallbacks.push(callback);
  }

  // Remove login prompt listener
  removeLoginPromptListener(callback) {
    this.loginPromptCallbacks = this.loginPromptCallbacks.filter(cb => cb !== callback);
  }

  // Notify listeners of sync status
  notifyListeners(status) {
    this.syncListeners.forEach(callback => callback(status));
  }

  // Notify listeners to show login prompt
  showLoginPrompt() {
    return new Promise((resolve) => {
      this.loginPromptCallbacks.forEach(callback => {
        callback({
          message: 'Authentication required to sync data. Would you like to login?',
          onConfirm: () => {
            // Redirect to OSM OAuth
            const oauthUrl = generateOAuthUrl();
            window.location.href = oauthUrl;
            resolve(true);
          },
          onCancel: () => {
            resolve(false);
          },
        });
      });
    });
  }

  // Check if we're online
  async isOnline() {
    if (Capacitor.isNativePlatform()) {
      const status = await Network.getStatus();
      return status.connected;
    } else {
      return navigator.onLine;
    }
  }

  // Check if we have a valid token before syncing
  async checkTokenAndPromptLogin() {
    // Check network status first - no point prompting for login if offline
    const isOnline = await checkNetworkStatus();
    if (!isOnline) {
      throw new Error('Cannot sync while offline. Connect to the internet and try again.');
    }

    const token = getToken();
    if (!token) {
      const shouldLogin = await this.showLoginPrompt();
      if (!shouldLogin) {
        throw new Error('Authentication required but user declined to login');
      }
      return false; // Login initiated, don't continue sync
    }
    
    // Actually validate the token against the server
    const isValid = await validateToken();
    if (!isValid) {
      const shouldLogin = await this.showLoginPrompt();
      if (!shouldLogin) {
        throw new Error('Authentication required but user declined to login');
      }
      return false; // Login initiated, don't continue sync
    }
    
    return true; // Token is valid, continue sync
  }

  // Handle 401/403 errors by prompting for login
  async handleAuthError(error) {
    if (error.status === 401 || error.status === 403 || 
        error.message.includes('Invalid access token') || 
        error.message.includes('Token expired') ||
        error.message.includes('Unauthorized')) {
      
      const shouldLogin = await this.showLoginPrompt();
      if (!shouldLogin) {
        throw new Error('Authentication failed and user declined to login');
      }
      return false; // Login initiated, don't continue sync
    }
    throw error; // Re-throw other errors
  }

  // Wrapper method to handle auth errors consistently
  async withAuthErrorHandling(operation, options = {}) {
    const { continueOnError = false, contextMessage = '' } = options;
    
    try {
      return await operation();
    } catch (error) {
      console.error(`${contextMessage}:`, error);
      
      try {
        const handled = await this.handleAuthError(error);
        if (!handled) {
          return; // Login was initiated
        }
      } catch (authError) {
        if (continueOnError) {
          console.warn(`Auth error${contextMessage ? ` for ${contextMessage}` : ''}, continuing: ${authError.message}`);
          return;
        }
        throw authError;
      }
      
      // Re-throw the original error for non-auth errors
      throw error;
    }
  }

  // Sync all data (legacy method - calls new three-stage approach)
  async syncAll() {
    await this.syncDashboardData();
    // Start background sync after dashboard data is complete
    setTimeout(() => this.syncBackgroundData(), 100);
  }

  // Stage 1: Sync core data only (fast)
  async syncDashboardData() {
    if (this.isSyncing) {
      return;
    }

    try {
      this.isSyncing = true;
      this.notifyListeners({ status: 'syncing', message: 'Loading core data...' });

      const online = await this.isOnline();
      if (!online) {
        throw new Error('No internet connection available');
      }

      // Check token and prompt for login if needed
      const hasValidToken = await this.checkTokenAndPromptLogin();
      if (!hasValidToken) {
        this.notifyListeners({ 
          status: 'error', 
          message: 'Login required - redirecting to authentication',
          timestamp: new Date().toISOString(),
        });
        return;
      }

      const token = getToken();

      // Load core static data - events will be loaded by buildEventCards
      await this.syncTerms(token);
      await this.syncSections(token);
      
      // Get sections for FlexiRecord preloading
      const sections = await databaseService.getSections();
      
      // Preload static FlexiRecord data (lists and structures) - static like terms
      try {
        await this.withAuthErrorHandling(async () => {
          this.notifyListeners({ status: 'syncing', message: 'Loading FlexiRecord structures...' });
          await this.preloadStaticFlexiRecordData(sections, token);
        }, { 
          continueOnError: true,
          contextMessage: 'Failed to preload FlexiRecord static data',
        });
      } catch (error) {
        logger.warn('FlexiRecord static preloading failed', { error: error.message }, LOG_CATEGORIES.SYNC);
      }

      const completionTimestamp = Date.now();
      localStorage.setItem('viking_last_sync', completionTimestamp.toString());
      
      // Notify dashboard data is complete
      this.notifyListeners({ 
        status: 'dashboard_complete', 
        message: 'Core data loaded - events loading...',
        timestamp: completionTimestamp,
      });

    } catch (error) {
      logger.error('Core data sync failed', { error: error.message }, LOG_CATEGORIES.SYNC);
      
      try {
        const handled = await this.handleAuthError(error);
        if (!handled) return;
      } catch (authError) {
        this.notifyListeners({ 
          status: 'error', 
          message: authError.message,
          timestamp: new Date().toISOString(),
        });
        return;
      }

      this.notifyListeners({ 
        status: 'error', 
        message: error.message,
        timestamp: new Date().toISOString(),
      });
      throw error;
    } finally {
      this.isSyncing = false;
    }
  }

  // Stage 2: Sync background data (members only) - non-blocking
  async syncBackgroundData() {
    try {
      this.notifyListeners({ status: 'syncing', message: 'Loading member data...' });

      const token = getToken();
      if (!token) return;

      const sections = await databaseService.getSections();
      
      // Sync members for all sections
      for (const section of sections) {
        await this.syncMembers(section.sectionid, token);
      }

      this.notifyListeners({ 
        status: 'background_complete', 
        message: 'Member data loaded',
        timestamp: Date.now(),
      });

    } catch (error) {
      logger.warn('Background sync failed', { error: error.message }, LOG_CATEGORIES.SYNC);
      this.notifyListeners({ 
        status: 'background_error', 
        message: `Background sync failed: ${error.message}`,
        timestamp: Date.now(),
      });
    }
  }

  // Sync terms (core data needed for all section operations)
  async syncTerms(token) {
    try {
      await this.withAuthErrorHandling(async () => {
        this.notifyListeners({ status: 'syncing', message: 'Loading terms...' });
        
        // Load terms once for all sections - major optimization!
        await getTerms(token);
        // Terms loaded and cached successfully
      }, { 
        continueOnError: false,
        contextMessage: 'Failed to sync terms',
      });
    } catch (error) {
      // Only non-auth errors reach here (auth errors are handled in wrapper)
      throw new Error(`Failed to sync terms: ${error.message}`);
    }
  }

  // Sync sections
  async syncSections(token) {
    try {
      await this.withAuthErrorHandling(async () => {
        this.notifyListeners({ status: 'syncing', message: 'Syncing sections...' });
        
        // This will fetch from server and save to database
        await getUserRoles(token);
      }, { 
        continueOnError: false,
        contextMessage: 'Failed to sync sections',
      });
    } catch (error) {
      // Only non-auth errors reach here (auth errors are handled in wrapper)
      throw new Error(`Failed to sync sections: ${error.message}`);
    }
  }

  // Sync events for a section
  async syncEvents(sectionId, token) {
    await this.withAuthErrorHandling(async () => {
      this.notifyListeners({ status: 'syncing', message: `Syncing events for section ${sectionId}...` });
      
      // Get the most recent term
      const termId = await fetchMostRecentTermId(sectionId, token);
      if (!termId) {
        logger.info(`No term found for section ${sectionId} - skipping events sync (this is normal for waiting lists)`, {
          sectionId,
        }, LOG_CATEGORIES.SYNC);
        return;
      }

      // This will fetch from server and save to database
      await getEvents(sectionId, termId, token);
    }, { 
      continueOnError: true,
      contextMessage: `Failed to sync events for section ${sectionId}`,
    });
  }

  // Sync attendance for an event
  async syncAttendance(sectionId, eventId, termId, token) {
    await this.withAuthErrorHandling(async () => {
      this.notifyListeners({ status: 'syncing', message: `Syncing attendance for event ${eventId}...` });
      
      if (!termId) {
        // Try to get term ID if not provided
        termId = await fetchMostRecentTermId(sectionId, token);
      }

      if (!termId) {
        logger.info(`No term ID available for event ${eventId} in section ${sectionId} - skipping attendance sync (this is normal for waiting lists)`, {
          sectionId,
          eventId,
        }, LOG_CATEGORIES.SYNC);
        return;
      }

      // This will fetch from server and save to database
      await getEventAttendance(sectionId, eventId, termId, token);
    }, { 
      continueOnError: true,
      contextMessage: `Failed to sync attendance for event ${eventId}`,
    });
  }

  // Sync members data for a section (includes medical information)
  async syncMembers(sectionId, token) {
    await this.withAuthErrorHandling(async () => {
      this.notifyListeners({ status: 'syncing', message: `Syncing members for section ${sectionId}...` });
      
      // Get the most recent term for this section
      const termId = await fetchMostRecentTermId(sectionId, token);
      if (!termId) {
        logger.info(`No term found for section ${sectionId} - skipping members sync (this is normal for waiting lists)`, {
          sectionId,
        }, LOG_CATEGORIES.SYNC);
        return;
      }

      // This will fetch from server and save to database (includes medical info)
      await getMembersGrid(sectionId, termId, token);
      
      logger.info('Members data synced successfully', {
        sectionId,
        termId,
      }, LOG_CATEGORIES.SYNC);
    }, { 
      continueOnError: true,
      contextMessage: `Failed to sync members for section ${sectionId}`,
    });
  }


  // Get sync status
  async getSyncStatus() {
    try {
      const hasOfflineData = await databaseService.hasOfflineData();
      const online = await this.isOnline();
      
      return {
        hasOfflineData,
        online,
        syncing: this.isSyncing,
      };
    } catch (error) {
      console.error('Error getting sync status:', error);
      return {
        hasOfflineData: false,
        online: false,
        syncing: false,
      };
    }
  }

  // Preload static flexirecord data (lists and structures) for faster access later
  async preloadStaticFlexiRecordData(sections, token) {
    try {
      if (!sections || !Array.isArray(sections) || sections.length === 0) {
        logger.info('No sections provided for flexirecord preloading', {}, LOG_CATEGORIES.SYNC);
        return;
      }

      logger.info('Preloading flexirecord structures', {
        sectionCount: sections.length,
      }, LOG_CATEGORIES.SYNC);
      
      // Import the API function here to avoid circular dependency
      const { getFlexiRecords, getFlexiStructure } = await import('../api/api.js');
      
      // Load flexirecord lists for all sections first
      const flexiRecordPromises = sections.map(async (section) => {
        try {
          const flexiRecords = await getFlexiRecords(section.sectionid, token, 'n', false);
          return { sectionId: section.sectionid, flexiRecords, success: true };
        } catch (error) {
          logger.warn('Failed to preload flexirecords for section', {
            sectionId: section.sectionid,
            error: error.message,
          }, LOG_CATEGORIES.SYNC);
          return { sectionId: section.sectionid, flexiRecords: null, success: false };
        }
      });

      const flexiRecordResults = await Promise.all(flexiRecordPromises);
      const successfulSections = flexiRecordResults.filter(r => r.success);
      
      logger.info('Loaded flexirecord lists', {
        successful: successfulSections.length,
        total: sections.length,
      }, LOG_CATEGORIES.SYNC);


      // Now load structures for all unique flexirecords found
      const allFlexiRecords = new Map();
      
      successfulSections.forEach(({ sectionId, flexiRecords }) => {
        if (flexiRecords &amp;&amp; flexiRecords.items) {
          flexiRecords.items.forEach(record => {
            if (record.extraid &amp;&amp; record.name &amp;&amp; record.archived !== '1' &amp;&amp; record.soft_deleted !== '1') {
              if (!allFlexiRecords.has(record.extraid)) {
                allFlexiRecords.set(record.extraid, {
                  extraid: record.extraid,
                  name: record.name,
                  sectionIds: [],
                });
              }
              allFlexiRecords.get(record.extraid).sectionIds.push(sectionId);
            }
          });
        }
      });

      if (allFlexiRecords.size === 0) {
        logger.info('No flexirecords found to preload structures for', {}, LOG_CATEGORIES.SYNC);
        return;
      }

      logger.info('Preloading structures for unique flexirecords', {
        count: allFlexiRecords.size,
      }, LOG_CATEGORIES.SYNC);

      // Load structures in parallel - only for "Viking Event Mgmt" and "Viking Section Movers" records
      const vikingRecords = Array.from(allFlexiRecords.values()).filter(record => 
        record.name === 'Viking Event Mgmt' || record.name === 'Viking Section Movers',
      );
      
      logger.info('Loading structures for Viking flexirecords', {
        totalRecords: allFlexiRecords.size,
        vikingEventMgmt: vikingRecords.filter(r => r.name === 'Viking Event Mgmt').length,
        vikingSectionMovers: vikingRecords.filter(r => r.name === 'Viking Section Movers').length,
      }, LOG_CATEGORIES.SYNC);
      
      const structurePromises = vikingRecords.map(async (record) => {
        try {
          // Use first section ID for the request
          const sectionId = record.sectionIds[0];
          await getFlexiStructure(record.extraid, sectionId, null, token);
          return { success: true, record };
        } catch (error) {
          logger.warn('Failed to preload structure for Viking flexirecord', {
            recordName: record.name,
            extraid: record.extraid,
            error: error.message,
          }, LOG_CATEGORIES.SYNC);
          return { success: false, record };
        }
      });

      const structureResults = await Promise.all(structurePromises);
      const successfulStructures = structureResults.filter(r => r.success);

      logger.info('Preloaded flexirecord structures', {
        successful: successfulStructures.length,
        total: allFlexiRecords.size,
      }, LOG_CATEGORIES.SYNC);

    } catch (error) {
      logger.error('Error preloading flexirecord structures', {
        error: error.message,
        stack: error.stack,
      }, LOG_CATEGORIES.SYNC);
      throw error;
    }
  }

  // Auto-sync disabled - user must manually sync via dashboard
  async setupAutoSync() {
    // Auto-sync functionality disabled to prevent unwanted OSM API calls
    // User must manually trigger sync via dashboard sync button
  }
}

export default new SyncService();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DatabaseService.html">DatabaseService</a></li><li><a href="module-EventCard.html">EventCard</a></li><li><a href="module-FlexiRecordService.html">FlexiRecordService</a></li><li><a href="module-ageUtils.html">ageUtils</a></li><li><a href="module-auth.html">auth</a></li><li><a href="module-cacheCleanup.html">cacheCleanup</a></li><li><a href="module-flexiRecordTransforms.html">flexiRecordTransforms</a></li><li><a href="module-logger.html">logger</a></li><li><a href="module-notifications.html">notifications</a></li><li><a href="module-sectionHelpers.html">sectionHelpers</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-logger-logger.html">logger</a></li></ul><h3>Classes</h3><ul><li><a href="APIQueue.html">APIQueue</a></li><li><a href="ErrorBoundary.html">ErrorBoundary</a></li><li><a href="RateLimitQueue.html">RateLimitQueue</a></li><li><a href="SyncService.html">SyncService</a></li><li><a href="module-DatabaseService-DatabaseService.html">DatabaseService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Alert">Alert</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#AppContent">AppContent</a></li><li><a href="global.html#AppRouter">AppRouter</a></li><li><a href="global.html#AuthButton">AuthButton</a></li><li><a href="global.html#CampGroupCard">CampGroupCard</a></li><li><a href="global.html#CampGroupsView">CampGroupsView</a></li><li><a href="global.html#ConfirmModal">ConfirmModal</a></li><li><a href="global.html#DEMO_CACHE_DATA">DEMO_CACHE_DATA</a></li><li><a href="global.html#GroupNamesEditModal">GroupNamesEditModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#REQUIRED_VIKING_SECTION_MOVERS_FIELDS">REQUIRED_VIKING_SECTION_MOVERS_FIELDS</a></li><li><a href="global.html#SectionFilter">SectionFilter</a></li><li><a href="global.html#_generateProductionFormatAttendance">_generateProductionFormatAttendance</a></li><li><a href="global.html#assignMemberToCampGroupDemo">assignMemberToCampGroupDemo</a></li><li><a href="global.html#batchAssignMembers">batchAssignMembers</a></li><li><a href="global.html#buildEventCard">buildEventCard</a></li><li><a href="global.html#checkNetworkStatus">checkNetworkStatus</a></li><li><a href="global.html#clearFlexiRecordCaches">clearFlexiRecordCaches</a></li><li><a href="global.html#cn">cn</a></li><li><a href="global.html#convertSharedEventToAttendanceFormat">convertSharedEventToAttendanceFormat</a></li><li><a href="global.html#demoConfig">demoConfig</a></li><li><a href="global.html#expandSharedEvents">expandSharedEvents</a></li><li><a href="global.html#extractFlexiRecordContext">extractFlexiRecordContext</a></li><li><a href="global.html#fetchAllSectionEvents">fetchAllSectionEvents</a></li><li><a href="global.html#fetchEventAttendance">fetchEventAttendance</a></li><li><a href="global.html#fetchMostRecentTermId">fetchMostRecentTermId</a></li><li><a href="global.html#fetchSectionEvents">fetchSectionEvents</a></li><li><a href="global.html#filterEventsByDateRange">filterEventsByDateRange</a></li><li><a href="global.html#formatPhoneForCall">formatPhoneForCall</a></li><li><a href="global.html#generateDemoSharedAttendance">generateDemoSharedAttendance</a></li><li><a href="global.html#generateVikingSectionMoversErrorMessages">generateVikingSectionMoversErrorMessages</a></li><li><a href="global.html#getEventAttendance">getEventAttendance</a></li><li><a href="global.html#getEventSharingStatus">getEventSharingStatus</a></li><li><a href="global.html#getEventSummary">getEventSummary</a></li><li><a href="global.html#getEvents">getEvents</a></li><li><a href="global.html#getFlexiRecords">getFlexiRecords</a></li><li><a href="global.html#getFlexiStructure">getFlexiStructure</a></li><li><a href="global.html#getListOfMembers">getListOfMembers</a></li><li><a href="global.html#getMembersGrid">getMembersGrid</a></li><li><a href="global.html#getMostRecentTermId">getMostRecentTermId</a></li><li><a href="global.html#getSharedEventAttendance">getSharedEventAttendance</a></li><li><a href="global.html#getSingleFlexiRecord">getSingleFlexiRecord</a></li><li><a href="global.html#getStartupData">getStartupData</a></li><li><a href="global.html#getTerms">getTerms</a></li><li><a href="global.html#getUserAccessibleSections">getUserAccessibleSections</a></li><li><a href="global.html#getUserRoles">getUserRoles</a></li><li><a href="global.html#groupContactInfo">groupContactInfo</a></li><li><a href="global.html#groupEventsByName">groupEventsByName</a></li><li><a href="global.html#handleAPIResponseWithRateLimit">handleAPIResponseWithRateLimit</a></li><li><a href="global.html#handlePhoneCall">handlePhoneCall</a></li><li><a href="global.html#initializeDemoMode">initializeDemoMode</a></li><li><a href="global.html#isDemoMode">isDemoMode</a></li><li><a href="global.html#isSharedEventOwner">isSharedEventOwner</a></li><li><a href="global.html#isValidPhoneNumber">isValidPhoneNumber</a></li><li><a href="global.html#logRateLimitInfo">logRateLimitInfo</a></li><li><a href="global.html#mergeSharedAndSectionAttendance">mergeSharedAndSectionAttendance</a></li><li><a href="global.html#multiUpdateFlexiRecord">multiUpdateFlexiRecord</a></li><li><a href="global.html#organizeByCampGroups">organizeByCampGroups</a></li><li><a href="global.html#parseTimestamp">parseTimestamp</a></li><li><a href="global.html#quickValidateVikingSectionMovers">quickValidateVikingSectionMovers</a></li><li><a href="global.html#retrieveUserInfo">retrieveUserInfo</a></li><li><a href="global.html#safeCacheWithLogging">safeCacheWithLogging</a></li><li><a href="global.html#safeGetItem">safeGetItem</a></li><li><a href="global.html#safeGetSessionItem">safeGetSessionItem</a></li><li><a href="global.html#safeSetItem">safeSetItem</a></li><li><a href="global.html#safeSetSessionItem">safeSetSessionItem</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepWithAbort">sleepWithAbort</a></li><li><a href="global.html#testBackendConnection">testBackendConnection</a></li><li><a href="global.html#updateFlexiRecord">updateFlexiRecord</a></li><li><a href="global.html#useAttendanceData">useAttendanceData</a></li><li><a href="global.html#useSignInOut">useSignInOut</a></li><li><a href="global.html#validateMemberMove">validateMemberMove</a></li><li><a href="global.html#validateTokenBeforeAPICall">validateTokenBeforeAPICall</a></li><li><a href="global.html#validateVikingSectionMoversFlexiRecord">validateVikingSectionMoversFlexiRecord</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Sep 12 2025 17:57:38 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
