<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/utils/eventDashboardHelpers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/utils/eventDashboardHelpers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Event Dashboard Helper Functions
// Extracted from EventDashboard component for better testability and reusability

import { fetchMostRecentTermId, getEvents, getEventAttendance, getTerms, getEventSummary, getEventSharingStatus } from '../services/api/api.js';
import { getMostRecentTermId } from './termUtils.js';
import databaseService from '../services/storage/database.js';
import logger, { LOG_CATEGORIES } from '../services/utils/logger.js';
import { isDemoMode } from '../../config/demoMode.js';

/**
 * Fetches events for all sections with optimized terms loading
 * @param {Array} sections - Array of section objects
 * @param {string|null} token - Authentication token (null for cache-only)
 * @returns {Promise&lt;Array>} Array of all events from all sections
 */
export const fetchAllSectionEvents = async (sections, token) => {
  const allEvents = [];
  
  // Load terms once for all sections (major optimization!)
  let allTerms = null;
  if (token) {
    try {
      logger.info('Loading terms once for all sections', {}, LOG_CATEGORIES.COMPONENT);
      allTerms = await getTerms(token); // This will use cache from sync process
      logger.info('Using cached terms', { sectionCount: Object.keys(allTerms || {}).length }, LOG_CATEGORIES.COMPONENT);
    } catch (err) {
      logger.error('Error loading terms, will use individual API calls as fallback', { error: err }, LOG_CATEGORIES.COMPONENT);
    }
  } else {
    // Load offline cached terms once (avoid per-section localStorage parsing)
    try {
      if (typeof localStorage !== 'undefined') {
        const demoMode = isDemoMode();
        const termsKey = demoMode ? 'demo_viking_terms_offline' : 'viking_terms_offline';
        const cachedTerms = localStorage.getItem(termsKey);
        if (cachedTerms) {
          allTerms = JSON.parse(cachedTerms);
          logger.info('Using offline cached terms', { sectionCount: Object.keys(allTerms || {}).length }, LOG_CATEGORIES.COMPONENT);
        }
      }
    } catch (err) {
      logger.warn('Failed to parse offline terms from localStorage', { error: err }, LOG_CATEGORIES.COMPONENT);
    }
  }
  
  // Fetch events for all sections using cached terms
  const results = await Promise.all(
    sections.map(async (section) => {
      try {
        return await fetchSectionEvents(section, token, allTerms);
      } catch (err) {
        logger.error('Error processing section {sectionId}', { 
          error: err, 
          sectionId: section.sectionid,
          sectionName: section.sectionname, 
        }, LOG_CATEGORIES.COMPONENT);
        return [];
      }
    }),
  );
  for (const sectionEvents of results) {
    allEvents.push(...sectionEvents);
  }
  
  return allEvents;
};

/**
 * Fetches events for a single section from API or cache
 * @param {Object} section - Section object with sectionid and sectionname
 * @param {string|null} token - Authentication token (null for cache-only)
 * @param {Object|null} allTerms - Pre-loaded terms data (optional optimization)
 * @returns {Promise&lt;Array>} Array of events for the section
 */
export const fetchSectionEvents = async (section, token, allTerms = null) => {
  try {
    let events = [];
    
    if (token) {
      // Rate limiting handled by queue
      
      // Fetch from API - use cached terms if available for major optimization
      // Defensive check for section ID (allows valid falsy values like 0)
      if (section.sectionid === null || section.sectionid === undefined) {
        logger.warn('Skipping section with invalid ID in fetchSectionEvents', {
          sectionid: section.sectionid,
          sectionname: section.sectionname,
          sectiontype: section.sectiontype,
          section: section.section,
        }, LOG_CATEGORIES.API);
        return []; // Return empty array for invalid section
      }
      
      let termId;
      if (allTerms) {
        // Use pre-loaded terms (avoids API call per section!)
        termId = getMostRecentTermId(section.sectionid, allTerms);
      } else {
        // Fallback to individual API call
        termId = await fetchMostRecentTermId(section.sectionid, token);
      }
      
      if (termId) {
        // Rate limiting now handled by RateLimitQueue
        const sectionEvents = await getEvents(section.sectionid, termId, token);
        if (sectionEvents &amp;&amp; Array.isArray(sectionEvents)) {
          events = sectionEvents.map(event => ({
            ...event,
            sectionid: section.sectionid,
            sectionname: section.sectionname,
            termid: termId,
          }));
          
          // Save to cache (with termid included)
          await databaseService.saveEvents(section.sectionid, events);
        }
      }
    } else {
      // Load from cache
      const cachedEvents = (await databaseService.getEvents(section.sectionid)) || [];
      
      // Get termId for cached events too (same logic as API path)
      let termId;
      if (allTerms) {
        // Use pre-loaded terms (avoids API call per section!)
        termId = getMostRecentTermId(section.sectionid, allTerms);
      } else {
        // Fallback: try to get from cached event or fetch from API if needed
        termId = cachedEvents[0]?.termid;
        
        // If still no termId, try to get from localStorage terms cache
        if (!termId) {
          try {
            const demoMode = isDemoMode();
            const termsKey = demoMode ? 'demo_viking_terms_offline' : 'viking_terms_offline';
            const cachedTerms = localStorage.getItem(termsKey);
            if (cachedTerms) {
              const parsedTerms = JSON.parse(cachedTerms);
              termId = getMostRecentTermId(section.sectionid, parsedTerms);
            }
          } catch (error) {
            logger.warn('Failed to get termId from localStorage terms cache', { error }, LOG_CATEGORIES.COMPONENT);
          }
        }
      }
      
      events = cachedEvents.map(event => ({
        ...event,
        sectionid: section.sectionid,  // CRITICAL FIX: Add missing sectionid 
        sectionname: section.sectionname,
        termid: termId || event.termid, // Use fetched termId, fallback to cached termid (don't default to null)
      }));
      
    }
    
    return events;
  } catch (err) {
    logger.error('Error fetching events for section {sectionId}', { 
      error: err, 
      sectionId: section.sectionid,
      sectionName: section.sectionname,
    }, LOG_CATEGORIES.API);
    return [];
  }
};

/**
 * Fetches attendance data for a single event from API or cache
 * For shared events where user has access to owner section, fetches and merges shared attendance data
 * @param {Object} event - Event object with eventid, sectionid, termid
 * @param {string|null} token - Authentication token (null for cache-only)
 * @param {Array|null} allEvents - Array of all events (needed for shared event processing)
 * @returns {Promise&lt;Array|null>} Attendance data (merged for shared events) or null if failed
 */
export const fetchEventAttendance = async (event, token, _allEvents = null) => {
  try {
    // Skip all API calls in demo mode to prevent rate limiting, but still process shared events
    const demoMode = isDemoMode();
    if (!token &amp;&amp; !demoMode) {
      // No token and not demo mode - load from database cache only
      const cachedAttendance = await databaseService.getAttendance(event.eventid);
      // Handle both array format (regular events) and object format (shared events)
      if (Array.isArray(cachedAttendance)) {
        return cachedAttendance;
      } else if (cachedAttendance &amp;&amp; cachedAttendance.items) {
        return cachedAttendance.items;
      }
      return cachedAttendance || [];
    }
    
    // In demo mode, first check localStorage cache (where demo data is stored)
    if (demoMode) {
      try {
        const cacheKey = `demo_viking_attendance_${event.sectionid}_${event.termid}_${event.eventid}_offline`;
        const cachedData = localStorage.getItem(cacheKey);
        if (cachedData) {
          const attendanceData = JSON.parse(cachedData);
          
          // Check if this is a shared event in demo mode by looking for shared metadata
          const { isDemoMode } = await import('../../config/demoMode.js');
          const prefix = isDemoMode() ? 'demo_' : '';
          const sharedMetadataKey = `${prefix}viking_shared_metadata_${event.eventid}`;
          const sharedMetadata = localStorage.getItem(sharedMetadataKey);
          if (sharedMetadata) {
            try {
              const metadata = JSON.parse(sharedMetadata);
              if (metadata._isSharedEvent) {
                
                // For shared events in demo mode, we might need to combine with other sections
                // Check if there are other sections' data to combine
                const allSections = metadata._allSections || [];
                const combinedAttendanceData = [...attendanceData];
                
                // Add synthetic attendance data for other sections if needed
                for (const section of allSections) {
                  if (section.sectionid !== event.sectionid &amp;&amp; section.attendance > 0) {
                    // Generate synthetic attendees for this section
                    for (let i = 0; i &lt; section.attendance; i++) {
                      combinedAttendanceData.push({
                        scoutid: `synthetic-${section.sectionid}-${i}`,
                        sectionid: section.sectionid,
                        sectionname: section.sectionname,
                        attending: 'Yes',
                        firstname: `Member ${i + 1}`,
                        lastname: `(${section.sectionname})`,
                        groupname: section.groupname,
                      });
                    }
                  }
                }
                
                return combinedAttendanceData;
              }
            } catch (metadataError) {
              if (import.meta.env.DEV) {
                logger.warn('Failed to parse shared metadata in demo mode', {
                  eventId: event.eventid,
                  error: metadataError.message,
                }, LOG_CATEGORIES.COMPONENT);
              }
            }
          }
          
          return attendanceData;
        }
      } catch (error) {
        if (import.meta.env.DEV) {
          logger.warn('Failed to parse demo attendance data from localStorage', {
            eventId: event.eventid,
            error: error.message,
          }, LOG_CATEGORIES.COMPONENT);
        }
      }
      
      // If no localStorage data found, return empty array for demo mode
      return [];
    }
    
    // Only log API calls, not every cache check
    // Removed debug log to reduce console spam
    
    // Check for cached attendance first to avoid unnecessary API calls
    const cachedAttendance = await databaseService.getAttendance(event.eventid);
    if (cachedAttendance) {
      // Check cache age to determine if we should refresh
      const cacheKey = `viking_attendance_cache_time_${event.eventid}`;
      const cacheTime = localStorage.getItem(cacheKey);
      const cacheAge = cacheTime ? Date.now() - parseInt(cacheTime) : Infinity;
      const maxCacheAge = 60 * 60 * 1000; // 1 hour
      
      if (cacheAge &lt; maxCacheAge) {
        // Use cached data if it's fresh
        return Array.isArray(cachedAttendance) ? cachedAttendance : (cachedAttendance.items || []);
      }
    }
    
    // If termid is missing, get it from API
    let termId = event.termid;
    if (!termId) {
      termId = await fetchMostRecentTermId(event.sectionid, token);
    }
    
    if (!termId) {
      return cachedAttendance || [];
    }
    
    // Get basic attendance data first
    const sectionSpecificAttendanceData = await getEventAttendance(
      event.sectionid, 
      event.eventid, 
      termId, 
      token,
    );
    
    if (!sectionSpecificAttendanceData) {
      if (import.meta.env.DEV) {
        logger.warn('No section-specific attendance data returned from API', {
          eventId: event.eventid,
          eventName: event.name,
        }, LOG_CATEGORIES.COMPONENT);
      }
      return cachedAttendance || [];
    }

    // For production, limit shared event processing to reduce API calls
    // Only check for shared events if explicitly enabled or in development
    const checkForSharedEvents = import.meta.env.DEV || import.meta.env.VITE_ENABLE_SHARED_EVENT_DETECTION === 'true';
    
    if (!checkForSharedEvents) {
      // Save basic attendance data to cache and return it
      await databaseService.saveAttendance(event.eventid, sectionSpecificAttendanceData);
      localStorage.setItem(`viking_attendance_cache_time_${event.eventid}`, Date.now().toString());
      return sectionSpecificAttendanceData;
    }
    
    // Check for shared event only if enabled (reduces API calls significantly)
    try {
      const eventSummary = await getEventSummary(event.eventid, token);
      
      // Check if this event has sharing information
      if (eventSummary?.data?.sharing) {
        if (import.meta.env.DEV) {
          logger.debug('Event has sharing data', {
            eventId: event.eventid,
            isOwner: eventSummary.data.sharing.is_owner,
          }, LOG_CATEGORIES.COMPONENT);
        }
        
        // If this section is the owner or participant of a shared event
        if (eventSummary.data.sharing.is_owner || eventSummary.data.sharing.is_owner === false) {
          try {
            // Get shared event data with section attendance counts
            const sharedEventData = await getEventSharingStatus(event.eventid, event.sectionid, token);
            
            if (sharedEventData) {
              // For shared events, create attendance data from section-level counts
              const sharedAttendanceData = convertSharedEventToAttendanceFormat(sharedEventData);
              
              // Combine section-specific and shared data for maximum detail
              const combinedAttendanceData = [
                // Include real section-specific data (has No/Invited/NotInvited details)
                ...sectionSpecificAttendanceData,
                // Include synthetic data for sections we don't have access to
                ...sharedAttendanceData.items.filter(item => 
                  item.scoutid &amp;&amp; item.scoutid.startsWith('synthetic-'),
                ),
              ];
              
              // Save combined attendance data to cache
              await databaseService.saveAttendance(event.eventid, combinedAttendanceData);
              localStorage.setItem(`viking_attendance_cache_time_${event.eventid}`, Date.now().toString());
              
              // Store shared event metadata separately for event expansion
              const { isDemoMode } = await import('../../config/demoMode.js');
              const prefix = isDemoMode() ? 'demo_' : '';
              const metadata = {
                _isSharedEvent: true,
                _allSections: sharedEventData.items,
                _sourceEvent: event,
              };
              localStorage.setItem(`${prefix}viking_shared_metadata_${event.eventid}`, JSON.stringify(metadata));
              
              return combinedAttendanceData;
            }
          } catch (sharedErr) {
            if (import.meta.env.DEV) {
              logger.warn('Failed to fetch shared event data, falling back to section-specific data', {
                eventId: event.eventid,
                error: sharedErr.message,
              }, LOG_CATEGORIES.API);
            }
            // Fall through to use section-specific data only
          }
        }
      }
    } catch (summaryErr) {
      if (import.meta.env.DEV) {
        logger.warn('Failed to fetch event summary, treating as regular event', {
          eventId: event.eventid,
          error: summaryErr.message,
        }, LOG_CATEGORIES.API);
      }
      // Continue to return section-specific data for regular events
    }
    
    // Default: Save section-specific data to cache and return it
    await databaseService.saveAttendance(event.eventid, sectionSpecificAttendanceData);
    localStorage.setItem(`viking_attendance_cache_time_${event.eventid}`, Date.now().toString());
    return sectionSpecificAttendanceData;
    
  } catch (err) {
    logger.error('Error fetching attendance for event {eventId}', { 
      error: err, 
      eventId: event.eventid,
      eventName: event.name,
      sectionId: event.sectionid,
    }, LOG_CATEGORIES.API);
    
    // Return cached data as fallback
    const cachedAttendance = await databaseService.getAttendance(event.eventid);
    return Array.isArray(cachedAttendance) ? cachedAttendance : (cachedAttendance?.items || []);
  }
};

/**
 * Groups events by their name
 * @param {Array} events - Array of event objects
 * @returns {Map} Map of event names to arrays of events
 */
export const groupEventsByName = (events) => {
  const eventGroups = new Map();
  
  for (const event of events) {
    const eventName = event.name;
    if (!eventGroups.has(eventName)) {
      eventGroups.set(eventName, []);
    }
    eventGroups.get(eventName).push(event);
  }
  
  return eventGroups;
};

/**
 * Builds an individual event card from grouped events
 * @param {string} eventName - Name of the event
 * @param {Array} events - Array of events with the same name
 * @returns {Object} Event card object
 */
export const buildEventCard = (eventName, events) => {
  // Sort events within group by date
  const sorted = [...events].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));
  
  // Create card with earliest event date for sorting
  return {
    id: `${eventName}-${sorted[0].eventid}`,
    name: eventName,
    events: sorted,
    earliestDate: new Date(sorted[0].startdate),
    sections: [...new Set(sorted.map(e => e.sectionname))],
  };
};

/**
 * Filters events to include only future events and events from the past week
 * @param {Array} events - Array of event objects
 * @param {Date} oneWeekAgo - Date representing one week ago
 * @returns {Array} Filtered events
 */
export const filterEventsByDateRange = (events, oneWeekAgo) => {
  return events.filter(event => {
    const eventDate = new Date(event.startdate);
    return eventDate >= oneWeekAgo;
  });
};

/**
 * Detects if an event is a shared event owner based on attendance data
 * @param {Object} attendanceData - Attendance data response from API
 * @returns {boolean} True if this section owns a shared event
 */
export const isSharedEventOwner = (attendanceData) => {
  // Check if the response has sharing info and is_owner is true
  if (attendanceData &amp;&amp; attendanceData.sharing &amp;&amp; attendanceData.sharing.is_owner === true) {
    return true;
  }
  return false;
};

/**
 * Extracts sections that the user has direct access to from events
 * @param {Array} events - Array of event objects with sectionid  
 * @returns {Set} Set of section IDs the user has access to
 */
export const getUserAccessibleSections = (events) => {
  return new Set(events.map(event => event.sectionid));
};

/**
 * Converts shared event data from getEventSharingStatus to attendance format for EventCard compatibility
 * @param {Object} sharedEventData - Response from getEventSharingStatus API with section-level counts
 * @returns {Object} Attendance data compatible with EventCard component
 */
export const convertSharedEventToAttendanceFormat = (sharedEventData) => {
  try {
    // Filter out null/empty section entries (these are totals/summaries)
    const sections = (sharedEventData?.items || []).filter(section => 
      section.sectionid &amp;&amp; section.sectionname &amp;&amp; 
      section.sectionid !== null &amp;&amp; section.sectionid !== 'null' &amp;&amp;
      section.sectionname !== null &amp;&amp; section.sectionname !== 'null',
    );
    
    // Create synthetic attendance records for each section based on their counts
    const attendanceItems = [];
    const attendanceSummary = { Yes: 0, No: 0, 'Not invited': 0, total_members: 0 };
    const sectionsInfo = [];
    
    sections.forEach(section => {
      // Add section info
      sectionsInfo.push({
        sectionid: parseInt(section.sectionid),
        section_name: section.sectionname,
        member_count: section.attendance || 0,
        hasDirectAccess: false, // For shared events, access level doesn't matter for display
        status: section.status, // Owner, Accepted, Pending
      });
      
      // For each attending member, create a synthetic attendance record  
      for (let i = 0; i &lt; (section.attendance || 0); i++) {
        attendanceItems.push({
          scoutid: `synthetic-${section.sectionid}-${i}`,
          sectionid: section.sectionid,
          sectionname: section.sectionname,
          attending: 'Yes',
          firstname: `Member ${i + 1}`, // Synthetic name for display count
          lastname: `(${section.sectionname})`,
          groupname: section.groupname,
        });
      }
      
      // Add to summary counts
      attendanceSummary.Yes += section.attendance || 0;
      attendanceSummary['Not invited'] += section.none || 0;
      attendanceSummary.total_members += (section.attendance || 0) + (section.none || 0);
    });
    
    if (import.meta.env.DEV) {
      logger.info('Converted shared event data to attendance format', {
        totalSections: sections.length,
        totalAttendees: attendanceSummary.Yes,
        totalNotInvited: attendanceSummary['Not invited'],
        sectionsWithAttendance: sections.filter(s => s.attendance > 0).length,
        attendanceItemsCreated: attendanceItems.length,
        sectionsInfo: sectionsInfo.map(s => `${s.section_name}: ${s.member_count}`),
        allSectionsData: sections.map(s => `${s.sectionname} (${s.sectionid}): ${s.attendance || 0} attending`),
      }, LOG_CATEGORIES.COMPONENT);
    }
    
    return {
      items: attendanceItems,
      summary: attendanceSummary,
      sections: sectionsInfo,
      sharing: {
        isSharedEvent: true,
        hasSharedData: true,
      },
    };
    
  } catch (error) {
    logger.error('Error converting shared event data to attendance format', {
      error: error.message,
      hasData: !!sharedEventData,
    }, LOG_CATEGORIES.COMPONENT);
    
    // Return empty structure on error
    return {
      items: [],
      summary: { Yes: 0, No: 0, 'Not invited': 0, total_members: 0 },
      sections: [],
      sharing: { isSharedEvent: true, hasSharedData: false },
    };
  }
};

/**
 * Expands shared events to include synthetic events for all participating sections
 * This allows EventCard to display attendance for all sections in shared events
 * @param {Array} events - Original events array (only user-accessible sections)
 * @param {Map} attendanceMap - Map of event IDs to attendance data
 * @returns {Array} Expanded events array including synthetic events for shared event sections
 */
export const expandSharedEvents = (events, attendanceMap) => {
  // For shared events, we DON'T want to create synthetic events for each section
  // Instead, we want the EventCard to handle displaying all sections within a single card
  // So we'll just return the original events array without expansion
  
  if (import.meta.env.DEV) {
    logger.debug('expandSharedEvents called - returning original events to prevent duplicate cards', {
      eventsCount: events.length,
      attendanceMapSize: attendanceMap.size,
      eventNames: events.map(e => e.name).slice(0, 5), // First 5 event names
    }, LOG_CATEGORIES.COMPONENT);
  }

  // The shared event data is already combined in the attendance data
  // EventCard will handle displaying all sections using the combined attendance data
  return events;
};

/**
 * Merges shared event attendance with section-specific attendance data
 * Combines attendee names from shared API with complete counts from section-specific APIs
 * @param {Object} sharedAttendanceData - Response from getSharedEventAttendance API
 * @param {Array} sectionSpecificAttendanceData - Array of attendance data from section-specific APIs
 * @param {Set} sectionsToShow - Set of section IDs to include in the output (all shared sections for shared events)
 * @returns {Object} Merged attendance data with combined attendees and accurate counts
 */
export const mergeSharedAndSectionAttendance = (sharedAttendanceData, sectionSpecificAttendanceData, sectionsToShow) => {
  try {
    // Get shared attendees (all "Yes" responses from all sections)
    // The shared API returns combined attendance in 'items' property
    const sharedAttendees = sharedAttendanceData?.items || [];
    
    // Get section-specific attendees (includes No/Maybe/Not invited for accessible sections)
    const sectionAttendees = sectionSpecificAttendanceData.flatMap(data => data.items || []);
    
    logger.info('Merging attendance data', {
      sharedCount: sharedAttendees.length,
      sectionCount: sectionAttendees.length,
      sectionsToShow: Array.from(sectionsToShow),
    }, LOG_CATEGORIES.COMPONENT);
    
    // Create a map for quick lookup of shared attendees
    const sharedAttendeesMap = new Map();
    sharedAttendees.forEach(attendee => {
      // Shared API uses scoutid, section API might use memberid
      const id = attendee.scoutid || attendee.memberid;
      const key = `${id}-${attendee.sectionid}`;
      sharedAttendeesMap.set(key, attendee);
    });
    
    // Merge logic: start with shared attendees, then add section-specific data that's not already included
    const mergedAttendees = [...sharedAttendees];
    
    // Add section-specific attendees that aren't already in shared data
    sectionAttendees.forEach(attendee => {
      // Section API might use different ID field than shared API
      const id = attendee.scoutid || attendee.memberid;
      const key = `${id}-${attendee.sectionid}`;
      
      // If not already in shared data, add it
      if (!sharedAttendeesMap.has(key)) {
        mergedAttendees.push(attendee);
      }
    });
    
    // Calculate merged summary counts
    const attendanceCountMap = {};
    mergedAttendees.forEach(attendee => {
      const attendance = attendee.attending || 'Unknown';
      attendanceCountMap[attendance] = (attendanceCountMap[attendance] || 0) + 1;
    });
    
    // Build sections summary from shared data and fill in gaps from section-specific data
    const sectionsMap = new Map();
    
    // Extract sections from shared attendee data (since no separate sections array)
    sharedAttendees.forEach(attendee => {
      const sectionId = parseInt(attendee.sectionid);
      if (!sectionsMap.has(sectionId)) {
        sectionsMap.set(sectionId, {
          sectionid: sectionId,
          section_name: attendee.sectionname,
          member_count: 0, // Will be calculated below
          hasDirectAccess: false, // For shared events, we show all sections regardless of access
        });
      }
    });
    
    // Count members per section from shared data
    sharedAttendees.forEach(attendee => {
      const sectionId = parseInt(attendee.sectionid);
      if (sectionsMap.has(sectionId)) {
        sectionsMap.get(sectionId).member_count += 1;
      }
    });
    
    // Add/update sections from section-specific data
    sectionSpecificAttendanceData.forEach(data => {
      if (data.items &amp;&amp; data.items.length > 0) {
        const firstItem = data.items[0];
        const sectionId = firstItem.sectionid;
        
        // For shared events, include all sections that have data
        if (sectionsToShow.has(sectionId)) {
          sectionsMap.set(sectionId, {
            sectionid: sectionId,
            section_name: firstItem.sectionname,
            member_count: data.items.length,
            hasDirectAccess: false, // For shared events, access level doesn't matter for display
          });
        }
      }
    });
    
    const mergedData = {
      items: mergedAttendees,
      summary: {
        total_members: mergedAttendees.length,
        ...attendanceCountMap,
      },
      sections: Array.from(sectionsMap.values()),
      sharing: {
        isSharedEvent: true,
        hasSharedData: true,
      },
    };
    
    logger.info('Attendance merge completed', {
      totalAttendees: mergedAttendees.length,
      sectionsCount: mergedData.sections.length,
      summaryBreakdown: attendanceCountMap,
    }, LOG_CATEGORIES.COMPONENT);
    
    return mergedData;
    
  } catch (error) {
    logger.error('Error merging shared and section attendance data', {
      error: error.message,
      sharedDataAvailable: !!sharedAttendanceData,
      sectionDataCount: sectionSpecificAttendanceData?.length || 0,
    }, LOG_CATEGORIES.COMPONENT);
    
    // Fallback to section-specific data only
    return sectionSpecificAttendanceData.flatMap(data => data.items || []);
  }
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-notifications.html">notifications</a></li></ul><h3>Classes</h3><ul><li><a href="APIQueue.html">APIQueue</a></li><li><a href="RateLimitQueue.html">RateLimitQueue</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Alert">Alert</a></li><li><a href="global.html#AuthButton">AuthButton</a></li><li><a href="global.html#CampGroupCard">CampGroupCard</a></li><li><a href="global.html#CampGroupsView">CampGroupsView</a></li><li><a href="global.html#ConfirmModal">ConfirmModal</a></li><li><a href="global.html#DEMO_CACHE_DATA">DEMO_CACHE_DATA</a></li><li><a href="global.html#GroupNamesEditModal">GroupNamesEditModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#REQUIRED_VIKING_SECTION_MOVERS_FIELDS">REQUIRED_VIKING_SECTION_MOVERS_FIELDS</a></li><li><a href="global.html#SectionFilter">SectionFilter</a></li><li><a href="global.html#_generateProductionFormatAttendance">_generateProductionFormatAttendance</a></li><li><a href="global.html#assignMemberToCampGroupDemo">assignMemberToCampGroupDemo</a></li><li><a href="global.html#batchAssignMembers">batchAssignMembers</a></li><li><a href="global.html#buildEventCard">buildEventCard</a></li><li><a href="global.html#calculateActualAge">calculateActualAge</a></li><li><a href="global.html#calculateAge">calculateAge</a></li><li><a href="global.html#checkForDemoData">checkForDemoData</a></li><li><a href="global.html#checkNetworkStatus">checkNetworkStatus</a></li><li><a href="global.html#cleanupDemoCache">cleanupDemoCache</a></li><li><a href="global.html#clearFlexiRecordCaches">clearFlexiRecordCaches</a></li><li><a href="global.html#cn">cn</a></li><li><a href="global.html#convertSharedEventToAttendanceFormat">convertSharedEventToAttendanceFormat</a></li><li><a href="global.html#createAssignmentTrackingData">createAssignmentTrackingData</a></li><li><a href="global.html#demoConfig">demoConfig</a></li><li><a href="global.html#discoverVikingSectionMoversFlexiRecords">discoverVikingSectionMoversFlexiRecords</a></li><li><a href="global.html#expandSharedEvents">expandSharedEvents</a></li><li><a href="global.html#extractFlexiRecordContext">extractFlexiRecordContext</a></li><li><a href="global.html#extractVikingEventFields">extractVikingEventFields</a></li><li><a href="global.html#extractVikingSectionMoversContext">extractVikingSectionMoversContext</a></li><li><a href="global.html#fetchAllSectionEvents">fetchAllSectionEvents</a></li><li><a href="global.html#fetchEventAttendance">fetchEventAttendance</a></li><li><a href="global.html#fetchMostRecentTermId">fetchMostRecentTermId</a></li><li><a href="global.html#fetchSectionEvents">fetchSectionEvents</a></li><li><a href="global.html#filterEventsByDateRange">filterEventsByDateRange</a></li><li><a href="global.html#findMemberSectionName">findMemberSectionName</a></li><li><a href="global.html#findMemberSectionType">findMemberSectionType</a></li><li><a href="global.html#generateDemoSharedAttendance">generateDemoSharedAttendance</a></li><li><a href="global.html#generateVikingSectionMoversErrorMessages">generateVikingSectionMoversErrorMessages</a></li><li><a href="global.html#getConsolidatedFlexiRecord">getConsolidatedFlexiRecord</a></li><li><a href="global.html#getEventAttendance">getEventAttendance</a></li><li><a href="global.html#getEventSharingStatus">getEventSharingStatus</a></li><li><a href="global.html#getEventSummary">getEventSummary</a></li><li><a href="global.html#getEvents">getEvents</a></li><li><a href="global.html#getFlexiRecordData">getFlexiRecordData</a></li><li><a href="global.html#getFlexiRecordStructure">getFlexiRecordStructure</a></li><li><a href="global.html#getFlexiRecords">getFlexiRecords</a></li><li><a href="global.html#getFlexiRecordsList">getFlexiRecordsList</a></li><li><a href="global.html#getFlexiStructure">getFlexiStructure</a></li><li><a href="global.html#getListOfMembers">getListOfMembers</a></li><li><a href="global.html#getMembersGrid">getMembersGrid</a></li><li><a href="global.html#getMostRecentTermId">getMostRecentTermId</a></li><li><a href="global.html#getSharedEventAttendance">getSharedEventAttendance</a></li><li><a href="global.html#getSingleFlexiRecord">getSingleFlexiRecord</a></li><li><a href="global.html#getStartupData">getStartupData</a></li><li><a href="global.html#getTerms">getTerms</a></li><li><a href="global.html#getUniqueSectionsFromEvents">getUniqueSectionsFromEvents</a></li><li><a href="global.html#getUserAccessibleSections">getUserAccessibleSections</a></li><li><a href="global.html#getUserRoles">getUserRoles</a></li><li><a href="global.html#getVikingEventData">getVikingEventData</a></li><li><a href="global.html#getVikingEventDataForEvents">getVikingEventDataForEvents</a></li><li><a href="global.html#getVikingSectionMoversData">getVikingSectionMoversData</a></li><li><a href="global.html#groupContactInfo">groupContactInfo</a></li><li><a href="global.html#groupEventsByName">groupEventsByName</a></li><li><a href="global.html#handleAPIResponseWithRateLimit">handleAPIResponseWithRateLimit</a></li><li><a href="global.html#initializeDemoMode">initializeDemoMode</a></li><li><a href="global.html#isDemoMode">isDemoMode</a></li><li><a href="global.html#isSharedEventOwner">isSharedEventOwner</a></li><li><a href="global.html#logRateLimitInfo">logRateLimitInfo</a></li><li><a href="global.html#mergeSharedAndSectionAttendance">mergeSharedAndSectionAttendance</a></li><li><a href="global.html#multiUpdateFlexiRecord">multiUpdateFlexiRecord</a></li><li><a href="global.html#organizeByCampGroups">organizeByCampGroups</a></li><li><a href="global.html#organizeMembersByCampGroups">organizeMembersByCampGroups</a></li><li><a href="global.html#parseFlexiStructure">parseFlexiStructure</a></li><li><a href="global.html#parseTimestamp">parseTimestamp</a></li><li><a href="global.html#quickValidateVikingSectionMovers">quickValidateVikingSectionMovers</a></li><li><a href="global.html#retrieveUserInfo">retrieveUserInfo</a></li><li><a href="global.html#safeCacheWithLogging">safeCacheWithLogging</a></li><li><a href="global.html#safeGetItem">safeGetItem</a></li><li><a href="global.html#safeGetSessionItem">safeGetSessionItem</a></li><li><a href="global.html#safeSetItem">safeSetItem</a></li><li><a href="global.html#safeSetSessionItem">safeSetSessionItem</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepWithAbort">sleepWithAbort</a></li><li><a href="global.html#testBackendConnection">testBackendConnection</a></li><li><a href="global.html#transformFlexiRecordData">transformFlexiRecordData</a></li><li><a href="global.html#updateFlexiRecord">updateFlexiRecord</a></li><li><a href="global.html#useAttendanceData">useAttendanceData</a></li><li><a href="global.html#useSignInOut">useSignInOut</a></li><li><a href="global.html#validateAssignmentTrackingData">validateAssignmentTrackingData</a></li><li><a href="global.html#validateMemberMove">validateMemberMove</a></li><li><a href="global.html#validateTokenBeforeAPICall">validateTokenBeforeAPICall</a></li><li><a href="global.html#validateVikingSectionMoversCollection">validateVikingSectionMoversCollection</a></li><li><a href="global.html#validateVikingSectionMoversFields">validateVikingSectionMoversFields</a></li><li><a href="global.html#validateVikingSectionMoversFlexiRecord">validateVikingSectionMoversFlexiRecord</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Sep 10 2025 22:00:52 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
