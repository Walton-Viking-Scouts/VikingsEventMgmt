<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/utils/flexiRecordTransforms.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/utils/flexiRecordTransforms.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// FlexiRecord transformation utilities for Vikings Event Management Mobile
// Pure functions for data transformation and field mapping
import { sentryUtils } from '../services/utils/sentry.js';
import logger, { LOG_CATEGORIES } from '../services/utils/logger.js';

/**
 * Parse flexirecord structure configuration to create field mapping
 * Converts the config JSON string to a map of field IDs to actual column names
 * 
 * @param {Object} structureData - Structure data from getFlexiStructure API
 * @returns {Map&lt;string, Object>} Map of field ID to field metadata
 * @throws {Error} If structure data is invalid
 * 
 * @example
 * // Parse structure configuration
 * const fieldMapping = parseFlexiStructure(structureData);
 * console.log(fieldMapping.get('f_1')); // { name: 'CampGroup', width: '150' }
 */
export function parseFlexiStructure(structureData) {
  try {
    if (!structureData || typeof structureData !== 'object') {
      throw new Error('Invalid structure data: must be an object');
    }

    const fieldMapping = new Map();

    // Parse config JSON if it exists (contains field mappings)
    if (structureData.config) {
      try {
        const configArray = JSON.parse(structureData.config);
        if (Array.isArray(configArray)) {
          configArray.forEach(field => {
            if (field.id &amp;&amp; field.name) {
              fieldMapping.set(field.id, {
                name: field.name,
                width: field.width || '150',
                fieldId: field.id,
              });
            }
          });
        }
      } catch (configError) {
        logger.warn('Failed to parse flexirecord config JSON', {
          config: structureData.config,
          error: configError.message,
        }, LOG_CATEGORIES.APP);
      }
    }

    // Also parse structure array for additional metadata
    if (structureData.structure &amp;&amp; Array.isArray(structureData.structure)) {
      structureData.structure.forEach(section => {
        if (section.rows &amp;&amp; Array.isArray(section.rows)) {
          section.rows.forEach(row => {
            if (row.field &amp;&amp; row.field.startsWith('f_')) {
              const existing = fieldMapping.get(row.field) || {};
              fieldMapping.set(row.field, {
                ...existing,
                name: row.name || existing.name,
                width: row.width || existing.width || '150px',
                fieldId: row.field,
                editable: row.editable || false,
                formatter: row.formatter,
              });
            }
          });
        }
      });
    }

    // Debug logging removed to prevent console spam
    // Structure parsed successfully with fieldMapping.size fields

    return fieldMapping;
  } catch (error) {
    logger.error('Error parsing flexirecord structure', {
      error: error.message,
      structureData: structureData,
      stack: error.stack,
    }, LOG_CATEGORIES.ERROR);

    sentryUtils.captureException(error, {
      tags: {
        operation: 'parse_flexi_structure',
      },
      contexts: {
        structureData: {
          hasConfig: !!(structureData &amp;&amp; structureData.config),
          hasStructure: !!(structureData &amp;&amp; structureData.structure),
          extraid: structureData?.extraid,
        },
      },
    });

    throw error;
  }
}

/**
 * Transform flexirecord data by mapping generic field names to actual column names
 * Converts f_1, f_2, etc. to their meaningful names like CampGroup, SignedInBy, etc.
 * 
 * @param {Object} flexiData - Data from getSingleFlexiRecord API
 * @param {Map&lt;string, Object>} fieldMapping - Field mapping from parseFlexiStructure
 * @returns {Object} Transformed data with meaningful field names
 * @throws {Error} If data is invalid
 * 
 * @example
 * // Transform flexirecord data
 * const transformedData = transformFlexiRecordData(flexiData, fieldMapping);
 * // Now access data.items[0].CampGroup instead of data.items[0].f_1
 */
export function transformFlexiRecordData(flexiData, fieldMapping) {
  try {
    if (!flexiData || typeof flexiData !== 'object') {
      throw new Error('Invalid flexiData: must be an object');
    }

    if (!fieldMapping || !(fieldMapping instanceof Map)) {
      throw new Error('Invalid fieldMapping: must be a Map');
    }

    if (!flexiData.items || !Array.isArray(flexiData.items)) {
      logger.warn('FlexiRecord data has no items array', {
        hasItems: !!flexiData.items,
        itemsType: typeof flexiData.items,
      }, LOG_CATEGORIES.APP);
      
      return {
        ...flexiData,
        items: [],
        fieldMapping: Object.fromEntries(fieldMapping),
      };
    }

    const transformedItems = flexiData.items.map(item => {
      const transformedItem = { ...item };

      // Transform generic field names to meaningful names
      fieldMapping.forEach((fieldInfo, fieldId) => {
        if (Object.prototype.hasOwnProperty.call(item, fieldId)) {
          const meaningfulName = fieldInfo.name;
          transformedItem[meaningfulName] = item[fieldId];
          
          // Keep original field for reference if needed
          transformedItem[`_original_${fieldId}`] = item[fieldId];
        }
      });

      return transformedItem;
    });

    const result = {
      ...flexiData,
      items: transformedItems,
      fieldMapping: Object.fromEntries(fieldMapping),
      _metadata: {
        originalFieldCount: fieldMapping.size,
        transformedAt: new Date().toISOString(),
        totalItems: transformedItems.length,
      },
    };

    // FlexiRecord data transformed successfully

    return result;
  } catch (error) {
    logger.error('Error transforming flexirecord data', {
      error: error.message,
      hasFlexiData: !!flexiData,
      hasFieldMapping: !!fieldMapping,
      fieldMappingSize: fieldMapping?.size || 0,
      stack: error.stack,
    }, LOG_CATEGORIES.ERROR);

    sentryUtils.captureException(error, {
      tags: {
        operation: 'transform_flexi_record_data',
      },
      contexts: {
        data: {
          hasItems: !!(flexiData &amp;&amp; flexiData.items),
          itemsCount: flexiData?.items?.length || 0,
          fieldMappingSize: fieldMapping?.size || 0,
        },
      },
    });

    throw error;
  }
}

/**
 * Extract expected Viking Event Management fields from flexirecord data
 * Specifically looks for CampGroup, SignedInBy, SignedInWhen, SignedOutBy, SignedOutWhen
 * 
 * @param {Object} consolidatedData - Consolidated flexirecord data
 * @returns {Array} Array of scout data with Viking Event Management fields
 * 
 * @example
 * // Extract Viking-specific fields
 * const vikingData = extractVikingEventFields(consolidatedData);
 * vikingData.forEach(scout => {
 *   console.log(`${scout.firstname}: Camp Group ${scout.CampGroup}, Signed In: ${scout.SignedInWhen}`);
 * });
 */
export function extractVikingEventFields(consolidatedData) {
  try {
    if (!consolidatedData || !consolidatedData.items) {
      return [];
    }

    const vikingFields = ['CampGroup', 'SignedInBy', 'SignedInWhen', 'SignedOutBy', 'SignedOutWhen'];
    
    return consolidatedData.items.map(scout => {
      const vikingScout = {
        // Core scout info
        scoutid: scout.scoutid,
        firstname: scout.firstname,
        lastname: scout.lastname,
        dob: scout.dob,
        age: scout.age,
        patrol: scout.patrol,
        patrolid: scout.patrolid,
        photo_guid: scout.photo_guid,
      };

      // Add Viking Event Management fields
      vikingFields.forEach(field => {
        if (Object.prototype.hasOwnProperty.call(scout, field)) {
          vikingScout[field] = scout[field];
        }
      });

      return vikingScout;
    });
  } catch (error) {
    logger.error('Error extracting Viking event fields', {
      error: error.message,
      hasConsolidatedData: !!consolidatedData,
    }, LOG_CATEGORIES.ERROR);

    return [];
  }
}

// Helper function removed - now using person_type directly from getSummaryStats data

/**
 * Organize members by their camp groups
 * Since Register and Camp Groups use the same data, just process the attendees array
 * which already has vikingEventData attached from getSummaryStats()
 * 
 * @param {Array} processedMembers - Members with vikingEventData from getSummaryStats()
 * @returns {Object} Organized camp groups with leaders and young people
 * 
 * @example
 * const organized = organizeMembersByCampGroups(getSummaryStatsArray);
 * console.log(organized.groups['Group 1'].youngPeople); // Young people in group 1
 */
export function organizeMembersByCampGroups(processedMembers) {
  try {
    if (!processedMembers || !Array.isArray(processedMembers)) {
      logger.warn('Invalid processed members data provided', {
        hasProcessedMembers: !!processedMembers,
        isArray: Array.isArray(processedMembers),
      }, LOG_CATEGORIES.APP);
      
      return { groups: {}, summary: { totalGroups: 0, totalMembers: 0 } };
    }

    logger.debug('Organizing members by camp groups', {
      totalProcessedMembers: processedMembers.length,
    }, LOG_CATEGORIES.APP);

    const groups = {};
    let processedCount = 0;
    let allHaveVikingEventData = true;

    // Process each member (they already have vikingEventData from getSummaryStats)
    processedMembers.forEach(member => {
      // Skip if no member data
      if (!member) {
        return;
      }

      // Filter out Leaders and Young Leaders using person_type from getSummaryStats
      if (member.person_type === 'Leaders' || member.person_type === 'Young Leaders') {
        logger.debug('Skipping leader from camp groups', {
          scoutid: member.scoutid,
          name: member.name,
          personType: member.person_type,
        }, LOG_CATEGORIES.APP);
        return;
      }

      // Get camp group assignment - getSummaryStats attaches vikingEventData
      const campGroupNumber = member.vikingEventData?.CampGroup;
      const groupName = campGroupNumber ? `Group ${campGroupNumber}` : 'Group Unassigned';

      // Initialize group if it doesn't exist
      if (!groups[groupName]) {
        groups[groupName] = {
          name: groupName,
          number: Number.isFinite(Number(campGroupNumber)) ? Number(campGroupNumber) : null,
          leaders: [], // Keep empty - no leaders in camp groups
          youngPeople: [],
          totalMembers: 0,
        };
      }

      // Add member to the appropriate group (leaders filtered out above)  
      const memberWithGroup = {
        ...member,
        campGroup: campGroupNumber,
        groupName: groupName,
      };
      
      // Debug member name issue - log to Sentry
      if (processedCount &lt; 2) {
        logger.info(`organizeMembersByCampGroups DEBUG: Processing member ${processedCount}. Original name: "${member.name}", After transform: "${memberWithGroup.name}", Name preserved: ${member.name === memberWithGroup.name}`, {
          originalName: member.name,
          transformedName: memberWithGroup.name,
          namePreserved: member.name === memberWithGroup.name,
          memberKeys: Object.keys(member).join(', '),
        }, LOG_CATEGORIES.APP);
      }
      
      groups[groupName].youngPeople.push(memberWithGroup);
      groups[groupName].totalMembers++;
      
      // Track viking event data availability
      allHaveVikingEventData &amp;&amp;= !!member.vikingEventData;
      
      processedCount++;
    });

    // Sort groups by number (Unassigned goes last)
    const sortedGroupNames = Object.keys(groups).sort((a, b) => {
      if (a === 'Group Unassigned') return 1;
      if (b === 'Group Unassigned') return -1;
      
      const aNum = parseInt(a.replace('Group ', ''));
      const bNum = parseInt(b.replace('Group ', ''));
      return aNum - bNum;
    });

    // Create sorted groups object
    const sortedGroups = {};
    sortedGroupNames.forEach(groupName => {
      const group = groups[groupName];
      
      // Sort members within each group by lastname, firstname
      group.leaders.sort((a, b) => {
        const aName = `${a.lastname || ''} ${a.firstname || ''}`.trim();
        const bName = `${b.lastname || ''} ${b.firstname || ''}`.trim();
        return aName.localeCompare(bName);
      });
      
      group.youngPeople.sort((a, b) => {
        const aName = `${a.lastname || ''} ${a.firstname || ''}`.trim();
        const bName = `${b.lastname || ''} ${b.firstname || ''}`.trim();
        return aName.localeCompare(bName);
      });
      
      sortedGroups[groupName] = group;
    });

    const summary = {
      totalGroups: Object.keys(sortedGroups).length,
      totalMembers: processedCount,
      totalLeaders: Object.values(sortedGroups).reduce((sum, group) => sum + group.leaders.length, 0),
      totalYoungPeople: Object.values(sortedGroups).reduce((sum, group) => sum + group.youngPeople.length, 0),
      hasUnassigned: !!sortedGroups['Group Unassigned'],
      vikingEventDataAvailable: allHaveVikingEventData, // Derived from actual member data
    };

    logger.debug('Successfully organized members by camp groups', {
      totalGroups: summary.totalGroups,
      totalMembers: summary.totalMembers,
      totalLeaders: summary.totalLeaders,
      totalYoungPeople: summary.totalYoungPeople,
      hasUnassigned: summary.hasUnassigned,
      groupNames: Object.keys(sortedGroups),
    }, LOG_CATEGORIES.APP);

    return {
      groups: sortedGroups,
      summary,
    };
  } catch (error) {
    logger.error('Error organizing members by camp groups', {
      error: error.message,
      hasProcessedMembers: !!processedMembers,
      stack: error.stack,
    }, LOG_CATEGORIES.ERROR);

    sentryUtils.captureException(error, {
      tags: {
        operation: 'organize_members_by_camp_groups',
      },
      contexts: {
        data: {
          processedMembersCount: processedMembers?.length || 0,
        },
      },
    });

    // Return empty structure on error
    return { groups: {}, summary: { totalGroups: 0, totalMembers: 0 } };
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DatabaseService.html">DatabaseService</a></li><li><a href="module-EventCard.html">EventCard</a></li><li><a href="module-FlexiRecordService.html">FlexiRecordService</a></li><li><a href="module-auth.html">auth</a></li><li><a href="module-logger.html">logger</a></li><li><a href="module-notifications.html">notifications</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-logger-logger.html">logger</a></li></ul><h3>Classes</h3><ul><li><a href="APIQueue.html">APIQueue</a></li><li><a href="RateLimitQueue.html">RateLimitQueue</a></li><li><a href="module-DatabaseService-DatabaseService.html">DatabaseService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Alert">Alert</a></li><li><a href="global.html#AuthButton">AuthButton</a></li><li><a href="global.html#CampGroupCard">CampGroupCard</a></li><li><a href="global.html#CampGroupsView">CampGroupsView</a></li><li><a href="global.html#ConfirmModal">ConfirmModal</a></li><li><a href="global.html#DEMO_CACHE_DATA">DEMO_CACHE_DATA</a></li><li><a href="global.html#GroupNamesEditModal">GroupNamesEditModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#REQUIRED_VIKING_SECTION_MOVERS_FIELDS">REQUIRED_VIKING_SECTION_MOVERS_FIELDS</a></li><li><a href="global.html#SectionFilter">SectionFilter</a></li><li><a href="global.html#_generateProductionFormatAttendance">_generateProductionFormatAttendance</a></li><li><a href="global.html#assignMemberToCampGroupDemo">assignMemberToCampGroupDemo</a></li><li><a href="global.html#batchAssignMembers">batchAssignMembers</a></li><li><a href="global.html#buildEventCard">buildEventCard</a></li><li><a href="global.html#calculateActualAge">calculateActualAge</a></li><li><a href="global.html#calculateAge">calculateAge</a></li><li><a href="global.html#checkForDemoData">checkForDemoData</a></li><li><a href="global.html#checkNetworkStatus">checkNetworkStatus</a></li><li><a href="global.html#cleanupDemoCache">cleanupDemoCache</a></li><li><a href="global.html#clearFlexiRecordCaches">clearFlexiRecordCaches</a></li><li><a href="global.html#cn">cn</a></li><li><a href="global.html#convertSharedEventToAttendanceFormat">convertSharedEventToAttendanceFormat</a></li><li><a href="global.html#demoConfig">demoConfig</a></li><li><a href="global.html#expandSharedEvents">expandSharedEvents</a></li><li><a href="global.html#extractFlexiRecordContext">extractFlexiRecordContext</a></li><li><a href="global.html#extractVikingEventFields">extractVikingEventFields</a></li><li><a href="global.html#fetchAllSectionEvents">fetchAllSectionEvents</a></li><li><a href="global.html#fetchEventAttendance">fetchEventAttendance</a></li><li><a href="global.html#fetchMostRecentTermId">fetchMostRecentTermId</a></li><li><a href="global.html#fetchSectionEvents">fetchSectionEvents</a></li><li><a href="global.html#filterEventsByDateRange">filterEventsByDateRange</a></li><li><a href="global.html#findMemberSectionName">findMemberSectionName</a></li><li><a href="global.html#findMemberSectionType">findMemberSectionType</a></li><li><a href="global.html#generateDemoSharedAttendance">generateDemoSharedAttendance</a></li><li><a href="global.html#generateVikingSectionMoversErrorMessages">generateVikingSectionMoversErrorMessages</a></li><li><a href="global.html#getEventAttendance">getEventAttendance</a></li><li><a href="global.html#getEventSharingStatus">getEventSharingStatus</a></li><li><a href="global.html#getEventSummary">getEventSummary</a></li><li><a href="global.html#getEvents">getEvents</a></li><li><a href="global.html#getFlexiRecords">getFlexiRecords</a></li><li><a href="global.html#getFlexiStructure">getFlexiStructure</a></li><li><a href="global.html#getListOfMembers">getListOfMembers</a></li><li><a href="global.html#getMembersGrid">getMembersGrid</a></li><li><a href="global.html#getMostRecentTermId">getMostRecentTermId</a></li><li><a href="global.html#getSharedEventAttendance">getSharedEventAttendance</a></li><li><a href="global.html#getSingleFlexiRecord">getSingleFlexiRecord</a></li><li><a href="global.html#getStartupData">getStartupData</a></li><li><a href="global.html#getTerms">getTerms</a></li><li><a href="global.html#getUniqueSectionsFromEvents">getUniqueSectionsFromEvents</a></li><li><a href="global.html#getUserAccessibleSections">getUserAccessibleSections</a></li><li><a href="global.html#getUserRoles">getUserRoles</a></li><li><a href="global.html#groupContactInfo">groupContactInfo</a></li><li><a href="global.html#groupEventsByName">groupEventsByName</a></li><li><a href="global.html#handleAPIResponseWithRateLimit">handleAPIResponseWithRateLimit</a></li><li><a href="global.html#initializeDemoMode">initializeDemoMode</a></li><li><a href="global.html#isDemoMode">isDemoMode</a></li><li><a href="global.html#isSharedEventOwner">isSharedEventOwner</a></li><li><a href="global.html#logRateLimitInfo">logRateLimitInfo</a></li><li><a href="global.html#mergeSharedAndSectionAttendance">mergeSharedAndSectionAttendance</a></li><li><a href="global.html#multiUpdateFlexiRecord">multiUpdateFlexiRecord</a></li><li><a href="global.html#organizeByCampGroups">organizeByCampGroups</a></li><li><a href="global.html#organizeMembersByCampGroups">organizeMembersByCampGroups</a></li><li><a href="global.html#parseFlexiStructure">parseFlexiStructure</a></li><li><a href="global.html#parseTimestamp">parseTimestamp</a></li><li><a href="global.html#quickValidateVikingSectionMovers">quickValidateVikingSectionMovers</a></li><li><a href="global.html#retrieveUserInfo">retrieveUserInfo</a></li><li><a href="global.html#safeCacheWithLogging">safeCacheWithLogging</a></li><li><a href="global.html#safeGetItem">safeGetItem</a></li><li><a href="global.html#safeGetSessionItem">safeGetSessionItem</a></li><li><a href="global.html#safeSetItem">safeSetItem</a></li><li><a href="global.html#safeSetSessionItem">safeSetSessionItem</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepWithAbort">sleepWithAbort</a></li><li><a href="global.html#testBackendConnection">testBackendConnection</a></li><li><a href="global.html#transformFlexiRecordData">transformFlexiRecordData</a></li><li><a href="global.html#updateFlexiRecord">updateFlexiRecord</a></li><li><a href="global.html#useAttendanceData">useAttendanceData</a></li><li><a href="global.html#useSignInOut">useSignInOut</a></li><li><a href="global.html#validateMemberMove">validateMemberMove</a></li><li><a href="global.html#validateTokenBeforeAPICall">validateTokenBeforeAPICall</a></li><li><a href="global.html#validateVikingSectionMoversFlexiRecord">validateVikingSectionMoversFlexiRecord</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Sep 10 2025 22:12:57 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
