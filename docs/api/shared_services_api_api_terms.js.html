<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/services/api/api/terms.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/services/api/api/terms.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Terms API service
// Extracted from monolithic api.js for better modularity

import {
  BACKEND_URL,
  validateTokenBeforeAPICall,
  handleAPIResponseWithRateLimit,
  apiQueue,
} from './base.js';
import { withRateLimitQueue } from '../../../utils/rateLimitQueue.js';
import { checkNetworkStatus } from '../../../utils/networkUtils.js';
import { safeGetItem, safeSetItem } from '../../../utils/storageUtils.js';
import { isDemoMode } from '../../../../config/demoMode.js';
import { getMostRecentTermId } from '../../../utils/termUtils.js';
import logger, { LOG_CATEGORIES } from '../../utils/logger.js';

// Terms cache TTL - localStorage only for persistence
const TERMS_CACHE_TTL = 30 * 60 * 1000; // 30 minutes

/**
 * Retrieves OSM terms data with caching and offline support
 * @param {string} token - OSM authentication token
 * @param {boolean} [forceRefresh=false] - Force refresh from API instead of using cache
 * @returns {Promise&lt;Object>} Terms data from OSM API
 * @throws {Error} When token is missing or API request fails
 * 
 * @example
 * const terms = await getTerms(userToken);
 * const freshTerms = await getTerms(userToken, true);
 */
export async function getTerms(token, forceRefresh = false) {
  try {
    // Skip API calls in demo mode - use cached data only
    const demoMode = isDemoMode();
    if (demoMode) {
      const cacheKey = 'demo_viking_terms_offline';
      const cached = safeGetItem(cacheKey, { items: [] });
      if (import.meta.env.DEV) {
        logger.debug('Demo mode: Using cached terms data', {
          termsCount: cached.items?.length || 0,
        }, LOG_CATEGORIES.API);
      }
      return cached;
    }
    
    const cacheKey = demoMode ? 'demo_viking_terms_offline' : 'viking_terms_offline';
    
    // Check network status first
    const isOnline = await checkNetworkStatus();
    
    // Check if we have valid cached data (unless force refresh)
    if (!forceRefresh &amp;&amp; isOnline) {
      const cached = safeGetItem(cacheKey, null);
      if (cached &amp;&amp; cached._cacheTimestamp) {
        const cacheAge = Date.now() - cached._cacheTimestamp;
        if (cacheAge &lt; TERMS_CACHE_TTL) {
          logger.info('Using cached terms data', { 
            cacheAgeMinutes: Math.round(cacheAge / 60000),
          }, LOG_CATEGORIES.API);
          return cached;
        }
      }
    }
    
    // If offline, get from localStorage regardless of age
    if (!isOnline) {
      const cached = safeGetItem(cacheKey, {});
      logger.info('Retrieved terms from localStorage while offline', {}, LOG_CATEGORIES.API);
      return cached;
    }

    // Validate token before making API call
    validateTokenBeforeAPICall(token, 'getTerms');

    const data = await withRateLimitQueue(async () => {
      const response = await fetch(`${BACKEND_URL}/get-terms`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });

      return await handleAPIResponseWithRateLimit(response, 'getTerms');
    });
    const terms = data || {};
    
    // Cache terms data with timestamp - enhanced error handling for visibility  
    try {
      const cachedTerms = {
        ...terms,
        _cacheTimestamp: Date.now(),
      };
      const success = safeSetItem(cacheKey, cachedTerms);
      if (success) {
        logger.info('Terms successfully cached', {
          cacheKey,
          termCount: Array.isArray(terms) 
            ? terms.length 
            : (terms?.items?.length ?? Object.keys(terms || {}).length),
          dataSize: JSON.stringify(cachedTerms).length,
        }, LOG_CATEGORIES.API);
      } else {
        logger.error('Terms caching failed - safeSetItem returned false', {
          cacheKey,
          termCount: Array.isArray(terms) 
            ? terms.length 
            : (terms?.items?.length ?? Object.keys(terms || {}).length),
          dataSize: JSON.stringify(cachedTerms).length,
        }, LOG_CATEGORIES.ERROR);
      }
    } catch (cacheError) {
      logger.error('Terms caching error', {
        cacheKey,
        error: cacheError.message,
        termCount: Array.isArray(terms) 
          ? terms.length 
          : (terms?.items?.length ?? Object.keys(terms || {}).length),
      }, LOG_CATEGORIES.ERROR);
    }
    
    return terms; // Return original data without timestamp
    
  } catch (error) {
    logger.error('Error fetching terms', {
      error: error.message,
      stack: error.stack,
    }, LOG_CATEGORIES.ERROR);
    
    // If online request fails, try localStorage as fallback
    const isOnline = await checkNetworkStatus();
    if (isOnline) {
      try {
        const demoMode = isDemoMode();
        const cacheKey = demoMode ? 'demo_viking_terms_offline' : 'viking_terms_offline';
        const cached = safeGetItem(cacheKey, {});
        logger.warn('Using cached terms after API failure', {}, LOG_CATEGORIES.API);
        return cached;
      } catch (cacheError) {
        logger.error('Cache fallback also failed', {
          error: cacheError.message,
        }, LOG_CATEGORIES.ERROR);
      }
    }
    
    throw error;
  }
}

/**
 * Fetches the most recent term ID for a specific section
 * @param {number|string} sectionId - OSM section identifier
 * @param {string} token - OSM authentication token
 * @returns {Promise&lt;string|null>} Most recent term ID or null if not found
 * @throws {Error} When API request fails or term cannot be determined
 * 
 * @example
 * const termId = await fetchMostRecentTermId(123, userToken);
 */
export async function fetchMostRecentTermId(sectionId, token) {
  return apiQueue.add(async () => {
    try {
      const terms = await getTerms(token);
      return getMostRecentTermId(sectionId, terms);
    } catch (error) {
      logger.error('Error fetching most recent term ID', { sectionId, error: error.message }, LOG_CATEGORIES.API);
      throw error;
    }
  });
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DatabaseService.html">DatabaseService</a></li><li><a href="module-EventCard.html">EventCard</a></li><li><a href="module-FlexiRecordService.html">FlexiRecordService</a></li><li><a href="module-ageUtils.html">ageUtils</a></li><li><a href="module-auth.html">auth</a></li><li><a href="module-cacheCleanup.html">cacheCleanup</a></li><li><a href="module-flexiRecordTransforms.html">flexiRecordTransforms</a></li><li><a href="module-logger.html">logger</a></li><li><a href="module-notifications.html">notifications</a></li><li><a href="module-sectionHelpers.html">sectionHelpers</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-logger-logger.html">logger</a></li></ul><h3>Classes</h3><ul><li><a href="APIQueue.html">APIQueue</a></li><li><a href="ErrorBoundary.html">ErrorBoundary</a></li><li><a href="RateLimitQueue.html">RateLimitQueue</a></li><li><a href="SyncService.html">SyncService</a></li><li><a href="module-DatabaseService-DatabaseService.html">DatabaseService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Alert">Alert</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#AppContent">AppContent</a></li><li><a href="global.html#AppRouter">AppRouter</a></li><li><a href="global.html#AuthButton">AuthButton</a></li><li><a href="global.html#CampGroupCard">CampGroupCard</a></li><li><a href="global.html#CampGroupsView">CampGroupsView</a></li><li><a href="global.html#ConfirmModal">ConfirmModal</a></li><li><a href="global.html#DEMO_CACHE_DATA">DEMO_CACHE_DATA</a></li><li><a href="global.html#GroupNamesEditModal">GroupNamesEditModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#REQUIRED_VIKING_SECTION_MOVERS_FIELDS">REQUIRED_VIKING_SECTION_MOVERS_FIELDS</a></li><li><a href="global.html#SectionFilter">SectionFilter</a></li><li><a href="global.html#_generateProductionFormatAttendance">_generateProductionFormatAttendance</a></li><li><a href="global.html#assignMemberToCampGroupDemo">assignMemberToCampGroupDemo</a></li><li><a href="global.html#batchAssignMembers">batchAssignMembers</a></li><li><a href="global.html#buildEventCard">buildEventCard</a></li><li><a href="global.html#checkNetworkStatus">checkNetworkStatus</a></li><li><a href="global.html#clearFlexiRecordCaches">clearFlexiRecordCaches</a></li><li><a href="global.html#cn">cn</a></li><li><a href="global.html#convertSharedEventToAttendanceFormat">convertSharedEventToAttendanceFormat</a></li><li><a href="global.html#demoConfig">demoConfig</a></li><li><a href="global.html#expandSharedEvents">expandSharedEvents</a></li><li><a href="global.html#extractFlexiRecordContext">extractFlexiRecordContext</a></li><li><a href="global.html#fetchAllSectionEvents">fetchAllSectionEvents</a></li><li><a href="global.html#fetchEventAttendance">fetchEventAttendance</a></li><li><a href="global.html#fetchMostRecentTermId">fetchMostRecentTermId</a></li><li><a href="global.html#fetchSectionEvents">fetchSectionEvents</a></li><li><a href="global.html#filterEventsByDateRange">filterEventsByDateRange</a></li><li><a href="global.html#formatPhoneForCall">formatPhoneForCall</a></li><li><a href="global.html#generateDemoSharedAttendance">generateDemoSharedAttendance</a></li><li><a href="global.html#generateVikingSectionMoversErrorMessages">generateVikingSectionMoversErrorMessages</a></li><li><a href="global.html#getEventAttendance">getEventAttendance</a></li><li><a href="global.html#getEventSharingStatus">getEventSharingStatus</a></li><li><a href="global.html#getEventSummary">getEventSummary</a></li><li><a href="global.html#getEvents">getEvents</a></li><li><a href="global.html#getFlexiRecords">getFlexiRecords</a></li><li><a href="global.html#getFlexiStructure">getFlexiStructure</a></li><li><a href="global.html#getListOfMembers">getListOfMembers</a></li><li><a href="global.html#getMembersGrid">getMembersGrid</a></li><li><a href="global.html#getMostRecentTermId">getMostRecentTermId</a></li><li><a href="global.html#getSharedEventAttendance">getSharedEventAttendance</a></li><li><a href="global.html#getSingleFlexiRecord">getSingleFlexiRecord</a></li><li><a href="global.html#getStartupData">getStartupData</a></li><li><a href="global.html#getTerms">getTerms</a></li><li><a href="global.html#getUserAccessibleSections">getUserAccessibleSections</a></li><li><a href="global.html#getUserRoles">getUserRoles</a></li><li><a href="global.html#groupContactInfo">groupContactInfo</a></li><li><a href="global.html#groupEventsByName">groupEventsByName</a></li><li><a href="global.html#handleAPIResponseWithRateLimit">handleAPIResponseWithRateLimit</a></li><li><a href="global.html#handlePhoneCall">handlePhoneCall</a></li><li><a href="global.html#initializeDemoMode">initializeDemoMode</a></li><li><a href="global.html#isDemoMode">isDemoMode</a></li><li><a href="global.html#isSharedEventOwner">isSharedEventOwner</a></li><li><a href="global.html#isValidPhoneNumber">isValidPhoneNumber</a></li><li><a href="global.html#logRateLimitInfo">logRateLimitInfo</a></li><li><a href="global.html#mergeSharedAndSectionAttendance">mergeSharedAndSectionAttendance</a></li><li><a href="global.html#multiUpdateFlexiRecord">multiUpdateFlexiRecord</a></li><li><a href="global.html#organizeByCampGroups">organizeByCampGroups</a></li><li><a href="global.html#parseTimestamp">parseTimestamp</a></li><li><a href="global.html#quickValidateVikingSectionMovers">quickValidateVikingSectionMovers</a></li><li><a href="global.html#retrieveUserInfo">retrieveUserInfo</a></li><li><a href="global.html#safeCacheWithLogging">safeCacheWithLogging</a></li><li><a href="global.html#safeGetItem">safeGetItem</a></li><li><a href="global.html#safeGetSessionItem">safeGetSessionItem</a></li><li><a href="global.html#safeSetItem">safeSetItem</a></li><li><a href="global.html#safeSetSessionItem">safeSetSessionItem</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepWithAbort">sleepWithAbort</a></li><li><a href="global.html#testBackendConnection">testBackendConnection</a></li><li><a href="global.html#updateFlexiRecord">updateFlexiRecord</a></li><li><a href="global.html#useAttendanceData">useAttendanceData</a></li><li><a href="global.html#useSignInOut">useSignInOut</a></li><li><a href="global.html#validateMemberMove">validateMemberMove</a></li><li><a href="global.html#validateTokenBeforeAPICall">validateTokenBeforeAPICall</a></li><li><a href="global.html#validateVikingSectionMoversFlexiRecord">validateVikingSectionMoversFlexiRecord</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Sep 12 2025 17:57:38 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
