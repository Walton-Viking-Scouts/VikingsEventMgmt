<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/utils/termUtils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/utils/termUtils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Term utility functions for Vikings Event Management Mobile
import { sentryUtils } from '../services/utils/sentry.js';
import logger, { LOG_CATEGORIES } from '../services/utils/logger.js';

/**
 * Find the most recent term from a list of terms based on end date
 * Compares term end dates to determine which is the most recent/current
 * 
 * @param {TermObject[]} terms - Array of term objects with enddate property
 * @returns {TermObject|null} Most recent term object or null if no valid terms
 * @throws {Error} If terms parameter is invalid
 * 
 * @typedef {Object} TermObject
 * @property {string} termid - Unique term identifier
 * @property {string} enddate - Term end date in ISO format or parseable date string
 * @property {string} [name] - Optional term name
 * @property {string} [startdate] - Optional term start date
 * 
 * @example
 * // Find current/most recent term from API response
 * const terms = [
 *   { termid: '1', enddate: '2023-07-31', name: 'Summer 2023' },
 *   { termid: '2', enddate: '2023-12-15', name: 'Autumn 2023' },
 *   { termid: '3', enddate: '2024-03-31', name: 'Spring 2024' }
 * ];
 * const currentTerm = findMostRecentTerm(terms); // Returns Spring 2024 term
 */
export function findMostRecentTerm(terms) {
  // Input validation
  if (!Array.isArray(terms)) {
    const error = new Error(`Invalid terms parameter: expected array, got ${typeof terms}`);
    
    logger.error('Invalid terms parameter for findMostRecentTerm', {
      providedType: typeof terms,
      isArray: Array.isArray(terms),
      isNull: terms === null,
      isUndefined: terms === undefined,
    }, LOG_CATEGORIES.ERROR);
    
    sentryUtils.captureException(error, {
      tags: {
        operation: 'find_most_recent_term',
        validation_error: true,
      },
      contexts: {
        input: {
          type: typeof terms,
          isArray: Array.isArray(terms),
          isNull: terms === null,
        },
      },
    });
    
    throw error;
  }

  if (terms.length === 0) {
    // No terms provided - this is a normal condition, not worth logging
    return null;
  }

  try {
    const mostRecentTerm = terms.reduce((latest, term) => {
      // Validate term object structure
      if (!term || typeof term !== 'object' || !term.enddate) {
        logger.warn('Invalid term object found', {
          term: term,
          hasEnddate: !!(term &amp;&amp; term.enddate),
        }, LOG_CATEGORIES.APP);
        return latest; // Skip invalid terms
      }

      const termEndDate = new Date(term.enddate);
      const latestEndDate = latest ? new Date(latest.enddate) : new Date(0);
      
      // Check for invalid dates
      if (isNaN(termEndDate.getTime())) {
        logger.warn('Invalid enddate in term', {
          termid: term.termid,
          enddate: term.enddate,
        }, LOG_CATEGORIES.APP);
        return latest; // Skip terms with invalid dates
      }
      
      return termEndDate > latestEndDate ? term : latest;
    }, null);

    // Successfully found most recent term - no need to log routine operations

    return mostRecentTerm;
  } catch (error) {
    logger.error('Error finding most recent term', {
      error: error.message,
      termsCount: terms.length,
      stack: error.stack,
    }, LOG_CATEGORIES.ERROR);

    sentryUtils.captureException(error, {
      tags: {
        operation: 'find_most_recent_term',
      },
      contexts: {
        terms: {
          count: terms.length,
          hasValidStructure: terms.every(t => t &amp;&amp; typeof t === 'object'),
        },
      },
    });

    throw error;
  }
}

/**
 * Get the most recent term ID for a specific section from pre-loaded terms data
 * Convenience function that combines section lookup with most recent term finding
 * 
 * @param {number|string} sectionId - Section ID to find terms for (will be converted to string for lookup)
 * @param {Object} allTerms - Terms object keyed by section ID, values are arrays of term objects
 * @returns {string|null} Most recent term ID or null if not found
 * @throws {Error} If parameters are invalid
 * 
 * @example
 * // Get current term ID for a specific section
 * const allTerms = {
 *   '101': [
 *     { termid: 'term1', enddate: '2023-12-31' },
 *     { termid: 'term2', enddate: '2024-06-30' }
 *   ],
 *   '102': [
 *     { termid: 'term3', enddate: '2024-03-31' }
 *   ]
 * };
 * 
 * const currentTermId = getMostRecentTermId(101, allTerms); // Returns 'term2'
 * const unknownSectionTerm = getMostRecentTermId(999, allTerms); // Returns null
 */
export function getMostRecentTermId(sectionId, allTerms) {
  // Input validation
  if (sectionId === null || sectionId === undefined) {
    const error = new Error('Section ID is required');
    
    logger.error('Missing section ID for getMostRecentTermId', {
      sectionId,
      hasAllTerms: !!allTerms,
    }, LOG_CATEGORIES.ERROR);
    
    throw error;
  }

  if (!allTerms || typeof allTerms !== 'object') {
    const error = new Error(`Invalid allTerms parameter: expected object, got ${typeof allTerms}`);
    
    logger.error('Invalid allTerms parameter', {
      sectionId,
      allTermsType: typeof allTerms,
      isNull: allTerms === null,
    }, LOG_CATEGORIES.ERROR);
    
    throw error;
  }

  // Convert sectionId to string for consistent lookup
  const sectionKey = String(sectionId);
  
  if (!allTerms[sectionKey]) {
    // No terms for this section - expected for some sections
    return null;
  }

  try {
    const mostRecentTerm = findMostRecentTerm(allTerms[sectionKey]);
    
    if (!mostRecentTerm) {
      logger.warn('No valid terms found for section', {
        sectionId: sectionKey,
        termsCount: allTerms[sectionKey].length,
      }, LOG_CATEGORIES.APP);
      return null;
    }

    // Successfully retrieved term ID - routine operation, no logging needed

    return mostRecentTerm.termid;
  } catch (error) {
    logger.error('Error getting most recent term ID', {
      sectionId: sectionKey,
      error: error.message,
      stack: error.stack,
    }, LOG_CATEGORIES.ERROR);

    sentryUtils.captureException(error, {
      tags: {
        operation: 'get_most_recent_term_id',
      },
      contexts: {
        section: {
          sectionId: sectionKey,
          hasTerms: !!(allTerms[sectionKey]),
          termsCount: allTerms[sectionKey]?.length || 0,
        },
      },
    });

    throw error;
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DatabaseService.html">DatabaseService</a></li><li><a href="module-EventCard.html">EventCard</a></li><li><a href="module-FlexiRecordService.html">FlexiRecordService</a></li><li><a href="module-ageUtils.html">ageUtils</a></li><li><a href="module-auth.html">auth</a></li><li><a href="module-cacheCleanup.html">cacheCleanup</a></li><li><a href="module-flexiRecordTransforms.html">flexiRecordTransforms</a></li><li><a href="module-logger.html">logger</a></li><li><a href="module-notifications.html">notifications</a></li><li><a href="module-sectionHelpers.html">sectionHelpers</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-logger-logger.html">logger</a></li></ul><h3>Classes</h3><ul><li><a href="APIQueue.html">APIQueue</a></li><li><a href="ErrorBoundary.html">ErrorBoundary</a></li><li><a href="RateLimitQueue.html">RateLimitQueue</a></li><li><a href="SyncService.html">SyncService</a></li><li><a href="module-DatabaseService-DatabaseService.html">DatabaseService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Alert">Alert</a></li><li><a href="global.html#AuthButton">AuthButton</a></li><li><a href="global.html#CampGroupCard">CampGroupCard</a></li><li><a href="global.html#CampGroupsView">CampGroupsView</a></li><li><a href="global.html#ConfirmModal">ConfirmModal</a></li><li><a href="global.html#DEMO_CACHE_DATA">DEMO_CACHE_DATA</a></li><li><a href="global.html#GroupNamesEditModal">GroupNamesEditModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#REQUIRED_VIKING_SECTION_MOVERS_FIELDS">REQUIRED_VIKING_SECTION_MOVERS_FIELDS</a></li><li><a href="global.html#SectionFilter">SectionFilter</a></li><li><a href="global.html#_generateProductionFormatAttendance">_generateProductionFormatAttendance</a></li><li><a href="global.html#assignMemberToCampGroupDemo">assignMemberToCampGroupDemo</a></li><li><a href="global.html#batchAssignMembers">batchAssignMembers</a></li><li><a href="global.html#buildEventCard">buildEventCard</a></li><li><a href="global.html#checkNetworkStatus">checkNetworkStatus</a></li><li><a href="global.html#clearFlexiRecordCaches">clearFlexiRecordCaches</a></li><li><a href="global.html#cn">cn</a></li><li><a href="global.html#convertSharedEventToAttendanceFormat">convertSharedEventToAttendanceFormat</a></li><li><a href="global.html#demoConfig">demoConfig</a></li><li><a href="global.html#expandSharedEvents">expandSharedEvents</a></li><li><a href="global.html#extractFlexiRecordContext">extractFlexiRecordContext</a></li><li><a href="global.html#fetchAllSectionEvents">fetchAllSectionEvents</a></li><li><a href="global.html#fetchEventAttendance">fetchEventAttendance</a></li><li><a href="global.html#fetchMostRecentTermId">fetchMostRecentTermId</a></li><li><a href="global.html#fetchSectionEvents">fetchSectionEvents</a></li><li><a href="global.html#filterEventsByDateRange">filterEventsByDateRange</a></li><li><a href="global.html#formatPhoneForCall">formatPhoneForCall</a></li><li><a href="global.html#generateDemoSharedAttendance">generateDemoSharedAttendance</a></li><li><a href="global.html#generateVikingSectionMoversErrorMessages">generateVikingSectionMoversErrorMessages</a></li><li><a href="global.html#getEventAttendance">getEventAttendance</a></li><li><a href="global.html#getEventSharingStatus">getEventSharingStatus</a></li><li><a href="global.html#getEventSummary">getEventSummary</a></li><li><a href="global.html#getEvents">getEvents</a></li><li><a href="global.html#getFlexiRecords">getFlexiRecords</a></li><li><a href="global.html#getFlexiStructure">getFlexiStructure</a></li><li><a href="global.html#getListOfMembers">getListOfMembers</a></li><li><a href="global.html#getMembersGrid">getMembersGrid</a></li><li><a href="global.html#getMostRecentTermId">getMostRecentTermId</a></li><li><a href="global.html#getSharedEventAttendance">getSharedEventAttendance</a></li><li><a href="global.html#getSingleFlexiRecord">getSingleFlexiRecord</a></li><li><a href="global.html#getStartupData">getStartupData</a></li><li><a href="global.html#getTerms">getTerms</a></li><li><a href="global.html#getUserAccessibleSections">getUserAccessibleSections</a></li><li><a href="global.html#getUserRoles">getUserRoles</a></li><li><a href="global.html#groupContactInfo">groupContactInfo</a></li><li><a href="global.html#groupEventsByName">groupEventsByName</a></li><li><a href="global.html#handleAPIResponseWithRateLimit">handleAPIResponseWithRateLimit</a></li><li><a href="global.html#handlePhoneCall">handlePhoneCall</a></li><li><a href="global.html#initializeDemoMode">initializeDemoMode</a></li><li><a href="global.html#isDemoMode">isDemoMode</a></li><li><a href="global.html#isSharedEventOwner">isSharedEventOwner</a></li><li><a href="global.html#isValidPhoneNumber">isValidPhoneNumber</a></li><li><a href="global.html#logRateLimitInfo">logRateLimitInfo</a></li><li><a href="global.html#mergeSharedAndSectionAttendance">mergeSharedAndSectionAttendance</a></li><li><a href="global.html#multiUpdateFlexiRecord">multiUpdateFlexiRecord</a></li><li><a href="global.html#organizeByCampGroups">organizeByCampGroups</a></li><li><a href="global.html#parseTimestamp">parseTimestamp</a></li><li><a href="global.html#quickValidateVikingSectionMovers">quickValidateVikingSectionMovers</a></li><li><a href="global.html#retrieveUserInfo">retrieveUserInfo</a></li><li><a href="global.html#safeCacheWithLogging">safeCacheWithLogging</a></li><li><a href="global.html#safeGetItem">safeGetItem</a></li><li><a href="global.html#safeGetSessionItem">safeGetSessionItem</a></li><li><a href="global.html#safeSetItem">safeSetItem</a></li><li><a href="global.html#safeSetSessionItem">safeSetSessionItem</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepWithAbort">sleepWithAbort</a></li><li><a href="global.html#testBackendConnection">testBackendConnection</a></li><li><a href="global.html#updateFlexiRecord">updateFlexiRecord</a></li><li><a href="global.html#useAttendanceData">useAttendanceData</a></li><li><a href="global.html#useSignInOut">useSignInOut</a></li><li><a href="global.html#validateMemberMove">validateMemberMove</a></li><li><a href="global.html#validateTokenBeforeAPICall">validateTokenBeforeAPICall</a></li><li><a href="global.html#validateVikingSectionMoversFlexiRecord">validateVikingSectionMoversFlexiRecord</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Sep 12 2025 15:24:48 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
