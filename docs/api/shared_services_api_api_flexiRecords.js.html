<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared/services/api/api/flexiRecords.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared/services/api/api/flexiRecords.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// FlexiRecords API service
// Extracted from monolithic api.js for better modularity

import {
  BACKEND_URL,
  validateTokenBeforeAPICall,
  handleAPIResponseWithRateLimit,
} from './base.js';
import { withRateLimitQueue } from '../../../utils/rateLimitQueue.js';
import { checkNetworkStatus } from '../../../utils/networkUtils.js';
import { safeGetItem, safeSetItem } from '../../../utils/storageUtils.js';
import { isDemoMode } from '../../../../config/demoMode.js';
import { authHandler } from '../../auth/authHandler.js';
import { checkWritePermission } from '../../auth/tokenService.js';
import logger, { LOG_CATEGORIES } from '../../utils/logger.js';

/**
 * Retrieves FlexiRecord definitions for a section with caching support
 * @param {number|string} sectionId - OSM section identifier
 * @param {string} token - OSM authentication token
 * @param {string} [archived='n'] - Include archived records ('y' or 'n')
 * @param {boolean} [forceRefresh=false] - Force refresh bypassing cache
 * @returns {Promise&lt;Object>} FlexiRecord list with items array
 * @throws {Error} When API request fails and no cached data available
 * 
 * @example
 * const flexiRecords = await getFlexiRecords(123, token);
 * console.log(`Found ${flexiRecords.items.length} FlexiRecords`);
 */
export async function getFlexiRecords(sectionId, token, archived = 'n', forceRefresh = false) {
  try {
    // Skip API calls in demo mode - use cached data only
    const demoMode = isDemoMode();
    if (demoMode) {
      const cacheKey = `demo_viking_flexi_lists_${sectionId}_offline`;
      const cached = safeGetItem(cacheKey, { items: [] });
      return cached;
    }
    
    const storageKey = `viking_flexi_records_${sectionId}_archived_${archived}_offline`;
    
    // Check network status first
    const isOnline = await checkNetworkStatus();
    
    // Check if we have valid cached data (unless force refresh)
    if (!forceRefresh &amp;&amp; isOnline) {
      const cached = safeGetItem(storageKey, null);
      if (cached &amp;&amp; cached._cacheTimestamp) {
        const cacheAge = Date.now() - cached._cacheTimestamp;
        const FLEXI_RECORDS_CACHE_TTL = 30 * 60 * 1000; // 30 minutes
        if (cacheAge &lt; FLEXI_RECORDS_CACHE_TTL) {
          return cached;
        }
      }
    }
    
    // If offline, get from localStorage regardless of age
    if (!isOnline) {
      const cached = safeGetItem(storageKey, { identifier: null, label: null, items: [] });
      return cached;
    }

    // Simple circuit breaker - use cache if auth already failed
    if (!authHandler.shouldMakeAPICall()) {
      const cached = safeGetItem(storageKey, null);
      // Validate cached data has meaningful content
      if (cached &amp;&amp; cached.items &amp;&amp; Array.isArray(cached.items)) {
        return cached;
      }
      // Return valid default structure if no meaningful cache exists
      return { identifier: null, label: null, items: [] };
    }

    const data = await withRateLimitQueue(async () => {
      // Online and allowed â€“ validate now
      validateTokenBeforeAPICall(token, 'getFlexiRecords');
      
      const response = await fetch(`${BACKEND_URL}/get-flexi-records?sectionid=${sectionId}&amp;archived=${archived}`, {
        method: 'GET',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });

      return await handleAPIResponseWithRateLimit(response, 'getFlexiRecords');
    });
        
    let flexiData;
    if (data &amp;&amp; data._rateLimitInfo) {
      const { _rateLimitInfo, ...responseData } = data;
      flexiData = responseData || { identifier: null, label: null, items: [] };
    } else {
      flexiData = data || { identifier: null, label: null, items: [] };
    }
    
    // Cache data with timestamp - enhanced error handling like getMembersGrid fix
    try {
      const cachedData = {
        ...flexiData,
        _cacheTimestamp: Date.now(),
      };
      const success = safeSetItem(storageKey, cachedData);
      if (success) {
        // FlexiRecord list successfully cached
      } else {
        logger.error('FlexiRecord list caching failed - safeSetItem returned false', {
          storageKey,
          itemCount: flexiData.items?.length || 0,
          dataSize: JSON.stringify(cachedData).length,
        }, LOG_CATEGORIES.ERROR);
      }
    } catch (cacheError) {
      logger.error('FlexiRecord list caching error', {
        storageKey,
        error: cacheError.message,
        itemCount: flexiData.items?.length || 0,
      }, LOG_CATEGORIES.ERROR);
    }
    
    return flexiData; // Return original data without timestamp

  } catch (error) {
    logger.error('Error fetching flexi records', { error: error.message }, LOG_CATEGORIES.API);
    
    // Don't cache error responses - only return existing cache as fallback
    const isOnline = await checkNetworkStatus();
    if (isOnline) {
      try {
        const storageKey = `viking_flexi_records_${sectionId}_archived_${archived}_offline`;
        const cached = safeGetItem(storageKey, { identifier: null, label: null, items: [] });
        logger.info('Using cached fallback data after API error', {}, LOG_CATEGORIES.API);
        return cached;
      } catch (cacheError) {
        logger.error('Cache fallback failed', { cacheError: cacheError.message }, LOG_CATEGORIES.API);
      }
    }
    
    throw error;
  }
}

/**
 * Retrieves data for a single FlexiRecord
 * @param {number|string} flexirecordid - FlexiRecord identifier
 * @param {number|string} sectionid - OSM section identifier
 * @param {number|string} termid - OSM term identifier
 * @param {string} token - OSM authentication token
 * @returns {Promise&lt;Object>} FlexiRecord data with member values
 * @throws {Error} When API request fails or authentication fails
 * 
 * @example
 * const flexiData = await getSingleFlexiRecord(456, 123, '789', token);
 * console.log(`FlexiRecord has ${flexiData.items.length} member entries`);
 */
export async function getSingleFlexiRecord(flexirecordid, sectionid, termid, token) {
  try {
    // Skip API calls in demo mode - use cached data only
    const demoMode = isDemoMode();
    if (demoMode) {
      const cacheKey = `demo_viking_flexi_data_${flexirecordid}_${sectionid}_${termid}_offline`;
      const cached = safeGetItem(cacheKey, { items: [] });
      return cached;
    }
    
    // Validate token before making API call
    validateTokenBeforeAPICall(token, 'getSingleFlexiRecord');

    // Simple circuit breaker - use cache if auth already failed
    if (!authHandler.shouldMakeAPICall()) {
      throw new Error('Authentication failed - unable to fetch flexi record data');
    }

    const data = await withRateLimitQueue(async () => {
      const response = await fetch(`${BACKEND_URL}/get-single-flexi-record?flexirecordid=${flexirecordid}&amp;sectionid=${sectionid}&amp;termid=${termid}`, {
        method: 'GET',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });
      
      return await handleAPIResponseWithRateLimit(response, 'getSingleFlexiRecord');
    });
        
    if (data &amp;&amp; data._rateLimitInfo) {
      const { _rateLimitInfo, ...flexiData } = data;
      return flexiData || { identifier: null, items: [] };
    }
        
    return data || { identifier: null, items: [] };
        
  } catch (error) {
    logger.error('Error fetching single flexi record', { error: error.message }, LOG_CATEGORIES.API);
    throw error;
  }
}

/**
 * Retrieves FlexiRecord structure definition with field mappings
 * @param {number|string} extraid - FlexiRecord external ID (same as flexirecordid)
 * @param {number|string} sectionid - OSM section identifier
 * @param {number|string} termid - OSM term identifier
 * @param {string} token - OSM authentication token
 * @param {boolean} [forceRefresh=false] - Force refresh bypassing cache
 * @returns {Promise&lt;Object|null>} Structure definition with field mappings or null
 * @throws {Error} When API request fails
 * 
 * @example
 * const structure = await getFlexiStructure(456, 123, '789', token);
 * if (structure) {
 *   console.log(`Structure: ${structure.name}`);
 * }
 */
export async function getFlexiStructure(extraid, sectionid, termid, token, forceRefresh = false) {
  try {
    // Skip API calls in demo mode - use cached data only
    const demoMode = isDemoMode();
    if (demoMode) {
      const cacheKey = `demo_viking_flexi_structure_${extraid}_offline`;
      const cached = safeGetItem(cacheKey, null);
      return cached;
    }
    
    const storageKey = demoMode ? `demo_viking_flexi_structure_${extraid}_offline` : `viking_flexi_structure_${extraid}_offline`;
    
    // Check network status first
    const isOnline = await checkNetworkStatus();
    
    // Check if we have valid cached data (unless force refresh)
    if (!forceRefresh &amp;&amp; isOnline) {
      const cached = safeGetItem(storageKey, null);
      if (cached &amp;&amp; cached._cacheTimestamp) {
        const cacheAge = Date.now() - cached._cacheTimestamp;
        const FLEXI_STRUCTURES_CACHE_TTL = 60 * 60 * 1000; // 60 minutes
        if (cacheAge &lt; FLEXI_STRUCTURES_CACHE_TTL) {
          return cached;
        }
      }
    }
    
    // If offline, get from localStorage regardless of age
    if (!isOnline) {
      const cached = safeGetItem(storageKey, null);
      if (cached) {
        logger.info('Retrieved structure from localStorage while offline', { 
          extraid,
          structureName: cached.name,
        }, LOG_CATEGORIES.OFFLINE);
        return cached;
      }
      return null;
    }

    // Simple circuit breaker - use cache if auth already failed
    if (!authHandler.shouldMakeAPICall()) {
      const cached = safeGetItem(storageKey, null);
      // Validate cached data exists and has meaningful content
      if (cached &amp;&amp; typeof cached === 'object' &amp;&amp; cached.name) {
        return cached;
      }
      // Return null for structure - caller should handle this case
      return null;
    }

    const data = await withRateLimitQueue(async () => {
      validateTokenBeforeAPICall(token, 'getFlexiStructure');
      
      const response = await fetch(`${BACKEND_URL}/get-flexi-structure?flexirecordid=${extraid}&amp;sectionid=${sectionid}&amp;termid=${termid}`, {
        method: 'GET',
        headers: { 
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json', 
        },
      });
      
      return await handleAPIResponseWithRateLimit(response, 'getFlexiStructure');
    });
    const structureData = data || null;
    
    // Cache data for offline use - enhanced error handling like getMembersGrid fix
    if (structureData) {
      try {
        const cachedData = {
          ...structureData,
          _cacheTimestamp: Date.now(),
        };
        const success = safeSetItem(storageKey, cachedData);
        if (success) {
          // FlexiRecord structure successfully cached
        } else {
          logger.error('FlexiRecord structure caching failed - safeSetItem returned false', {
            storageKey,
            structureName: structureData.name || 'Unknown',
            dataSize: JSON.stringify(cachedData).length,
          }, LOG_CATEGORIES.ERROR);
        }
      } catch (cacheError) {
        logger.error('FlexiRecord structure caching error', {
          storageKey,
          error: cacheError.message,
          structureName: structureData.name || 'Unknown',
        }, LOG_CATEGORIES.ERROR);
      }
    }
    
    return structureData;
    
  } catch (error) {
    logger.error('Error fetching flexi structure', { error: error.message }, LOG_CATEGORIES.API);
    
    // Don't cache error responses - only return existing cache as fallback
    const isOnline = await checkNetworkStatus();
    if (isOnline) {
      try {
        const demoMode = isDemoMode();
        const storageKey = demoMode ? `demo_viking_flexi_structure_${extraid}_offline` : `viking_flexi_structure_${extraid}_offline`;
        const cacheData = safeGetItem(storageKey, null);
        logger.info('Using cached fallback data after API error, not updating cache timestamp', {}, LOG_CATEGORIES.API);
        return cacheData;
      } catch (cacheError) {
        logger.error('Cache fallback failed', { cacheError: cacheError.message }, LOG_CATEGORIES.API);
      }
    }
    
    throw error;
  }
}

/**
 * Updates a FlexiRecord field value for a specific member
 * Requires valid authentication and write permissions
 * @param {number|string} sectionid - OSM section identifier
 * @param {number|string} scoutid - Member identifier
 * @param {number|string} flexirecordid - FlexiRecord identifier
 * @param {number|string} columnid - Field column identifier
 * @param {string} value - New field value
 * @param {number|string} termid - OSM term identifier
 * @param {string} section - Section name for context
 * @param {string} token - OSM authentication token
 * @returns {Promise&lt;Object|null>} Update response data
 * @throws {Error} When write permissions denied or API request fails
 * 
 * @example
 * await updateFlexiRecord(123, 456, 789, 'f_1', 'Blue Group', '2024', 'Beavers', token);
 */
export async function updateFlexiRecord(sectionid, scoutid, flexirecordid, columnid, value, termid, section, token) {
  // Demo mode protection
  if (isDemoMode()) {
    logger.info('Demo mode: Simulating updateFlexiRecord success', {
      scoutid,
      flexirecordid,
      columnid,
      value,
    }, LOG_CATEGORIES.API);
    return {
      ok: true,
      success: true,
      message: 'Demo mode: FlexiRecord update simulated',
    };
  }
  
  try {
    validateTokenBeforeAPICall(token, 'updateFlexiRecord');
    
    // Check if write operations are allowed (blocks offline writes with expired token)
    checkWritePermission();

    // Validate column id format (e.g. "f_1")
    if (typeof columnid !== 'string' || !/^f_\d+$/.test(columnid)) {
      const err = new Error('Invalid columnid format');
      err.status = 400;
      err.code = 'INVALID_COLUMN_ID';
      throw err;
    }

    const response = await fetch(`${BACKEND_URL}/update-flexi-record`, {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json', 
      },
      body: JSON.stringify({
        sectionid,
        scoutid,
        flexirecordid,
        columnid,
        value,
        termid,
        section,
      }),
    });
        
    const data = await handleAPIResponseWithRateLimit(response, 'updateFlexiRecord');
    return data || null;
        
  } catch (error) {
    logger.error('Error updating flexi record', { error: error.message }, LOG_CATEGORIES.API);
    throw error;
  }
}

/**
 * Multi-update FlexiRecord field for multiple members in a single batch operation
 * Updates the same field value for multiple scouts efficiently
 * 
 * @param {number|string} sectionid - OSM section identifier  
 * @param {Array&lt;string|number>} scouts - Array of scout/member IDs to update
 * @param {string} value - New field value to set for all scouts
 * @param {string} column - Field column ID (e.g., "f_1", "f_2")
 * @param {number|string} flexirecordid - FlexiRecord identifier
 * @param {string} token - OSM authentication token
 * @returns {Promise&lt;Object|null>} Update response with success status and updated count
 * @throws {Error} When write permissions denied or API request fails
 * 
 * @example
 * await multiUpdateFlexiRecord(123, ['456', '789'], 'Yellow', 'f_1', '999', token);
 */
export async function multiUpdateFlexiRecord(sectionid, scouts, value, column, flexirecordid, token) {
  // Demo mode protection
  if (isDemoMode()) {
    logger.info('Demo mode: Simulating multiUpdateFlexiRecord success', {
      sectionid,
      flexirecordid,
      column,
      value,
      scoutCount: Array.isArray(scouts) ? scouts.length : 0,
    }, LOG_CATEGORIES.API);
    return {
      ok: true,
      success: true,
      message: `Demo mode: Multi-update simulated for ${Array.isArray(scouts) ? scouts.length : 0} scouts`,
    };
  }
  
  validateTokenBeforeAPICall(token, 'multiUpdateFlexiRecord');
  logger.debug('multiUpdateFlexiRecord: Token validation passed', {}, LOG_CATEGORIES.API);
  
  try {
    // Check if write operations are allowed
    checkWritePermission();
    logger.debug('multiUpdateFlexiRecord: Write permission check passed', {}, LOG_CATEGORIES.API);

    // Validate column id format (e.g. "f_1")
    if (typeof column !== 'string' || !/^f_\d+$/.test(column)) {
      const err = new Error('Invalid column format');
      err.status = 400;
      err.code = 'INVALID_COLUMN_ID';
      throw err;
    }
    logger.debug('multiUpdateFlexiRecord: Column format validation passed', { column }, LOG_CATEGORIES.API);

    if (!Array.isArray(scouts) || scouts.length === 0) {
      throw new Error('Scouts array is required and must not be empty');
    }
    logger.debug('multiUpdateFlexiRecord: Scouts array validation passed', { scoutCount: scouts.length }, LOG_CATEGORIES.API);

    const requestBody = {
      sectionid,
      scouts,
      value,
      column,
      flexirecordid,
    };

    logger.debug('multiUpdateFlexiRecord: Making API call', { 
      url: `${BACKEND_URL}/multi-update-flexi-record`,
      requestBody, 
    }, LOG_CATEGORIES.API);

    const response = await fetch(`${BACKEND_URL}/multi-update-flexi-record`, {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json', 
      },
      body: JSON.stringify(requestBody),
    });

    logger.debug('multiUpdateFlexiRecord: Response received', { 
      status: response.status,
      statusText: response.statusText, 
    }, LOG_CATEGORIES.API);
        
    const data = await handleAPIResponseWithRateLimit(response, 'multiUpdateFlexiRecord');
    
    logger.debug('multiUpdateFlexiRecord: Response processed', { 
      success: data?.data?.success,
      data: data, 
    }, LOG_CATEGORIES.API);
    
    return data || null;
        
  } catch (error) {
    logger.error('Error multi-updating flexi record', { 
      error: error.message,
      sectionid,
      scoutCount: scouts?.length,
      value,
      column,
    }, LOG_CATEGORIES.API);
    throw error;
  }
}

// TODO: Move getConsolidatedFlexiRecord to shared layer to avoid circular dependency
// Temporarily removing cross-feature export

export { 
  parseFlexiStructure,
  transformFlexiRecordData,
  extractVikingEventFields,
} from '../../../utils/flexiRecordTransforms.js';</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DatabaseService.html">DatabaseService</a></li><li><a href="module-EventCard.html">EventCard</a></li><li><a href="module-FlexiRecordService.html">FlexiRecordService</a></li><li><a href="module-ageUtils.html">ageUtils</a></li><li><a href="module-auth.html">auth</a></li><li><a href="module-cacheCleanup.html">cacheCleanup</a></li><li><a href="module-flexiRecordTransforms.html">flexiRecordTransforms</a></li><li><a href="module-logger.html">logger</a></li><li><a href="module-notifications.html">notifications</a></li><li><a href="module-sectionHelpers.html">sectionHelpers</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-logger-logger.html">logger</a></li></ul><h3>Classes</h3><ul><li><a href="APIQueue.html">APIQueue</a></li><li><a href="ErrorBoundary.html">ErrorBoundary</a></li><li><a href="RateLimitQueue.html">RateLimitQueue</a></li><li><a href="SyncService.html">SyncService</a></li><li><a href="module-DatabaseService-DatabaseService.html">DatabaseService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Alert">Alert</a></li><li><a href="global.html#AuthButton">AuthButton</a></li><li><a href="global.html#CampGroupCard">CampGroupCard</a></li><li><a href="global.html#CampGroupsView">CampGroupsView</a></li><li><a href="global.html#ConfirmModal">ConfirmModal</a></li><li><a href="global.html#DEMO_CACHE_DATA">DEMO_CACHE_DATA</a></li><li><a href="global.html#GroupNamesEditModal">GroupNamesEditModal</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#REQUIRED_VIKING_SECTION_MOVERS_FIELDS">REQUIRED_VIKING_SECTION_MOVERS_FIELDS</a></li><li><a href="global.html#SectionFilter">SectionFilter</a></li><li><a href="global.html#_generateProductionFormatAttendance">_generateProductionFormatAttendance</a></li><li><a href="global.html#assignMemberToCampGroupDemo">assignMemberToCampGroupDemo</a></li><li><a href="global.html#batchAssignMembers">batchAssignMembers</a></li><li><a href="global.html#buildEventCard">buildEventCard</a></li><li><a href="global.html#checkNetworkStatus">checkNetworkStatus</a></li><li><a href="global.html#clearFlexiRecordCaches">clearFlexiRecordCaches</a></li><li><a href="global.html#cn">cn</a></li><li><a href="global.html#convertSharedEventToAttendanceFormat">convertSharedEventToAttendanceFormat</a></li><li><a href="global.html#demoConfig">demoConfig</a></li><li><a href="global.html#expandSharedEvents">expandSharedEvents</a></li><li><a href="global.html#extractFlexiRecordContext">extractFlexiRecordContext</a></li><li><a href="global.html#fetchAllSectionEvents">fetchAllSectionEvents</a></li><li><a href="global.html#fetchEventAttendance">fetchEventAttendance</a></li><li><a href="global.html#fetchMostRecentTermId">fetchMostRecentTermId</a></li><li><a href="global.html#fetchSectionEvents">fetchSectionEvents</a></li><li><a href="global.html#filterEventsByDateRange">filterEventsByDateRange</a></li><li><a href="global.html#formatPhoneForCall">formatPhoneForCall</a></li><li><a href="global.html#generateDemoSharedAttendance">generateDemoSharedAttendance</a></li><li><a href="global.html#generateVikingSectionMoversErrorMessages">generateVikingSectionMoversErrorMessages</a></li><li><a href="global.html#getEventAttendance">getEventAttendance</a></li><li><a href="global.html#getEventSharingStatus">getEventSharingStatus</a></li><li><a href="global.html#getEventSummary">getEventSummary</a></li><li><a href="global.html#getEvents">getEvents</a></li><li><a href="global.html#getFlexiRecords">getFlexiRecords</a></li><li><a href="global.html#getFlexiStructure">getFlexiStructure</a></li><li><a href="global.html#getListOfMembers">getListOfMembers</a></li><li><a href="global.html#getMembersGrid">getMembersGrid</a></li><li><a href="global.html#getMostRecentTermId">getMostRecentTermId</a></li><li><a href="global.html#getSharedEventAttendance">getSharedEventAttendance</a></li><li><a href="global.html#getSingleFlexiRecord">getSingleFlexiRecord</a></li><li><a href="global.html#getStartupData">getStartupData</a></li><li><a href="global.html#getTerms">getTerms</a></li><li><a href="global.html#getUserAccessibleSections">getUserAccessibleSections</a></li><li><a href="global.html#getUserRoles">getUserRoles</a></li><li><a href="global.html#groupContactInfo">groupContactInfo</a></li><li><a href="global.html#groupEventsByName">groupEventsByName</a></li><li><a href="global.html#handleAPIResponseWithRateLimit">handleAPIResponseWithRateLimit</a></li><li><a href="global.html#handlePhoneCall">handlePhoneCall</a></li><li><a href="global.html#initializeDemoMode">initializeDemoMode</a></li><li><a href="global.html#isDemoMode">isDemoMode</a></li><li><a href="global.html#isSharedEventOwner">isSharedEventOwner</a></li><li><a href="global.html#isValidPhoneNumber">isValidPhoneNumber</a></li><li><a href="global.html#logRateLimitInfo">logRateLimitInfo</a></li><li><a href="global.html#mergeSharedAndSectionAttendance">mergeSharedAndSectionAttendance</a></li><li><a href="global.html#multiUpdateFlexiRecord">multiUpdateFlexiRecord</a></li><li><a href="global.html#organizeByCampGroups">organizeByCampGroups</a></li><li><a href="global.html#parseTimestamp">parseTimestamp</a></li><li><a href="global.html#quickValidateVikingSectionMovers">quickValidateVikingSectionMovers</a></li><li><a href="global.html#retrieveUserInfo">retrieveUserInfo</a></li><li><a href="global.html#safeCacheWithLogging">safeCacheWithLogging</a></li><li><a href="global.html#safeGetItem">safeGetItem</a></li><li><a href="global.html#safeGetSessionItem">safeGetSessionItem</a></li><li><a href="global.html#safeSetItem">safeSetItem</a></li><li><a href="global.html#safeSetSessionItem">safeSetSessionItem</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepWithAbort">sleepWithAbort</a></li><li><a href="global.html#testBackendConnection">testBackendConnection</a></li><li><a href="global.html#updateFlexiRecord">updateFlexiRecord</a></li><li><a href="global.html#useAttendanceData">useAttendanceData</a></li><li><a href="global.html#useSignInOut">useSignInOut</a></li><li><a href="global.html#validateMemberMove">validateMemberMove</a></li><li><a href="global.html#validateTokenBeforeAPICall">validateTokenBeforeAPICall</a></li><li><a href="global.html#validateVikingSectionMoversFlexiRecord">validateVikingSectionMoversFlexiRecord</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Sep 12 2025 15:24:48 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
