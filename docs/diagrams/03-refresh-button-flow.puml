@startuml Refresh Button Flow
!theme plain
title Refresh Button - Data Synchronization Flow

actor "Scout Leader" as User
participant "EventDashboard\nComponent" as Dashboard
participant "EventSync\nService" as SyncSvc
participant "OSM API" as OSM
database "SQLite/IndexedDB" as DB
database "localStorage" as LocalStore

== User Clicks Refresh Button ==
User -> Dashboard: Click refresh button
activate Dashboard
Dashboard -> Dashboard: Set loading state\nsetIsRefreshing(true)
Dashboard -> SyncSvc: doSync(forceRefresh=true)
activate SyncSvc

note right of SyncSvc: Only EventSyncService\nmakes API calls during refresh\nReference Data & Events use cache

== Step 1: Get Cached Events ==
SyncSvc -> DB: getEvents()
activate DB
DB --> SyncSvc: Cached events list
deactivate DB

note right of SyncSvc: No API call to re-fetch events\nUse existing cached event definitions

== Step 2: Sync Regular Attendance (Parallel) ==
note right of SyncSvc: Smart Rate Limit Queue handles\nall rate limiting automatically\n(100 req/min OSM limit)

SyncSvc -> SyncSvc: Fire all requests in parallel\nPromise.allSettled()

loop For each displayable event (last week to 3 months)
    SyncSvc -> OSM: getEventAttendance(section, event, term, token)\n[via Smart Rate Queue]
    activate OSM

    note right of OSM: Queue intelligently:\n- Manages request timing\n- Handles 429 responses\n- Exponential backoff\n- No manual delays needed

    OSM --> SyncSvc: Latest attendance data
    deactivate OSM

    SyncSvc -> DB: saveAttendance(eventId, attendance)
    activate DB
    DB --> SyncSvc: Updated
    deactivate DB
end

note right of SyncSvc: API call count: 5-20\n(only displayable events)\nOld events skipped for speed

== Step 3: Sync Shared Event Attendance ==
SyncSvc -> SyncSvc: syncSharedAttendance(events, token)

loop For each event
    SyncSvc -> LocalStore: Get viking_shared_metadata_${eventid}
    activate LocalStore
    LocalStore --> SyncSvc: Check if shared event
    deactivate LocalStore

    alt Is Shared Event (multi-section)
        note right of SyncSvc: Event like JOTI/Group Camp\nwith 8+ participating sections

        SyncSvc -> OSM: getSharedEventAttendance(eventId, section, token)
        activate OSM
        OSM --> SyncSvc: Shared attendance\nfrom all sections
        deactivate OSM

        SyncSvc -> LocalStore: Update cache\nviking_shared_attendance_${eventid}_${sectionid}_offline
        activate LocalStore
        LocalStore --> SyncSvc: Cached
        deactivate LocalStore

        note right of SyncSvc: API call count: +1-3\n(one per shared event)
    else Regular Event
        note right of SyncSvc: Skip - already synced\nin Step 2
    end
end

== Sync Complete ==
SyncSvc --> Dashboard: ✅ Sync complete\n{apiCallCount, successCount, errorCount}
deactivate SyncSvc

Dashboard -> Dashboard: setIsRefreshing(false)
Dashboard -> DB: Reload events from cache
activate DB
DB --> Dashboard: Updated events with fresh attendance
deactivate DB

Dashboard -> Dashboard: Re-render with new data
Dashboard --> User: Show updated attendance\n+ success notification

note right of User: Total API calls: 5-25\nDepends on: number of events\nand shared events present

== If Sync Fails ==
alt Network Error
    SyncSvc -> Dashboard: ❌ Sync failed (offline)
    Dashboard --> User: Show error notification\n"Unable to refresh - offline"
    Dashboard -> Dashboard: Continue showing cached data
else API Rate Limited
    SyncSvc -> Dashboard: ⚠️ Partial sync (rate limited)
    Dashboard --> User: Show warning\n"Some data may be stale"
else Auth Failed
    SyncSvc -> Dashboard: ❌ Auth error (401/403)
    Dashboard -> Dashboard: authHandler.handleAPIResponse()
    Dashboard --> User: Show "Session Expired" dialog
end

@enduml