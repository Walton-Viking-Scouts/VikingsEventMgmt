@startuml Initial Login Data Load
!theme plain
title Post-Authentication Data Loading - Three Service Architecture

actor "Scout Leader" as User
participant "Frontend" as Frontend
participant "Reference Data\nService" as RefData
participant "Events\nService" as EventsSvc
participant "EventSync\nService" as SyncSvc
participant "OSM API" as OSM
database "IndexedDB\n(Key-Value Store)" as Storage
database "IndexedDB\n(Structured Tables)" as TableDB

== After Successful OAuth Authentication ==
User -> Frontend: Login successful\n(token received)
activate Frontend
note right of Frontend: Token stored in sessionStorage

== Phase 1A: Load Core Reference Data (Before Events) ==
Frontend -> RefData: loadInitialReferenceData(token)
activate RefData
note right of RefData: Core static data loaded FIRST\nCached for entire session

RefData -> OSM: getTerms(token)
activate OSM
OSM --> RefData: Terms data
deactivate OSM
RefData -> Storage: Cache terms (viking_terms_offline)
activate Storage
Storage --> RefData: Cached
deactivate Storage
RefData -> TableDB: Store per-section term IDs\n(CURRENT_ACTIVE_TERMS table)
activate TableDB
TableDB --> RefData: Stored
deactivate TableDB

RefData -> OSM: getUserRoles(token)
activate OSM
OSM --> RefData: User roles (sections)
deactivate OSM
RefData -> Storage: Cache sections (viking_user_roles_offline)
activate Storage
Storage --> RefData: Cached
deactivate Storage

RefData -> OSM: getStartupData(token)
activate OSM
OSM --> RefData: Startup data (user info)
deactivate OSM
RefData -> Storage: Cache startup data (viking_startup_data_offline)
activate Storage
Storage --> RefData: Cached
deactivate Storage

RefData -> OSM: getListOfMembers(sections, token, forceRefresh=true)
activate OSM
note right of RefData: forceRefresh=true bypasses cache on login
OSM --> RefData: Members for all sections
deactivate OSM
RefData -> Storage: Save fresh members
activate Storage
Storage --> RefData: Cached
deactivate Storage

RefData --> Frontend: ✅ Core reference data loaded\n(4 API calls: terms, roles, startup, members)
deactivate RefData
note right of Frontend: FlexiRecords deferred to Phase 1B\nfor faster initial render

== Phase 2: Load Events (Moderately Dynamic - Cache Only) ==
Frontend -> EventsSvc: loadEventsForSections(sections, token)
activate EventsSvc
note right of EventsSvc: Event definitions change weekly\nNo API calls after initial load

loop For each section
    EventsSvc -> TableDB: getCurrentActiveTerm(section.sectionid)
    activate TableDB
    note right of EventsSvc: Use cached term IDs\nNo API call needed!
    TableDB --> EventsSvc: termId (from CURRENT_ACTIVE_TERMS)
    deactivate TableDB

    EventsSvc -> OSM: getEvents(section, termId, token)
    activate OSM
    OSM --> EventsSvc: Events list
    deactivate OSM

    EventsSvc -> Storage: saveEvents(sectionId, events)
    activate Storage
    Storage --> EventsSvc: Stored
    deactivate Storage
end

EventsSvc --> Frontend: ✅ Events loaded\n(~2-3 API calls - only getEvents per section)
deactivate EventsSvc
note right of Frontend: Events cached\nTerm IDs from cache = faster loading!

== Phase 3: Load Attendance (Highly Dynamic - Can Refresh) ==
Frontend -> SyncSvc: syncAllEventAttendance(token)
activate SyncSvc
note right of SyncSvc: Smart Rate Limit Queue handles all timing\nNo manual batching or delays

SyncSvc -> Storage: getEvents()
activate Storage
Storage --> SyncSvc: Cached events list
deactivate Storage

SyncSvc -> SyncSvc: Filter to displayable events\n(last week to 3 months from now)
note right of SyncSvc: Performance optimization:\nOnly sync events that will be displayed

loop For each displayable event (parallel)
    SyncSvc -> OSM: getEventAttendance(section, event, term, token)\n[via Smart Rate Queue]
    activate OSM
    note right of OSM: Queue handles:\n- Rate limiting (100 req/min)\n- 429 retry with backoff\n- Request timing
    OSM --> SyncSvc: Attendance data
    deactivate OSM

    SyncSvc -> Storage: saveAttendance(eventId, attendance)
    activate Storage
    Storage --> SyncSvc: Stored
    deactivate Storage
end

note right of SyncSvc: Sync shared attendance for all events
SyncSvc -> SyncSvc: syncSharedAttendance(displayableEvents, token)
loop For each displayable event
    SyncSvc -> OSM: getSharedEventAttendance(eventId, section, token)
    activate OSM
    note right of OSM: API checks if event is shared\nReturns data or error
    OSM --> SyncSvc: Shared attendance data (if shared)
    deactivate OSM

    SyncSvc -> Storage: Cache shared attendance\n(viking_shared_attendance_${eventid}_${sectionid}_offline)
    activate Storage
    Storage --> SyncSvc: Cached
    deactivate Storage
end

SyncSvc --> Frontend: ✅ Attendance synced\n(~5-20 API calls, only displayable events)
deactivate SyncSvc

== Phase 1B: Load FlexiRecords (After Attendance) ==
Frontend -> RefData: loadFlexiRecordData(sections, token)
activate RefData
note right of RefData: Deferred to end for faster initial render

RefData -> OSM: getFlexiRecords(section, token, forceRefresh=true)
activate OSM
OSM --> RefData: FlexiRecord lists
deactivate OSM
RefData -> OSM: getFlexiStructure(extraid, token)
activate OSM
OSM --> RefData: Viking FlexiRecord structures\n(Event Mgmt & Section Movers)
deactivate OSM
RefData -> Storage: Save fresh FlexiRecords
activate Storage
Storage --> RefData: Cached
deactivate Storage

RefData --> Frontend: ✅ FlexiRecords loaded
deactivate RefData

== All Data Loaded ==
Frontend --> User: Show dashboard with complete data
note right of User: Total API calls: 10-25\nOptimized flow:\n1. Core ref data (4 calls)\n2. Events (2-3 calls)\n3. Attendance (5-20 calls, displayable only)\n4. FlexiRecords (1-2 calls)

@enduml