@startuml Initial Login Data Load
!theme plain
title Post-Authentication Data Loading - Three Service Architecture

actor "Scout Leader" as User
participant "Frontend" as Frontend
participant "Reference Data\nService" as RefData
participant "Events\nService" as EventsSvc
participant "EventSync\nService" as SyncSvc
participant "OSM API" as OSM
database "IndexedDB\n(Key-Value Store)" as Storage
database "IndexedDB\n(Structured Tables)" as TableDB

== After Successful OAuth Authentication ==
User -> Frontend: Login successful\n(token received)
activate Frontend
note right of Frontend: Token stored in sessionStorage

== Phase 1: Load Reference Data (Static - Session Cache) ==
Frontend -> RefData: loadInitialReferenceData(token)
activate RefData
note right of RefData: Static data loaded ONCE at login\nCached for entire session

RefData -> OSM: getTerms(token)
activate OSM
OSM --> RefData: Terms data
deactivate OSM
RefData -> Storage: Cache terms (viking_terms_offline)
activate Storage
Storage --> RefData: Cached
deactivate Storage
RefData -> TableDB: Store per-section term IDs\n(CURRENT_ACTIVE_TERMS table)
activate TableDB
TableDB --> RefData: Stored
deactivate TableDB

RefData -> OSM: getUserRoles(token)
activate OSM
note right of RefData: No longer calls getStartupData() here\nUser info extracted by caller
OSM --> RefData: User roles (sections)
deactivate OSM
RefData -> Storage: Cache sections (viking_user_roles_offline)
activate Storage
Storage --> RefData: Cached
deactivate Storage

RefData -> OSM: getStartupData(token)
activate OSM
OSM --> RefData: Startup data (user info)
deactivate OSM
RefData -> Storage: Cache startup data (viking_startup_data_offline)
activate Storage
Storage --> RefData: Cached
deactivate Storage

RefData -> OSM: getListOfMembers(sections, token, forceRefresh=true)
activate OSM
note right of RefData: forceRefresh=true bypasses cache on login
OSM --> RefData: Members for all sections
deactivate OSM
alt forceRefresh=true
    note right of RefData: Login refresh - always fetch from API
    RefData -> Storage: Save fresh members
    activate Storage
    Storage --> RefData: Cached
    deactivate Storage
else forceRefresh=false (normal operation)
    note right of RefData: Check cache first, use if available
    RefData -> Storage: Try cache first
    activate Storage
    Storage --> RefData: Cached members (if available)
    deactivate Storage
end

RefData -> OSM: getFlexiRecords(section, token, forceRefresh=true)
activate OSM
note right of RefData: forceRefresh=true bypasses cache on login
OSM --> RefData: FlexiRecord lists
deactivate OSM
RefData -> OSM: getFlexiStructure(extraid, token)
activate OSM
OSM --> RefData: Viking FlexiRecord structures
deactivate OSM
alt forceRefresh=true
    note right of RefData: Login refresh - always fetch from API
    RefData -> Storage: Save fresh FlexiRecords
    activate Storage
    Storage --> RefData: Cached
    deactivate Storage
else forceRefresh=false (normal operation)
    note right of RefData: Check cache first, use if available
    RefData -> Storage: Try cache first
    activate Storage
    Storage --> RefData: Cached FlexiRecords (if available)
    deactivate Storage
end

RefData --> Frontend: ✅ Reference data loaded\n(4 API calls: terms, roles, startup, members/flexi)
deactivate RefData
note right of Frontend: Fresh data loaded on login\nCache bypassed via forceRefresh

== Phase 2: Load Events (Moderately Dynamic - Cache Only) ==
Frontend -> EventsSvc: loadEventsForSections(sections, token)
activate EventsSvc
note right of EventsSvc: Event definitions change weekly\nNo API calls after initial load

loop For each section
    EventsSvc -> TableDB: getCurrentActiveTerm(section.sectionid)
    activate TableDB
    note right of EventsSvc: Use cached term IDs\nNo API call needed!
    TableDB --> EventsSvc: termId (from CURRENT_ACTIVE_TERMS)
    deactivate TableDB

    EventsSvc -> OSM: getEvents(section, termId, token)
    activate OSM
    OSM --> EventsSvc: Events list
    deactivate OSM

    EventsSvc -> Storage: saveEvents(sectionId, events)
    activate Storage
    Storage --> EventsSvc: Stored
    deactivate Storage

    EventsSvc -> EventsSvc: detectAndStoreSharedEventsAcrossSections()
    EventsSvc -> Storage: Store shared metadata\n(viking_shared_metadata_${eventid})
    activate Storage
    Storage --> EventsSvc: Cached
    deactivate Storage
end

EventsSvc --> Frontend: ✅ Events loaded\n(~2-3 API calls - only getEvents per section)
deactivate EventsSvc
note right of Frontend: Events cached\nTerm IDs from cache = faster loading!

== Phase 3: Load Attendance (Highly Dynamic - Can Refresh) ==
Frontend -> SyncSvc: syncAllEventAttendance(token)
activate SyncSvc
note right of SyncSvc: ONLY service that refreshes during session

SyncSvc -> Storage: getEvents()
activate Storage
Storage --> SyncSvc: Cached events list
deactivate Storage

loop For each event (batched)
    SyncSvc -> OSM: getEventAttendance(section, event, term, token)
    activate OSM
    OSM --> SyncSvc: Attendance data
    deactivate OSM

    SyncSvc -> Storage: saveAttendance(eventId, attendance)
    activate Storage
    Storage --> SyncSvc: Stored
    deactivate Storage
end

note right of SyncSvc: Check for shared events
SyncSvc -> SyncSvc: syncSharedAttendance(events, token)
loop For each shared event
    SyncSvc -> Storage: Get viking_shared_metadata_${eventid}
    activate Storage
    Storage --> SyncSvc: Shared metadata
    deactivate Storage

    alt Is Shared Event
        SyncSvc -> OSM: getSharedEventAttendance(eventId, section, token)
        activate OSM
        OSM --> SyncSvc: Shared attendance data
        deactivate OSM

        SyncSvc -> Storage: Cache shared attendance\n(viking_shared_attendance_${eventid}_${sectionid}_offline)
        activate Storage
        Storage --> SyncSvc: Cached
        deactivate Storage
    end
end

SyncSvc --> Frontend: ✅ Attendance synced\n(~5-20 API calls depending on events)
deactivate SyncSvc

== All Data Loaded ==
Frontend --> User: Show dashboard with data
note right of User: Total API calls: 10-25\n(reduced from 12-31!)\nAll data now cached in IndexedDB

@enduml