---
phase: 05-terms-normalization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/shared/services/storage/database.js
  - src/shared/services/storage/schemas/sqliteSchema.js
  - src/shared/services/api/terms.js
autonomous: true

must_haves:
  truths:
    - "DatabaseService.saveTerms validates with Zod and writes to normalized IndexedDB or SQLite"
    - "DatabaseService.getTerms returns terms for a section from normalized store"
    - "SQLite terms table exists with termid primary key and indexes on sectionid and startdate"
    - "API getTerms() stores full terms to normalized store for offline access"
    - "getCurrentActiveTerm and setCurrentActiveTerm delegate to CurrentActiveTermsService"
  artifacts:
    - path: "src/shared/services/storage/database.js"
      provides: "saveTerms, getTerms, getAllTerms, getTermById, getCurrentActiveTerm, setCurrentActiveTerm implementations"
      contains: "bulkReplaceTermsForSection"
    - path: "src/shared/services/storage/schemas/sqliteSchema.js"
      provides: "SQL for terms table and indexes"
      contains: "CREATE TABLE IF NOT EXISTS terms"
    - path: "src/shared/services/api/terms.js"
      provides: "Normalized store writes during API sync"
      contains: "DatabaseService"
  key_links:
    - from: "database.js saveTerms"
      to: "IndexedDBService.bulkReplaceTermsForSection"
      via: "Zod validation then direct IndexedDB call"
      pattern: "bulkReplaceTermsForSection"
    - from: "database.js saveTerms"
      to: "SQLite terms table"
      via: "DELETE + INSERT in transaction"
      pattern: "DELETE FROM terms WHERE sectionid"
    - from: "terms.js getTerms"
      to: "DatabaseService.saveTerms"
      via: "iterate API response sections and save each"
      pattern: "saveTerms"
---

<objective>
Implement DatabaseService terms methods, add SQLite terms table, and update API layer to store terms in the normalized store.

Purpose: Connects the IndexedDB CRUD layer (Plan 01) to the application through DatabaseService facade and ensures terms are persisted for offline access when synced from API.
Output: Working saveTerms/getTerms on both platforms, SQLite terms table, and API-driven offline term storage.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-terms-normalization/05-RESEARCH.md
@.planning/phases/05-terms-normalization/05-01-SUMMARY.md
@src/shared/services/storage/database.js
@src/shared/services/storage/schemas/sqliteSchema.js
@src/shared/services/api/terms.js
@src/shared/services/storage/currentActiveTermsService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite terms table and DatabaseService implementation</name>
  <files>
    src/shared/services/storage/schemas/sqliteSchema.js
    src/shared/services/storage/database.js
  </files>
  <action>
**sqliteSchema.js:** Add a terms table definition following the pattern of existing table definitions:
```sql
CREATE TABLE IF NOT EXISTS terms (
  termid TEXT PRIMARY KEY,
  sectionid INTEGER,
  name TEXT NOT NULL,
  startdate TEXT,
  enddate TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS idx_terms_sectionid ON terms(sectionid);
CREATE INDEX IF NOT EXISTS idx_terms_startdate ON terms(startdate);
```
Export the SQL string and add it to the table creation array used by database.js createTables().

**database.js:** Replace the four Phase 5 stub methods (lines ~1722-1764) with real implementations. Add TermSchema to the existing schema import line from validation.js.

**saveTerms(sectionId, terms):**
- Enrich each term with sectionid: `terms.map(t => ({ ...t, sectionid: sectionId }))`
- Validate with `safeParseArray(TermSchema, enrichedTerms)` -- log warnings for validation errors (same pattern as saveAttendance)
- Web path: call `IndexedDBService.bulkReplaceTermsForSection(sectionId, validTerms)`
- Native path: BEGIN TRANSACTION, DELETE FROM terms WHERE sectionid = ?, INSERT each term, COMMIT (ROLLBACK on error)
- Call `this.updateSyncStatus('terms')` after native write

**getTerms(sectionId):**
- Web: return `IndexedDBService.getTermsBySection(sectionId)`
- Native: `SELECT * FROM terms WHERE sectionid = ? ORDER BY startdate DESC`, return result.values or []

**getAllTerms():**
- Web: return `IndexedDBService.getAllTerms()`
- Native: `SELECT * FROM terms ORDER BY sectionid, startdate DESC`, return result.values or []

**getTermById(termId):**
- Web: return `IndexedDBService.getTermById(termId)`
- Native: `SELECT * FROM terms WHERE termid = ?`, return first result or null

**getCurrentActiveTerm(sectionId):**
- Import CurrentActiveTermsService at top of file
- Delegate: `return CurrentActiveTermsService.getCurrentActiveTerm(sectionId)`

**setCurrentActiveTerm(sectionId, term):**
- Delegate: `return CurrentActiveTermsService.setCurrentActiveTerm(sectionId, term)`

Add JSDoc to all methods. Do NOT add inline comments. Wrap all methods in try/catch with logger.error + sentryUtils.captureException, matching existing patterns.
  </action>
  <verify>
Grep database.js for "Phase 5" or "not yet implemented" -- must return zero matches. Grep for `bulkReplaceTermsForSection` -- must exist in saveTerms. Run `npm run lint` and `npm run test:run`.
  </verify>
  <done>All six DatabaseService terms methods implemented. SQLite terms table defined with indexes. No Phase 5 stubs remain. getCurrentActiveTerm/setCurrentActiveTerm delegate to CurrentActiveTermsService.</done>
</task>

<task type="auto">
  <name>Task 2: API terms.js stores to normalized terms store</name>
  <files>
    src/shared/services/api/terms.js
  </files>
  <action>
The `getTerms()` function in terms.js fetches terms from the API and currently only calls `calculateAndStoreCurrentTerms()` to populate `current_active_terms`. It needs to ALSO store the full terms to the normalized store for offline access.

After the API response is received and before/after `calculateAndStoreCurrentTerms()` is called, add a loop that stores terms to the normalized store:

```javascript
const databaseService = DatabaseService.getInstance();
for (const [sectionId, sectionTerms] of Object.entries(termsData)) {
  await databaseService.saveTerms(sectionId, sectionTerms);
}
```

Import DatabaseService at the top of the file if not already imported. The `calculateAndStoreCurrentTerms()` call must remain unchanged -- it independently writes to `current_active_terms` and is not affected by this addition.

Do NOT modify `calculateAndStoreCurrentTerms()` or any CurrentActiveTermsService calls. Those flows work correctly and are NOT part of Phase 5 normalization.

Add JSDoc to the new storage block. Do NOT add inline comments.
  </action>
  <verify>
Grep terms.js for `saveTerms` -- must exist. Grep for `DatabaseService` -- must be imported and used. Verify `calculateAndStoreCurrentTerms` is still called (not removed). Run `npm run lint` and `npm run test:run`.
  </verify>
  <done>API getTerms() now stores full terms data to normalized store via DatabaseService.saveTerms() for each section. calculateAndStoreCurrentTerms() remains unchanged for current_active_terms population.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes
2. `npm run test:run` passes
3. No "Phase 5" or "not yet implemented" stubs remain in database.js
4. SQLite terms table SQL defined in sqliteSchema.js
5. terms.js calls DatabaseService.saveTerms() for each section in API response
6. getCurrentActiveTerm/setCurrentActiveTerm delegate to CurrentActiveTermsService
</verification>

<success_criteria>
DatabaseService provides complete terms CRUD on both platforms. API sync stores terms to normalized store for offline access. CurrentActiveTermsService integration is preserved through delegation.
</success_criteria>

<output>
After completion, create `.planning/phases/05-terms-normalization/05-02-SUMMARY.md`
</output>
