---
phase: 04-attendance-normalization
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/shared/services/storage/database.js
  - src/shared/services/storage/__tests__/attendanceNormalization.test.js
autonomous: true

must_haves:
  truths:
    - "DatabaseService.saveAttendance validates with Zod and writes to normalized IndexedDB store (web) or SQLite with transaction (native)"
    - "DatabaseService.getAttendance returns attendance records from normalized store, not USS blobs"
    - "DatabaseService.saveSharedEventMetadata and getSharedEventMetadata work on both platforms"
    - "Unknown fields in attendance records are logged to Sentry as warnings"
    - "Integration tests verify compound key storage, per-event replacement, and query methods"
  artifacts:
    - path: "src/shared/services/storage/database.js"
      provides: "saveAttendance, getAttendance, saveSharedAttendance, saveSharedEventMetadata, getSharedEventMetadata with Zod validation"
    - path: "src/shared/services/storage/__tests__/attendanceNormalization.test.js"
      provides: "Integration tests for attendance normalization"
  key_links:
    - from: "src/shared/services/storage/database.js"
      to: "IndexedDBService.bulkReplaceAttendanceForEvent"
      via: "saveAttendance web path"
      pattern: "bulkReplaceAttendanceForEvent"
    - from: "src/shared/services/storage/database.js"
      to: "AttendanceSchema"
      via: "Zod validation at write boundary"
      pattern: "safeParseArray.*AttendanceSchema"
---

<objective>
Wire DatabaseService attendance methods to the normalized IndexedDB store with Zod validation at the write boundary, add SQLite transaction wrapping for native, and create integration tests for attendance normalization.

Purpose: DatabaseService is the public API for all storage consumers. This plan connects it to the IndexedDB CRUD methods from Plan 01, adds Zod validation + unknown field logging, and verifies correctness with integration tests.

Output: Working DatabaseService attendance methods on both platforms, 6+ integration tests.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-attendance-normalization/04-RESEARCH.md
@.planning/phases/04-attendance-normalization/04-01-SUMMARY.md
@.planning/phases/03-events-normalization/03-02-SUMMARY.md

@src/shared/services/storage/database.js
@src/shared/services/storage/__tests__/eventNormalization.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DatabaseService attendance and shared event metadata methods</name>
  <files>
    src/shared/services/storage/database.js
  </files>
  <action>
**Import updates:**
Add `AttendanceSchema` and `SharedEventMetadataSchema` to the existing schema import line (alongside SectionSchema, EventSchema).

**Replace saveAttendance method** (currently uses UnifiedStorageService blob writes):

Web (IndexedDB) path:
1. Validate with `safeParseArray(AttendanceSchema, attendanceData)` -- log validation errors as warnings
2. Log unknown fields to Sentry: compare each validated record's keys against known set `['scoutid', 'eventid', 'sectionid', 'attending', 'patrol', 'notes', 'isSharedSection', 'updated_at']`. If unknown keys found, call `sentryUtils.captureMessage('Attendance record has unknown fields', { level: 'warning', extra: { unknownKeys, eventid } })` -- log once per batch (break after first match)
3. Call `IndexedDBService.bulkReplaceAttendanceForEvent(eventId, validRecords)`
4. Return (no USS write)

Native (SQLite) path:
1. Validate with Zod same as web
2. BEGIN TRANSACTION
3. DELETE FROM attendance WHERE eventid = ? (scoped to event)
4. INSERT each record: eventid, scoutid, sectionid, attending, patrol, notes, isSharedSection (add isSharedSection column if missing -- use INTEGER 0/1)
5. COMMIT (ROLLBACK on error)
6. updateSyncStatus('attendance')

**Replace getAttendance method:**

Web path: `return IndexedDBService.getAttendanceByEvent(String(eventId))` -- no USS read, no demo mode filtering needed for attendance (attendance is per-event, already scoped).

Native path: `SELECT * FROM attendance WHERE eventid = ? ORDER BY scoutid` with result.values fallback to [].

**Add/replace saveSharedAttendance method** (replaces stub from Phase 1):

Same as saveAttendance but records should have `isSharedSection: true` marker added before validation. Uses the same `bulkReplaceAttendanceForEvent` -- but with a twist: only delete records WHERE isSharedSection is true for the event.

For web path, implement a separate cursor-based delete that filters by isSharedSection:
- Open readwrite tx on attendance store
- Open cursor on eventid index for the eventId
- Delete only records where `cursor.value.isSharedSection === true`
- Then put all new shared records
- await tx.done

For native path: `DELETE FROM attendance WHERE eventid = ? AND isSharedSection = 1` then INSERT shared records.

**Add/replace saveSharedEventMetadata method** (replaces stub from Phase 1):

Web path: Validate with `SharedEventMetadataSchema`, call `IndexedDBService.saveSharedEventMetadata(validMetadata)`.
Native path: `INSERT OR REPLACE INTO shared_event_metadata (eventid, is_shared_event, owner_section_id, sections, updated_at) VALUES (?, ?, ?, ?, ?)` where sections is JSON.stringify(metadata.sections).

**Add/replace getSharedEventMetadata method** (replaces stub from Phase 1):

Web path: `return IndexedDBService.getSharedEventMetadata(String(eventId))`
Native path: `SELECT * FROM shared_event_metadata WHERE eventid = ?` with JSON.parse on the sections column.

**Add getAttendanceByScout method:**

Web path: `return IndexedDBService.getAttendanceByScout(Number(scoutId))`
Native path: `SELECT * FROM attendance WHERE scoutid = ? ORDER BY eventid` with result.values fallback.

**SQLite schema update -- add isSharedSection column:**
In the createTables method or the attendance table CREATE statement, ensure the attendance table has an `isSharedSection` INTEGER column (default 0). If the table already exists without it, add an ALTER TABLE statement in the initialization path, or recreate the table. Follow the pattern from Phase 1's SQLite table creation.

Also ensure the `shared_event_metadata` table is created in createTables (from sqliteSchema.js).
  </action>
  <verify>
Run `npm run lint` from the project directory. No new lint errors. Verify saveAttendance no longer references UnifiedStorageService. Verify getAttendance reads from IndexedDBService.getAttendanceByEvent. Verify saveSharedAttendance handles the isSharedSection marker. Verify saveSharedEventMetadata and getSharedEventMetadata work on both paths.
  </verify>
  <done>
DatabaseService attendance methods bypass UnifiedStorageService entirely. saveAttendance validates with Zod at write boundary and writes to normalized IndexedDB (web) or SQLite with transaction wrapping (native). Shared attendance uses same store with isSharedSection marker. Shared event metadata stored in dedicated store. Unknown fields logged to Sentry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for attendance normalization</name>
  <files>
    src/shared/services/storage/__tests__/attendanceNormalization.test.js
  </files>
  <action>
Create a new test file following the exact pattern from `eventNormalization.test.js`:

**Setup:** Import from `idb`, `fake-indexeddb`, vitest globals. Set up IndexedDB with v6 schema (attendance store with compound keyPath ['eventid', 'scoutid'] and indexes, shared_event_metadata store). Mock logger and sentryUtils.

**Test cases (6-8 tests):**

1. **"stores and retrieves attendance by event"** -- bulkReplaceAttendanceForEvent with 3 records, getAttendanceByEvent returns all 3 with correct fields.

2. **"retrieves attendance by scout across events"** -- Store attendance for scout 100 across events A and B. getAttendanceByScout(100) returns both records.

3. **"retrieves single attendance record by compound key"** -- Store a record, getAttendanceRecord(eventId, scoutId) returns it. getAttendanceRecord with wrong scoutId returns null.

4. **"per-event atomic replacement preserves other events"** -- Store attendance for event A and event B. bulkReplaceAttendanceForEvent for event A with new data. Verify event A has new data, event B is unchanged.

5. **"shared and regular attendance coexist in same store"** -- Store regular records (no isSharedSection) and shared records (isSharedSection: true) for same event. getAttendanceByEvent returns both types.

6. **"shared event metadata CRUD"** -- saveSharedEventMetadata with sections array, getSharedEventMetadata returns it. getAllSharedEventMetadata returns all saved metadata.

7. **"compound key type coercion"** -- Store record with eventid as number and scoutid as string in raw put. Verify getAttendanceRecord with String(eventid) and Number(scoutid) retrieves correctly. This tests that the Zod coercion prevents type mismatches.

8. **"attending value normalization"** -- Validate records through AttendanceSchema with mixed attending values ("yes", "1", "No", "invited", "Shown"). Verify normalized output values.

Follow the same describe/it structure and beforeEach/afterEach cleanup pattern from eventNormalization.test.js.
  </action>
  <verify>
Run `npm run test:run -- --reporter=verbose src/shared/services/storage/__tests__/attendanceNormalization.test.js` and verify all tests pass.
  </verify>
  <done>
Integration test suite verifies: compound key storage and retrieval, per-event atomic replacement, scout-based queries, shared/regular coexistence, shared event metadata CRUD, type coercion correctness, and attending value normalization. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with no new errors
2. `npm run test:run -- src/shared/services/storage/__tests__/attendanceNormalization.test.js` -- all tests pass
3. DatabaseService.saveAttendance uses Zod validation + IndexedDBService.bulkReplaceAttendanceForEvent (no USS)
4. DatabaseService.getAttendance uses IndexedDBService.getAttendanceByEvent (no USS)
5. Shared attendance uses isSharedSection marker in unified store
6. Shared event metadata has separate CRUD methods
7. Unknown fields logged to Sentry
</verification>

<success_criteria>
DatabaseService attendance methods work end-to-end on both platforms using normalized stores. Integration tests prove compound key operations, per-event replacement atomicity, and shared attendance coexistence.
</success_criteria>

<output>
After completion, create `.planning/phases/04-attendance-normalization/04-02-SUMMARY.md`
</output>
