---
phase: 01-infrastructure-schema
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/shared/services/storage/indexedDBService.js
  - src/shared/services/storage/database.js
autonomous: true

must_haves:
  truths:
    - "App opens on web with DATABASE_VERSION 5 and all existing stores still work"
    - "SQLite createTables() creates 3 new flexi tables and 6 new indexes on native platforms"
    - "DatabaseService exposes method stubs for terms, flexi, and shared attendance that throw descriptive errors indicating which phase implements them"
    - "All existing database.js methods that catch errors report to Sentry with structured tags and contexts (matching indexedDBService.js pattern)"
    - "Demo mode database gets the same version 5 schema automatically (verified by design, no code change needed)"
  artifacts:
    - path: "src/shared/services/storage/indexedDBService.js"
      provides: "DATABASE_VERSION 5 with upgrade guard structure"
      contains: "DATABASE_VERSION = 5"
    - path: "src/shared/services/storage/database.js"
      provides: "Flexi SQLite tables, method stubs, Sentry error handling"
      contains: "flexi_lists"
  key_links:
    - from: "src/shared/services/storage/database.js"
      to: "src/shared/services/utils/sentry.js"
      via: "import sentryUtils"
      pattern: "sentryUtils\\.captureException"
    - from: "src/shared/services/storage/database.js"
      to: "src/shared/services/storage/schemas/sqliteSchema.js"
      via: "import SQLITE_SCHEMAS"
      pattern: "import.*SQLITE_SCHEMAS"
---

<objective>
Bump IndexedDB to DATABASE_VERSION 5, add SQLite flexi tables and indexes, add DatabaseService method stubs for all normalized data types, and make database.js error handling consistent with Sentry reporting.

Purpose: Complete the infrastructure layer so that subsequent phases (2-6) have the version upgrade guard structure, SQLite tables, facade methods, and error handling patterns already in place. Each phase then fills in the implementation without touching infrastructure.

Output: Modified indexedDBService.js (version bump) and database.js (SQLite tables, method stubs, Sentry).
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-schema/01-RESEARCH.md
@.planning/phases/01-infrastructure-schema/01-01-SUMMARY.md
@src/shared/services/storage/indexedDBService.js
@src/shared/services/storage/database.js
@src/shared/services/utils/sentry.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bump IndexedDB to VERSION 5 and add SQLite flexi tables with indexes</name>
  <files>
    src/shared/services/storage/indexedDBService.js
    src/shared/services/storage/database.js
  </files>
  <action>
**IndexedDB (indexedDBService.js):**

1. Change `const DATABASE_VERSION = 4;` to `const DATABASE_VERSION = 5;` on line 7.

2. Inside the `upgrade()` callback, AFTER all the existing `if (!db.objectStoreNames.contains(...))` blocks and BEFORE the final `logger.info('IndexedDB upgrade completed', ...)`, add a version 5 upgrade guard:

```js
if (oldVersion < 5) {
  logger.info('IndexedDB v5 upgrade: schema infrastructure for data normalization', {
    dbName,
  }, LOG_CATEGORIES.DATABASE);
}
```

This guard is intentionally a no-op in Phase 1. Phases 2-6 will add store deletion/recreation logic inside this block. The critical change is the version bump itself -- this triggers the upgrade callback on existing databases, confirming the mechanism works. All existing stores are preserved because they use `if (!db.objectStoreNames.contains(...))` guards which skip creation when stores already exist.

Do NOT delete or recreate any existing stores. Do NOT change any existing store definitions. The version bump alone validates that the upgrade mechanism works end-to-end.

**SQLite (database.js):**

1. Add import at top of database.js:
```js
import { SQLITE_SCHEMAS, SQLITE_INDEXES } from './schemas/sqliteSchema.js';
```

2. In the `createTables()` method, AFTER the existing `await this.db.execute(createSyncMetadataTable);` line, add execution of the 3 flexi table CREATE statements and 6 index CREATE statements:

```js
await this.db.execute(SQLITE_SCHEMAS.flexi_lists);
await this.db.execute(SQLITE_SCHEMAS.flexi_structure);
await this.db.execute(SQLITE_SCHEMAS.flexi_data);

for (const indexSql of SQLITE_INDEXES) {
  await this.db.execute(indexSql);
}
```

This uses the constants defined in Plan 01's sqliteSchema.js. The `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS` are idempotent -- safe to run on both fresh and existing databases.
  </action>
  <verify>
Run `npm run test:run` -- all existing tests must pass (the version bump should not break tests since fake-indexeddb handles upgrades).
Run `npm run lint` -- no lint errors.
Run `npm run build` -- build must succeed.
  </verify>
  <done>
DATABASE_VERSION is 5 in indexedDBService.js. The upgrade callback has an `if (oldVersion < 5)` guard block ready for subsequent phases. database.js createTables() creates 3 flexi tables and 6 indexes using the schema constants from Plan 01. Existing stores and tables are unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DatabaseService method stubs and Sentry error handling</name>
  <files>
    src/shared/services/storage/database.js
  </files>
  <action>
**Part A: Add Sentry error handling to database.js**

1. Add import at top of database.js (after the existing imports):
```js
import { sentryUtils } from '../utils/sentry.js';
import logger, { LOG_CATEGORIES } from '../utils/logger.js';
```

2. Replace ALL `console.error(...)` calls in database.js with the Sentry pattern from indexedDBService.js. The existing methods that need this treatment are: `initialize()`, `saveMembers()` (the catch block around line 950 with `console.error('Failed to save members to dual-store:', ...)`). For each `console.error`:

Replace with:
```js
logger.error('DatabaseService {operationName} failed', {
  // relevant context params
  error: error.message,
  stack: error.stack,
}, LOG_CATEGORIES.ERROR);

sentryUtils.captureException(error, {
  tags: {
    operation: 'database_{operation_name}',
    platform: this.isNative ? 'sqlite' : 'web',
  },
  contexts: {
    database: {
      operation: '{operationName}',
      // relevant params
    },
  },
});
```

Also replace `console.log('Running in browser...')` in initialize() and `console.log('Database initialized successfully')` with appropriate `logger.info(...)` calls using `LOG_CATEGORIES.DATABASE`.

Also replace `console.warn('getMembers called with invalid sectionIds:', ...)` with `logger.warn(...)` using `LOG_CATEGORIES.DATABASE`.

Also replace `console.warn('Failed to fetch members from dual-store:', ...)` and `console.warn('Orphaned member_section record...', ...)` with `logger.warn(...)` calls.

**Part B: Add method stubs for all normalized data types**

Add these method stubs to the DatabaseService class, BEFORE the `close()` method. Each stub follows the exact same pattern: `await this.initialize()` then throw a descriptive error indicating which phase implements it. Group methods by data type with JSDoc.

**Terms (Phase 5):**
- `async getTerms(sectionId)` — stub throws `'Terms retrieval via normalized storage not yet implemented (Phase 5)'`
- `async saveTerms(sectionId, terms)` — stub throws `'Terms storage via normalized storage not yet implemented (Phase 5)'`
- `async getCurrentActiveTerm(sectionId)` — stub throws `'Current active term retrieval via normalized storage not yet implemented (Phase 5)'`
- `async setCurrentActiveTerm(sectionId, term)` — stub throws `'Current active term storage via normalized storage not yet implemented (Phase 5)'`

**Flexi Records (Phase 6):**
- `async getFlexiLists(sectionId)` — stub throws `'FlexiLists retrieval via normalized storage not yet implemented (Phase 6)'`
- `async saveFlexiLists(sectionId, lists)` — stub throws `'FlexiLists storage via normalized storage not yet implemented (Phase 6)'`
- `async getFlexiStructure(recordId)` — stub throws `'FlexiStructure retrieval via normalized storage not yet implemented (Phase 6)'`
- `async saveFlexiStructure(recordId, structure)` — stub throws `'FlexiStructure storage via normalized storage not yet implemented (Phase 6)'`
- `async getFlexiData(recordId, sectionId, termId)` — stub throws `'FlexiData retrieval via normalized storage not yet implemented (Phase 6)'`
- `async saveFlexiData(recordId, sectionId, termId, data)` — stub throws `'FlexiData storage via normalized storage not yet implemented (Phase 6)'`

**Shared Attendance (Phase 4):**
- `async getSharedAttendance(eventId)` — stub throws `'SharedAttendance retrieval via normalized storage not yet implemented (Phase 4)'`
- `async saveSharedAttendance(eventId, data)` — stub throws `'SharedAttendance storage via normalized storage not yet implemented (Phase 4)'`

Each stub pattern:
```js
/**
 * [JSDoc description]
 * @async
 * @param {type} paramName - Description
 * @returns {Promise<type>} Description
 * @throws {Error} Not yet implemented - Phase N
 */
async methodName(params) {
  await this.initialize();
  throw new Error('MethodName via normalized storage not yet implemented (Phase N)');
}
```

Do NOT add platform branching (isNative checks) in stubs -- that complexity is deferred to the implementing phase. A single `throw new Error(...)` after initialize is sufficient.

Add JSDoc to every new method. Do NOT add inline comments.
  </action>
  <verify>
Run `npm run lint` -- no lint errors in database.js.
Run `npm run test:run` -- all existing tests pass.
Run `npm run build` -- build succeeds.
Verify no `console.error` or `console.log` calls remain in database.js (all replaced with logger/sentryUtils): `grep -n 'console\.' src/shared/services/storage/database.js` should return zero results.
  </verify>
  <done>
DatabaseService has 12 new method stubs covering terms (4), flexi (6), and shared attendance (2). All throw descriptive errors referencing the implementing phase. All console.error/console.log/console.warn calls in database.js are replaced with logger + sentryUtils following the indexedDBService.js pattern. Sentry captures include operation tags and platform context.
  </done>
</task>

</tasks>

<verification>
1. `npm run test:run` -- all tests pass (critical: IndexedDB tests with fake-indexeddb handle VERSION 5 upgrade)
2. `npm run lint` -- no lint errors
3. `npm run build` -- production build succeeds
4. `grep 'DATABASE_VERSION = 5' src/shared/services/storage/indexedDBService.js` -- confirms version bump
5. `grep 'console\.\(error\|log\|warn\)' src/shared/services/storage/database.js` -- returns no matches (all replaced)
6. `grep 'sentryUtils.captureException' src/shared/services/storage/database.js` -- confirms Sentry integration
7. `grep 'not yet implemented' src/shared/services/storage/database.js` -- shows all 12 method stubs present
</verification>

<success_criteria>
- DATABASE_VERSION is 5 with oldVersion < 5 guard block in upgrade callback
- SQLite createTables() creates flexi_lists, flexi_structure, flexi_data tables and 6 indexes
- 12 DatabaseService method stubs exist (terms: 4, flexi: 6, shared attendance: 2) that throw descriptive errors
- All console.error/log/warn in database.js replaced with logger + sentryUtils
- All lint, tests, and build pass
- Demo mode parity confirmed by design (same DATABASE_VERSION + upgrade callback used for both database names)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-schema/01-02-SUMMARY.md`
</output>
