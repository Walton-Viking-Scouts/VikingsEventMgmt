---
phase: 01-infrastructure-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/shared/services/storage/schemas/validation.js
  - src/shared/services/storage/schemas/indexedDBSchema.js
  - src/shared/services/storage/schemas/sqliteSchema.js
autonomous: true

must_haves:
  truths:
    - "Zod is installed and importable"
    - "Every data type (Section, Event, Attendance, Term, FlexiList, FlexiStructure, FlexiData, SharedAttendance) has a Zod schema that validates correct input and rejects malformed input with descriptive errors"
    - "Schema constant files document the target IndexedDB store definitions and SQLite CREATE TABLE statements for all normalized data types"
  artifacts:
    - path: "src/shared/services/storage/schemas/validation.js"
      provides: "Zod schemas for all data types with safeParseArray utility"
      exports: ["SectionSchema", "EventSchema", "AttendanceSchema", "TermSchema", "FlexiListSchema", "FlexiStructureSchema", "FlexiDataSchema", "SharedAttendanceSchema", "safeParseArray"]
    - path: "src/shared/services/storage/schemas/indexedDBSchema.js"
      provides: "IndexedDB store definitions with target keyPaths and indexes"
      exports: ["NORMALIZED_STORES"]
    - path: "src/shared/services/storage/schemas/sqliteSchema.js"
      provides: "SQLite CREATE TABLE statements for all normalized tables"
      exports: ["SQLITE_SCHEMAS"]
  key_links:
    - from: "src/shared/services/storage/schemas/validation.js"
      to: "zod"
      via: "import { z } from 'zod'"
      pattern: "import.*from.*zod"
---

<objective>
Install Zod and create all schema definition files for the data storage normalization project.

Purpose: Establish the validation layer and schema documentation that all subsequent normalization phases depend on. Zod schemas validate API data at the storage boundary. Schema constant files document the target IndexedDB/SQLite schemas for reference during implementation.

Output: Three new files in `src/shared/services/storage/schemas/` plus Zod as a production dependency.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-schema/01-RESEARCH.md
@src/shared/services/storage/indexedDBService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod and create validation schemas</name>
  <files>
    package.json
    src/shared/services/storage/schemas/validation.js
  </files>
  <action>
1. Install Zod: `npm install zod` (adds to package.json dependencies). Use Zod v3 (the default `zod` package).

2. Create directory `src/shared/services/storage/schemas/`.

3. Create `src/shared/services/storage/schemas/validation.js` with these Zod schemas. Use `import { z } from 'zod'` (ES module).

**SectionSchema:**
```js
z.object({
  sectionid: z.union([z.string(), z.number()]).transform(Number),
  sectionname: z.string().min(1),
  sectiontype: z.string().optional(),
  section: z.string().optional(),
  isDefault: z.boolean().optional(),
  permissions: z.record(z.number()).optional(),
})
```

**EventSchema:**
```js
z.object({
  eventid: z.union([z.string(), z.number()]).transform(String),
  name: z.string().min(1),
  sectionid: z.union([z.string(), z.number()]).transform(Number),
  termid: z.string().nullable().optional(),
  startdate: z.string().nullable().optional(),
  startdate_g: z.string().nullable().optional(),
  enddate: z.string().nullable().optional(),
  enddate_g: z.string().nullable().optional(),
  location: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
  cost: z.string().nullable().optional(),
  date: z.string().nullable().optional(),
})
```

**AttendanceSchema:**
```js
z.object({
  scoutid: z.union([z.string(), z.number()]).transform(Number),
  eventid: z.union([z.string(), z.number()]).transform(String),
  firstname: z.string().nullable().optional(),
  lastname: z.string().nullable().optional(),
  attending: z.string().nullable().optional(),
  patrol: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
})
```

**SharedAttendanceSchema:**
```js
z.object({
  eventid: z.union([z.string(), z.number()]).transform(String),
  sectionid: z.union([z.string(), z.number()]).transform(Number),
  firstname: z.string().nullable().optional(),
  lastname: z.string().nullable().optional(),
  attending: z.string().nullable().optional(),
  patrol: z.string().nullable().optional(),
  scoutid: z.union([z.string(), z.number()]).transform(Number).optional(),
})
```

**TermSchema:**
```js
z.object({
  termid: z.union([z.string(), z.number()]).transform(String),
  name: z.string().min(1),
  sectionid: z.union([z.string(), z.number()]).optional(),
  startdate: z.string().nullable().optional(),
  enddate: z.string().nullable().optional(),
})
```

**FlexiListSchema:**
```js
z.object({
  extraid: z.union([z.string(), z.number()]).transform(String),
  name: z.string(),
  sectionid: z.union([z.string(), z.number()]).transform(Number).optional(),
})
```

**FlexiStructureSchema:**
```js
z.object({
  extraid: z.union([z.string(), z.number()]).transform(String),
  name: z.string().optional(),
  config: z.string().optional(),
  structure: z.array(z.any()).optional(),
})
```

**FlexiDataSchema:**
```js
z.object({
  scoutid: z.union([z.string(), z.number()]).transform(String),
  firstname: z.string().optional(),
  lastname: z.string().optional(),
}).passthrough()
```
The `.passthrough()` allows dynamic `f_1`, `f_2`, etc. fields that vary by flexi record type.

4. Create a `safeParseArray` utility function exported from the same file:
```js
export function safeParseArray(schema, data) {
  const arrayResult = z.array(schema).safeParse(data);
  if (arrayResult.success) {
    return { success: true, data: arrayResult.data, errors: [] };
  }
  // Graceful degradation: filter to individually valid records
  const validRecords = [];
  const errors = [];
  for (let i = 0; i < (data?.length || 0); i++) {
    const itemResult = schema.safeParse(data[i]);
    if (itemResult.success) {
      validRecords.push(itemResult.data);
    } else {
      errors.push({ index: i, issues: itemResult.error.issues });
    }
  }
  return { success: errors.length === 0, data: validRecords, errors };
}
```

5. Export all schemas as named exports. Also export array versions: `SectionArraySchema = z.array(SectionSchema)`, etc. for all 8 types.

6. Add JSDoc to each schema and the `safeParseArray` function. Do NOT add inline comments (per project rules).
  </action>
  <verify>
Run `node -e "import('zod').then(z => console.log('Zod version:', z.z.string().parse('ok')))"` to verify Zod is installed.
Run `npm run lint` to verify no lint errors in the new file.
Run `npm run test:run` to verify no regressions.
  </verify>
  <done>
Zod is a production dependency in package.json. validation.js exports 8 named Zod schemas (Section, Event, Attendance, SharedAttendance, Term, FlexiList, FlexiStructure, FlexiData), 8 array schema variants, and a safeParseArray utility. All schemas use .transform() for type coercion where needed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create schema constant files for IndexedDB and SQLite</name>
  <files>
    src/shared/services/storage/schemas/indexedDBSchema.js
    src/shared/services/storage/schemas/sqliteSchema.js
  </files>
  <action>
1. Create `src/shared/services/storage/schemas/indexedDBSchema.js` exporting a `NORMALIZED_STORES` constant object documenting the target IndexedDB store definitions. This serves as the reference for what each phase's `upgrade()` block should create. Structure:

```js
export const NORMALIZED_STORES = {
  sections: {
    keyPath: 'sectionid',
    indexes: [
      { name: 'sectiontype', keyPath: 'sectiontype', unique: false },
    ],
  },
  events: {
    keyPath: 'eventid',
    indexes: [
      { name: 'sectionid', keyPath: 'sectionid', unique: false },
      { name: 'termid', keyPath: 'termid', unique: false },
      { name: 'startdate', keyPath: 'startdate', unique: false },
    ],
  },
  attendance: {
    keyPath: ['eventid', 'scoutid'],
    indexes: [
      { name: 'eventid', keyPath: 'eventid', unique: false },
      { name: 'scoutid', keyPath: 'scoutid', unique: false },
    ],
  },
  shared_attendance: {
    keyPath: ['eventid', 'sectionid'],
    indexes: [
      { name: 'eventid', keyPath: 'eventid', unique: false },
    ],
  },
  terms: {
    keyPath: 'termid',
    indexes: [
      { name: 'sectionid', keyPath: 'sectionid', unique: false },
      { name: 'startdate', keyPath: 'startdate', unique: false },
    ],
  },
  flexi_lists: {
    keyPath: ['sectionid', 'extraid'],
    indexes: [
      { name: 'sectionid', keyPath: 'sectionid', unique: false },
    ],
  },
  flexi_structure: {
    keyPath: 'extraid',
    indexes: [],
  },
  flexi_data: {
    keyPath: ['extraid', 'sectionid', 'termid'],
    indexes: [
      { name: 'extraid', keyPath: 'extraid', unique: false },
      { name: 'sectionid', keyPath: 'sectionid', unique: false },
    ],
  },
};
```

Also export `UNCHANGED_STORES` listing stores that don't change: `cache_data`, `startup_data`, `current_active_terms`, `core_members`, `member_section`.

2. Create `src/shared/services/storage/schemas/sqliteSchema.js` exporting a `SQLITE_SCHEMAS` constant object with CREATE TABLE statements for the three missing flexi tables:

```js
export const SQLITE_SCHEMAS = {
  flexi_lists: `
    CREATE TABLE IF NOT EXISTS flexi_lists (
      extraid TEXT NOT NULL,
      sectionid INTEGER NOT NULL,
      name TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (extraid, sectionid)
    )
  `,
  flexi_structure: `
    CREATE TABLE IF NOT EXISTS flexi_structure (
      extraid TEXT PRIMARY KEY,
      name TEXT,
      config TEXT,
      structure TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `,
  flexi_data: `
    CREATE TABLE IF NOT EXISTS flexi_data (
      extraid TEXT NOT NULL,
      sectionid INTEGER NOT NULL,
      termid TEXT NOT NULL,
      scoutid TEXT NOT NULL,
      firstname TEXT,
      lastname TEXT,
      data TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (extraid, sectionid, termid, scoutid)
    )
  `,
};
```

Also export `SQLITE_INDEXES` with CREATE INDEX IF NOT EXISTS statements for missing indexes on existing tables:
- `CREATE INDEX IF NOT EXISTS idx_events_sectionid ON events(sectionid)`
- `CREATE INDEX IF NOT EXISTS idx_events_termid ON events(termid)`
- `CREATE INDEX IF NOT EXISTS idx_events_startdate ON events(startdate)`
- `CREATE INDEX IF NOT EXISTS idx_attendance_eventid ON attendance(eventid)`
- `CREATE INDEX IF NOT EXISTS idx_attendance_scoutid ON attendance(scoutid)`
- `CREATE INDEX IF NOT EXISTS idx_sections_sectiontype ON sections(sectiontype)`

3. Add JSDoc to all exports. No inline comments.
  </action>
  <verify>
Run `npm run lint` to verify no lint errors.
Run `npm run test:run` to verify no regressions.
  </verify>
  <done>
indexedDBSchema.js exports NORMALIZED_STORES and UNCHANGED_STORES constants. sqliteSchema.js exports SQLITE_SCHEMAS (3 CREATE TABLE statements) and SQLITE_INDEXES (6 CREATE INDEX statements). All constants match the target schema defined in the research document.
  </done>
</task>

</tasks>

<verification>
1. `npm ls zod` shows zod is installed as a production dependency
2. `npm run lint` passes with no errors in schemas/ directory
3. `npm run test:run` passes (no regressions)
4. All three schema files are importable: `node -e "import('./src/shared/services/storage/schemas/validation.js').then(m => console.log(Object.keys(m)))"`
</verification>

<success_criteria>
- Zod is installed and importable
- 8 Zod validation schemas exist covering all data types, with .transform() for type coercion
- safeParseArray utility provides graceful degradation for arrays with some invalid records
- IndexedDB target schema constants document all normalized store definitions
- SQLite schema constants contain CREATE TABLE statements for 3 missing tables and CREATE INDEX for 6 missing indexes
- All lint and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-schema/01-01-SUMMARY.md`
</output>
