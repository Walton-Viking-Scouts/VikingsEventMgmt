---
phase: 06-flexi-records-normalization
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/shared/services/storage/database.js
autonomous: true

must_haves:
  truths:
    - "DatabaseService.getFlexiLists returns flexi lists for a section without throwing Error"
    - "DatabaseService.saveFlexiLists persists flexi lists with Zod validation"
    - "DatabaseService.getFlexiStructure returns a flexi structure without throwing Error"
    - "DatabaseService.saveFlexiStructure persists a flexi structure with Zod validation"
    - "DatabaseService.getFlexiData returns flexi data without throwing Error"
    - "DatabaseService.saveFlexiData persists flexi data with Zod validation"
    - "All six methods work on both web (IndexedDB) and native (SQLite) platforms"
  artifacts:
    - path: "src/shared/services/storage/database.js"
      provides: "6 working flexi methods replacing Phase 6 stubs"
      contains: "FlexiListSchema"
  key_links:
    - from: "src/shared/services/storage/database.js"
      to: "src/shared/services/storage/indexedDBService.js"
      via: "IndexedDBService static method calls"
      pattern: "IndexedDBService\\.(bulkReplace|get|save)Flexi"
    - from: "src/shared/services/storage/database.js"
      to: "src/shared/services/storage/schemas/validation.js"
      via: "Zod schema imports for write validation"
      pattern: "FlexiListSchema|FlexiStructureSchema|FlexiDataSchema"
---

<objective>
Replace all 6 DatabaseService flexi stub methods with working implementations using Zod validation, IndexedDB (web), and SQLite (native).

Purpose: Provides the platform-agnostic DatabaseService API that FlexiRecordDataService will call in Plan 03, completing the storage layer for flexi records.
Output: DatabaseService with 6 working flexi methods (3 get + 3 save) on both platforms.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-flexi-records-normalization/06-RESEARCH.md
@.planning/phases/06-flexi-records-normalization/06-01-SUMMARY.md

@src/shared/services/storage/database.js
@src/shared/services/storage/schemas/validation.js
@src/shared/services/storage/schemas/sqliteSchema.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DatabaseService flexi list and structure methods</name>
  <files>src/shared/services/storage/database.js</files>
  <action>
Import FlexiListSchema, FlexiStructureSchema, and FlexiDataSchema from validation.js (add to existing schema import line alongside SectionSchema, EventSchema, etc.).

Replace the 4 stub methods (getFlexiLists, saveFlexiLists, getFlexiStructure, saveFlexiStructure) with working implementations following the established patterns from saveTerms/getTerms (Phase 5):

**getFlexiLists(sectionId):**
- Remove the `throw new Error(...)` line
- Web path: `return await IndexedDBService.getFlexiListsBySection(sectionId)`
- Native path: `SELECT * FROM flexi_lists WHERE sectionid = ?` with `[Number(sectionId)]`, return `res.values || []`
- Read-path resilience: wrap in try/catch, return `[]` on error with Sentry capture

**saveFlexiLists(sectionId, lists):**
- Remove the `throw new Error(...)` line
- Enrich each list with sectionid: `lists.map(l => ({ ...l, sectionid: sectionId }))`
- Zod validate: `const { data: valid, errors } = safeParseArray(FlexiListSchema, enriched)`
- Log warning if errors.length > 0 (single log, not per-error)
- Web path: `await IndexedDBService.bulkReplaceFlexiListsForSection(sectionId, valid)`
- Native path: `BEGIN TRANSACTION`, `DELETE FROM flexi_lists WHERE sectionid = ?`, INSERT OR REPLACE each record with `(sectionid, extraid, name)` columns, `COMMIT`. Wrap in try/catch with ROLLBACK on error.

**getFlexiStructure(recordId):**
- Remove the `throw new Error(...)` line
- Web path: `return await IndexedDBService.getFlexiRecordStructure(recordId)`
- Native path: `SELECT * FROM flexi_structure WHERE extraid = ?` with `[String(recordId)]`, return first row or null
- Read-path resilience: return null on error

**saveFlexiStructure(recordId, structure):**
- Remove the `throw new Error(...)` line
- Enrich: `{ ...structure, extraid: recordId }`
- Zod validate: single parse with FlexiStructureSchema (not array)
- Web path: `await IndexedDBService.saveFlexiRecordStructure(valid)`
- Native path: `INSERT OR REPLACE INTO flexi_structure (extraid, name, config, structure) VALUES (?, ?, ?, ?)` storing structure field as JSON.stringify

Remove underscore prefixes from parameter names (change `_sectionId` to `sectionId`, etc.) since params are now used.
  </action>
  <verify>Run `npm run lint` -- no errors. Grep for "Phase 6" in database.js to confirm only getFlexiData and saveFlexiData stubs remain.</verify>
  <done>getFlexiLists, saveFlexiLists, getFlexiStructure, and saveFlexiStructure are fully implemented with Zod validation and dual-platform support.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DatabaseService flexi data methods</name>
  <files>src/shared/services/storage/database.js</files>
  <action>
Replace the 2 remaining stub methods (getFlexiData, saveFlexiData):

**getFlexiData(recordId, sectionId, termId):**
- Remove the `throw new Error(...)` line
- Web path: `return await IndexedDBService.getFlexiRecordData(recordId, sectionId, termId)` — returns the full API response object (or null if not found)
- Native path: `SELECT * FROM flexi_data WHERE extraid = ? AND sectionid = ? AND termid = ?` with `[String(recordId), Number(sectionId), String(termId)]`, return `res.values || []`
- Read-path resilience: return null on error (web) or [] on error (native), with Sentry capture
- Note: web returns the stored object (with items array inside), native returns individual rows. This asymmetry is intentional per the research — FlexiRecordDataService already handles the difference.

**saveFlexiData(recordId, sectionId, termId, data):**
- Remove the `throw new Error(...)` line
- Web path: `await IndexedDBService.saveFlexiRecordData(recordId, sectionId, termId, data)` — stores the full API response as one record
- Native path: If `data` is an array of member rows, validate each with `safeParseArray(FlexiDataSchema, data)`. Then `BEGIN TRANSACTION`, `DELETE FROM flexi_data WHERE extraid = ? AND sectionid = ? AND termid = ?`, INSERT OR REPLACE each valid row with columns `(extraid, sectionid, termid, scoutid, firstname, lastname, data)` where `data` = JSON.stringify of remaining fields. `COMMIT`. Wrap in try/catch with ROLLBACK on error.
- If `data` is an object (full API response with items array), extract `data.items` for SQLite row insertion.

Remove underscore prefixes from all parameter names. Update JSDoc to remove `@throws` annotations since methods no longer throw.
  </action>
  <verify>Run `npm run lint` -- no errors. Grep for "Phase 6" in database.js -- should return zero matches. Grep for "not yet implemented" -- should not match any flexi methods. Run `npm run build` to verify no import errors.</verify>
  <done>All 6 DatabaseService flexi stubs are replaced with working implementations. No "Phase 6" stub errors remain.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes
2. `npm run build` succeeds
3. Zero occurrences of "Phase 6" or "not yet implemented" in database.js for flexi methods
4. All 6 methods have Zod validation on writes, read-path resilience on reads
5. Both web (IndexedDB) and native (SQLite) code paths exist
</verification>

<success_criteria>
All 6 DatabaseService flexi methods work on both platforms. No stub errors remain. Zod validation applied at write boundary. Read paths are resilient with fallback values.
</success_criteria>

<output>
After completion, create `.planning/phases/06-flexi-records-normalization/06-02-SUMMARY.md`
</output>
