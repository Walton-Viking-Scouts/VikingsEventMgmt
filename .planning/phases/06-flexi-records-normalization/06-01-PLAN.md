---
phase: 06-flexi-records-normalization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/services/storage/indexedDBService.js
autonomous: true

must_haves:
  truths:
    - "IndexedDB flexi_lists store uses compound keyPath [sectionid, extraid] with sectionid index"
    - "IndexedDB flexi_structure store uses keyPath extraid"
    - "IndexedDB flexi_data store uses compound keyPath [extraid, sectionid, termid] with extraid and sectionid indexes"
    - "CRUD methods exist for all three flexi stores in IndexedDBService"
  artifacts:
    - path: "src/shared/services/storage/indexedDBService.js"
      provides: "v8 upgrade block + 9 CRUD methods for flexi stores"
      contains: "oldVersion < 8"
  key_links:
    - from: "src/shared/services/storage/indexedDBService.js"
      to: "NORMALIZED_STORES in indexedDBSchema.js"
      via: "store definitions match schema constants"
      pattern: "STORES\\.FLEXI_"
---

<objective>
Bump IndexedDB to version 8 with normalized flexi stores and add all CRUD methods to IndexedDBService.

Purpose: Provides the storage foundation for all three flexi record stores (lists, structures, data) with proper keyPaths, indexes, and query methods that DatabaseService will call in Plan 02.
Output: IndexedDBService with v8 upgrade block and 9 static CRUD methods for flexi stores.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-flexi-records-normalization/06-RESEARCH.md

@src/shared/services/storage/indexedDBService.js
@src/shared/services/storage/schemas/indexedDBSchema.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add v8 upgrade block for normalized flexi stores</name>
  <files>src/shared/services/storage/indexedDBService.js</files>
  <action>
Bump DATABASE_VERSION from 7 to 8.

Add an `if (oldVersion < 8)` block inside the upgrade() callback (after the existing `if (oldVersion < 7)` block). Inside the v8 block, delete and recreate all three flexi stores with proper keyPaths and indexes matching NORMALIZED_STORES from indexedDBSchema.js:

1. **flexi_lists**: Delete if exists, recreate with `keyPath: ['sectionid', 'extraid']`, add index `sectionid` (non-unique).
2. **flexi_structure**: Delete if exists, recreate with `keyPath: 'extraid'`, no indexes.
3. **flexi_data**: Delete if exists, recreate with `keyPath: ['extraid', 'sectionid', 'termid']`, add indexes `extraid` (non-unique) and `sectionid` (non-unique).

Follow the exact pattern from the v7 upgrade block (Phase 5): check `db.objectStoreNames.contains()` before deleting, then `db.createObjectStore()` + `store.createIndex()`.
  </action>
  <verify>Run `npm run lint` -- no errors on indexedDBService.js. Grep for `oldVersion < 8` in the file to confirm the block exists. Grep for `DATABASE_VERSION` to confirm it equals 8.</verify>
  <done>DATABASE_VERSION is 8, v8 upgrade block deletes and recreates all three flexi stores with correct keyPaths and indexes.</done>
</task>

<task type="auto">
  <name>Task 2: Add CRUD methods for all three flexi stores</name>
  <files>src/shared/services/storage/indexedDBService.js</files>
  <action>
Add 9 static methods to IndexedDBService, following the established patterns from prior phases (section-scoped cursor delete for bulk replace, index queries for lookups, read-path resilience with try/catch returning empty array/null on error, Sentry error capture).

**flexi_lists (compound key [sectionid, extraid]):**
1. `static async bulkReplaceFlexiListsForSection(sectionId, lists)` — Open readwrite tx on STORES.FLEXI_LISTS, cursor-delete by sectionid index (matching `bulkReplaceEventsForSection` pattern), then put each list with `updated_at: Date.now()`. Return count.
2. `static async getFlexiListsBySection(sectionId)` — Use `db.getAllFromIndex(STORES.FLEXI_LISTS, 'sectionid', Number(sectionId))` with read-path resilience (return [] on error).
3. `static async getAllFlexiLists()` — Use `db.getAll(STORES.FLEXI_LISTS)` with read-path resilience.

**flexi_structure (simple key extraid):**
4. `static async saveFlexiRecordStructure(structure)` — Use `db.put(STORES.FLEXI_STRUCTURE, { ...structure, updated_at: Date.now() })` with error logging.
5. `static async getFlexiRecordStructure(extraId)` — Use `db.get(STORES.FLEXI_STRUCTURE, String(extraId))` with read-path resilience (return null on error).
6. `static async getAllFlexiRecordStructures()` — Use `db.getAll(STORES.FLEXI_STRUCTURE)` with read-path resilience.

**flexi_data (compound key [extraid, sectionid, termid]):**
7. `static async saveFlexiRecordData(extraId, sectionId, termId, data)` — Use `db.put(STORES.FLEXI_DATA, { ...data, extraid: String(extraId), sectionid: Number(sectionId), termid: String(termId), updated_at: Date.now() })`. The `data` parameter is the full API response object (contains items array). Store it as a single record keyed by the compound key.
8. `static async getFlexiRecordData(extraId, sectionId, termId)` — Use `db.get(STORES.FLEXI_DATA, [String(extraId), Number(sectionId), String(termId)])` with read-path resilience (return null on error).
9. `static async getFlexiRecordDataByExtra(extraId)` — Use `db.getAllFromIndex(STORES.FLEXI_DATA, 'extraid', String(extraId))` with read-path resilience (return [] on error).

All methods must:
- Use `const db = await getDB()` at the top
- Include try/catch with logger.error and sentryUtils.captureException following existing patterns
- Use consistent type coercion: sectionId -> Number(), extraId/termId -> String()
- Add JSDoc with @param and @returns tags
- NO inline comments (per code style policy)
  </action>
  <verify>Run `npm run lint` -- no errors. Grep for each method name to confirm all 9 exist: `bulkReplaceFlexiListsForSection`, `getFlexiListsBySection`, `getAllFlexiLists`, `saveFlexiRecordStructure`, `getFlexiRecordStructure`, `getAllFlexiRecordStructures`, `saveFlexiRecordData`, `getFlexiRecordData`, `getFlexiRecordDataByExtra`.</verify>
  <done>All 9 CRUD methods exist in IndexedDBService with proper error handling, type coercion, and Sentry logging.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with no errors
2. `npm run build` succeeds
3. DATABASE_VERSION equals 8
4. v8 upgrade block creates all three stores with correct keyPaths/indexes
5. All 9 CRUD methods exist with try/catch, Sentry, and JSDoc
</verification>

<success_criteria>
IndexedDBService has a v8 upgrade block that normalizes all three flexi stores with proper compound keys and indexes, plus 9 CRUD methods following established patterns from Phases 2-5.
</success_criteria>

<output>
After completion, create `.planning/phases/06-flexi-records-normalization/06-01-SUMMARY.md`
</output>
