---
phase: 02-sections-normalization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/shared/services/storage/indexedDBService.js
  - src/shared/services/storage/database.js
  - src/shared/services/storage/__tests__/sectionNormalization.test.js
autonomous: true

must_haves:
  truths:
    - "Sections synced from API are stored as individual records keyed by sectionid (not blob array)"
    - "getSections() returns the same data shape (array of objects with sectionid, sectionname, sectiontype) on both IndexedDB and SQLite"
    - "Bulk upsert replaces the entire sections dataset atomically -- no partial state on failure"
    - "Demo sections are filtered out when not in demo mode"
  artifacts:
    - path: "src/shared/services/storage/indexedDBService.js"
      provides: "Store replacement in v5 upgrade block, bulkReplaceSections, getAllSections"
      contains: "bulkReplaceSections"
    - path: "src/shared/services/storage/database.js"
      provides: "saveSections with Zod validation + direct IndexedDB write, getSections with direct read"
      contains: "safeParseArray"
    - path: "src/shared/services/storage/__tests__/sectionNormalization.test.js"
      provides: "Integration tests for sections normalization on IndexedDB"
      exports: []
  key_links:
    - from: "src/shared/services/storage/database.js"
      to: "src/shared/services/storage/indexedDBService.js"
      via: "IndexedDBService.bulkReplaceSections and IndexedDBService.getAllSections"
      pattern: "IndexedDBService\\.bulkReplaceSections|IndexedDBService\\.getAllSections"
    - from: "src/shared/services/storage/database.js"
      to: "src/shared/services/storage/schemas/validation.js"
      via: "Zod validation at write boundary"
      pattern: "safeParseArray.*SectionSchema"
    - from: "src/shared/services/storage/indexedDBService.js"
      to: "IndexedDB upgrade callback"
      via: "v5 upgrade block deletes+recreates sections store"
      pattern: "deleteObjectStore.*SECTIONS|createObjectStore.*sectionid"
---

<objective>
Normalize sections storage from blob-in-a-key to individual records keyed by sectionid on both IndexedDB and SQLite platforms.

Purpose: This is the first data-type normalization, proving the end-to-end pattern (store migration, direct IndexedDB access, Zod validation at write boundary, atomic bulk replacement) that phases 3-6 will repeat.

Output: Working saveSections/getSections on both platforms with normalized storage, plus integration tests.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sections-normalization/02-RESEARCH.md
@.planning/phases/01-infrastructure-schema/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-schema/01-02-SUMMARY.md
@src/shared/services/storage/indexedDBService.js
@src/shared/services/storage/database.js
@src/shared/services/storage/schemas/validation.js
@src/shared/services/storage/schemas/indexedDBSchema.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: IndexedDB store migration and new section methods</name>
  <files>src/shared/services/storage/indexedDBService.js</files>
  <action>
Three changes to indexedDBService.js:

**1. Store replacement in v5 upgrade block.**
Inside the existing `if (oldVersion < 5)` block in the upgrade() callback, add:
```javascript
if (db.objectStoreNames.contains(STORES.SECTIONS)) {
  db.deleteObjectStore(STORES.SECTIONS);
}
const sectionsStore = db.createObjectStore(STORES.SECTIONS, { keyPath: 'sectionid' });
sectionsStore.createIndex('sectiontype', 'sectiontype', { unique: false });
```
Add a logger.info call after the store creation: `'IndexedDB v5 upgrade: sections store normalized'` with `{ dbName }` context and `LOG_CATEGORIES.DATABASE`.

Leave the existing fresh-install guard (`if (!db.objectStoreNames.contains(STORES.SECTIONS))`) unchanged -- the v5 block always replaces it, and this keeps changes isolated (per research recommendation).

**2. Add static `bulkReplaceSections(sections)` method.**
Follow the `bulkUpsertCoreMembers` pattern (same file, ~lines 544-590) but use clear-then-put instead of merge:
- Open a readwrite transaction on STORES.SECTIONS
- `await store.clear()` to remove all existing records
- Loop `await store.put({ ...section, updated_at: Date.now() })` for each section
- `await tx.done` for atomic commit
- Return `sections.length`
- Wrap in try/catch with logger.error + sentryUtils.captureException (operation tag: `indexeddb_bulk_replace_sections`, store: STORES.SECTIONS)

**3. Add static `getAllSections()` method.**
Follow the `getAllCoreMembers` pattern (~lines 486-512):
- `const db = await getDB(); return (await db.getAll(STORES.SECTIONS)) || [];`
- Wrap in try/catch with logger.error + sentryUtils.captureException (operation tag: `indexeddb_get_all_sections`, store: STORES.SECTIONS)
  </action>
  <verify>
Run `npm run test:run -- --reporter=verbose 2>&1 | tail -40` from the project root (vikings-eventmgmt-mobile/) to confirm all existing tests still pass. The v5 upgrade block change should not break any tests since Phase 1 tests already expect DATABASE_VERSION 5.
  </verify>
  <done>
indexedDBService.js has: (1) sections store delete+recreate in v5 upgrade block with keyPath:'sectionid' and sectiontype index, (2) bulkReplaceSections static method with atomic clear+put, (3) getAllSections static method. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: DatabaseService saveSections/getSections bypass UnifiedStorageService</name>
  <files>src/shared/services/storage/database.js</files>
  <action>
Two method rewrites in database.js:

**1. Rewrite `saveSections(sections)` (web path).**
Add imports at top of file (if not already present):
- `import { SectionSchema, safeParseArray } from './schemas/validation.js';`
- Ensure `IndexedDBService` is imported (it likely already is).

Replace the web path (`if (!this.isNative || !this.db)` branch) to:
- Call `const { data: validSections, errors } = safeParseArray(SectionSchema, sections);`
- If `errors.length > 0`, log with `logger.warn('Section validation errors during save', { errorCount: errors.length, totalCount: sections?.length, errors: errors.slice(0, 5) }, LOG_CATEGORIES.DATABASE);`
- Call `await IndexedDBService.bulkReplaceSections(validSections);`
- Return (do NOT route through UnifiedStorageService)

Replace the SQLite path to wrap DELETE+INSERT in a transaction:
- `await this.db.execute('BEGIN TRANSACTION');`
- In try block: `await this.db.execute('DELETE FROM sections');` then loop INSERT for each section
- `await this.db.execute('COMMIT');`
- In catch: `await this.db.execute('ROLLBACK');` then rethrow
- After transaction: `await this.updateSyncStatus('sections');`

**2. Rewrite `getSections()` (web path).**
Replace the web path to:
- Call `const sections = await IndexedDBService.getAllSections();`
- Import isDemoMode: `const { isDemoMode } = await import('../../../config/demoMode.js');`
- If NOT in demo mode, filter out demo sections: `return sections.filter(s => !(typeof s?.sectionname === 'string' && s.sectionname.startsWith('Demo ')));`
- If in demo mode, return sections as-is

Leave the SQLite path (`SELECT * FROM sections ORDER BY sectionname`) unchanged (it already returns normalized rows).

**Important:** Remove any reference to UnifiedStorageService for sections reads/writes in these two methods. The old calls like `this.unifiedStorage.setSections()` or `this.unifiedStorage.getSections()` must be replaced, not kept alongside.
  </action>
  <verify>
Run `npm run lint 2>&1 | tail -20` to confirm no lint errors. Run `npm run test:run -- --reporter=verbose 2>&1 | tail -40` to confirm all tests pass.
  </verify>
  <done>
database.js saveSections() validates with Zod then writes directly to IndexedDB (web) or uses transactional DELETE+INSERT (SQLite). getSections() reads directly from IndexedDB (web) with demo mode filtering. No UnifiedStorageService involvement for sections. Lint and tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for sections normalization</name>
  <files>src/shared/services/storage/__tests__/sectionNormalization.test.js</files>
  <action>
Create a new test file using Vitest and fake-indexeddb (already a devDependency, used in existing indexedDBService.test.js). Reference the existing test patterns in `indexedDBService.test.js` for setup/teardown with fake-indexeddb.

Tests to write:

**1. "bulkReplaceSections stores individual records keyed by sectionid"**
- Call `IndexedDBService.bulkReplaceSections([{ sectionid: 1, sectionname: 'Cubs', sectiontype: 'cubs' }, { sectionid: 2, sectionname: 'Scouts', sectiontype: 'scouts' }])`
- Call `IndexedDBService.getAllSections()`
- Assert result is array of length 2
- Assert each record has `sectionid`, `sectionname`, `sectiontype`, `updated_at` fields
- Assert records are keyed by sectionid (find by sectionid works)

**2. "bulkReplaceSections replaces all records atomically"**
- Call bulkReplaceSections with sections A and B
- Call bulkReplaceSections with sections C and D
- Call getAllSections
- Assert result contains ONLY C and D (not A and B)
- Assert result length is exactly 2

**3. "bulkReplaceSections with empty array clears all sections"**
- Call bulkReplaceSections with 2 sections
- Call bulkReplaceSections with empty array
- Call getAllSections
- Assert result is empty array

**4. "getAllSections returns empty array when no sections exist"**
- Call getAllSections on fresh database
- Assert result is empty array (not null/undefined)

**5. "sections store has sectiontype index"**
- After bulkReplaceSections with mixed sectiontype values
- Open a transaction on the sections store, get the sectiontype index
- Use `index.getAll('cubs')` to query by sectiontype
- Assert only cubs sections returned

Use `beforeEach` to initialize IndexedDB (call the internal getDB or equivalent to trigger upgrade). Use `afterEach` or `beforeEach` to clear state between tests. Follow the import pattern from existing test files.
  </action>
  <verify>
Run `npm run test:run -- src/shared/services/storage/__tests__/sectionNormalization.test.js --reporter=verbose 2>&1` to confirm all 5 tests pass. Then run `npm run test:run 2>&1 | tail -10` to confirm all project tests still pass.
  </verify>
  <done>
5 integration tests pass covering: individual record storage, atomic replacement, empty array clearing, empty-state read, and sectiontype index query. All project tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint` -- 0 errors
2. `npm run test:run` -- all tests pass including new sectionNormalization tests
3. `npm run build` -- production build succeeds
4. Verify in indexedDBService.js: v5 upgrade block contains sections store delete+recreate with keyPath:'sectionid'
5. Verify in database.js: saveSections imports safeParseArray and calls IndexedDBService.bulkReplaceSections (not UnifiedStorageService)
6. Verify in database.js: getSections calls IndexedDBService.getAllSections (not UnifiedStorageService)
</verification>

<success_criteria>
- Sections stored as individual records keyed by sectionid in IndexedDB (SECT-01)
- SQLite saveSections uses transactional DELETE+INSERT (SECT-02, SECT-03)
- Bulk upsert replaces entire dataset atomically via clear+put in single transaction (SECT-03)
- getSections returns consistent array-of-objects shape on both platforms (SECT-04)
- Zod validation at write boundary catches malformed section data
- Demo mode filtering preserved in getSections web path
- 5 integration tests verify the normalized CRUD behavior
</success_criteria>

<output>
After completion, create `.planning/phases/02-sections-normalization/02-01-SUMMARY.md`
</output>
