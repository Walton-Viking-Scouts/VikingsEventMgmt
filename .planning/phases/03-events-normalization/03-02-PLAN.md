---
phase: 03-events-normalization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/shared/services/storage/database.js
  - src/shared/services/storage/__tests__/eventNormalization.test.js
autonomous: true

must_haves:
  truths:
    - "saveEvents validates with Zod and writes directly to IndexedDB via bulkReplaceEventsForSection, bypassing UnifiedStorageService"
    - "getEvents reads from IndexedDB via getEventsBySection with demo mode filtering preserved"
    - "getEventsByTerm and getEventById work on both web and native platforms"
    - "SQLite saveEvents is wrapped in a transaction for atomicity"
    - "Integration tests verify normalized event CRUD with section-scoped replacement"
  artifacts:
    - path: "src/shared/services/storage/database.js"
      provides: "Normalized saveEvents, getEvents, getEventsByTerm, getEventById"
      contains: "bulkReplaceEventsForSection"
    - path: "src/shared/services/storage/__tests__/eventNormalization.test.js"
      provides: "Integration tests for event normalization"
      contains: "eventNormalization"
  key_links:
    - from: "database.js saveEvents"
      to: "IndexedDBService.bulkReplaceEventsForSection"
      via: "direct static method call after Zod validation"
      pattern: "IndexedDBService\\.bulkReplaceEventsForSection"
    - from: "database.js getEvents"
      to: "IndexedDBService.getEventsBySection"
      via: "direct static method call"
      pattern: "IndexedDBService\\.getEventsBySection"
    - from: "database.js saveEvents"
      to: "safeParseArray(EventSchema, events)"
      via: "Zod validation at write boundary"
      pattern: "safeParseArray.*EventSchema"
---

<objective>
Update DatabaseService to bypass UnifiedStorageService for events, using Zod validation at write boundary and direct IndexedDB access. Add query methods and integration tests.

Purpose: Completes the events normalization by wiring DatabaseService to the IndexedDBService methods from plan 03-01.
Output: DatabaseService with normalized event methods, SQLite transaction wrapping, and integration test suite.
</objective>

<execution_context>
@/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-events-normalization/03-01-SUMMARY.md
@src/shared/services/storage/database.js
@src/shared/services/storage/indexedDBService.js
@src/shared/services/storage/schemas/validation.js
@src/shared/services/storage/__tests__/sectionNormalization.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update DatabaseService saveEvents, getEvents, and add query methods</name>
  <files>src/shared/services/storage/database.js</files>
  <action>
Modify the existing `saveEvents` and `getEvents` methods and add two new query methods. Import `EventSchema` from `schemas/validation.js` (add to existing import that already imports `SectionSchema` and `safeParseArray`). Import `IndexedDBService` if not already imported.

**saveEvents(sectionId, events) -- replace web path (around line 507):**

Replace the web path that calls `this._saveWebStorageEvents(sectionId, events)` with:
1. `const { data: validEvents, errors } = safeParseArray(EventSchema, events);`
2. Log warning if errors.length > 0 (same pattern as saveSections): `logger.warn('Event validation errors during save', { errorCount: errors.length, totalCount: events?.length, errors: errors.slice(0, 5) }, LOG_CATEGORIES.DATABASE);`
3. `await IndexedDBService.bulkReplaceEventsForSection(sectionId, validEvents);`
4. `return;`

Keep the native/SQLite path but wrap it in a transaction:
- Add `await this.db.execute('BEGIN TRANSACTION');` before the DELETE
- Wrap the existing DELETE + INSERT loop in try/catch
- Add `await this.db.execute('COMMIT');` after the loop
- In catch: `await this.db.execute('ROLLBACK');` then re-throw
- Keep the existing `await this.updateSyncStatus('events');` after the transaction

**getEvents(sectionId) -- replace web path (around line 578):**

Replace the web path that calls `this._getWebStorageEvents(sectionId)` with:
1. `const events = await IndexedDBService.getEventsBySection(sectionId);`
2. Preserve demo mode filtering: import `isDemoMode` dynamically (`const { isDemoMode } = await import('../../../config/demoMode.js');`) and if NOT demo mode, filter out events where `eventid` starts with `'demo_event_'`
3. Return the (filtered) events

The demo mode filtering pattern should match what getSections does for demo sections.

**Add getEventsByTerm(termId) -- new method:**
- `await this.initialize();`
- Web path: `return IndexedDBService.getEventsByTerm(termId);`
- Native path: `const query = 'SELECT * FROM events WHERE termid = ? ORDER BY startdate DESC'; const result = await this.db.query(query, [termId]); return result.values || [];`
- Add JSDoc with @param and @returns

**Add getEventById(eventId) -- new method:**
- `await this.initialize();`
- Web path: `return IndexedDBService.getEventById(eventId);`
- Native path: `const query = 'SELECT * FROM events WHERE eventid = ?'; const result = await this.db.query(query, [eventId]); return result.values?.[0] || null;`
- Add JSDoc with @param and @returns

**DO NOT** remove `_saveWebStorageEvents` or `_getWebStorageEvents` private methods yet -- they may be referenced elsewhere. They are now dead code on the events path but cleanup is Phase 7's job per the backwards compatibility policy.

**DO NOT add inline comments** -- JSDoc documentation only per project standards.
  </action>
  <verify>Run `npm run lint` to check for lint errors. Run `npm run test:run` to verify all existing tests pass. Grep for `bulkReplaceEventsForSection` and `getEventsBySection` in database.js to confirm the new call paths exist.</verify>
  <done>DatabaseService.saveEvents validates with Zod and calls IndexedDBService.bulkReplaceEventsForSection (web) or uses transactional SQL (native). getEvents reads from IndexedDBService.getEventsBySection with demo mode filtering. getEventsByTerm and getEventById work on both platforms.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for events normalization</name>
  <files>src/shared/services/storage/__tests__/eventNormalization.test.js</files>
  <action>
Create a new test file following the exact structure of `sectionNormalization.test.js`. Use `fake-indexeddb` for IndexedDB simulation. Import `IndexedDBService` and test the normalized event CRUD methods directly.

**Test setup:** Same as sectionNormalization.test.js -- import `fake-indexeddb/auto`, import IndexedDBService, use beforeEach to reset the DB (call `IndexedDBService._resetForTesting()` if available, or re-initialize).

**Required tests (5-6 tests):**

1. **"should store and retrieve events by section"**
   - Call `bulkReplaceEventsForSection(1, [{ eventid: 'evt1', sectionid: 1, termid: 't1', name: 'Camp', startdate: '2026-03-01' }, { eventid: 'evt2', sectionid: 1, termid: 't1', name: 'Hike', startdate: '2026-03-15' }])`
   - Call `getEventsBySection(1)` -- expect 2 results with correct eventid values

2. **"should replace only events for target section (section-scoped)"**
   - Store events for section 1 AND section 2
   - Call `bulkReplaceEventsForSection(1, [newEvent])` with replacement data for section 1 only
   - Verify `getEventsBySection(1)` returns only the new event
   - Verify `getEventsBySection(2)` still has its original events (untouched)

3. **"should retrieve events by term"**
   - Store events with different termid values
   - Call `getEventsByTerm('t1')` -- expect only events with termid 't1'

4. **"should retrieve single event by ID"**
   - Store multiple events
   - Call `getEventById('evt1')` -- expect the correct event
   - Call `getEventById('nonexistent')` -- expect null

5. **"should handle empty section gracefully"**
   - Call `getEventsBySection(999)` -- expect empty array
   - Call `bulkReplaceEventsForSection(999, [])` -- expect 0 returned, no errors

6. **"should handle bulk replace atomically (all-or-nothing)"**
   - Store events for section 1
   - Replace with new events for section 1
   - Verify old events are gone and new events are present (no duplicates, no partial state)
  </action>
  <verify>Run `npm run test:run` -- all new tests pass alongside existing tests. Run `npm run lint` on the test file.</verify>
  <done>6 integration tests verify: store+retrieve by section, section-scoped replacement (other sections untouched), query by term, query by ID (including null for missing), empty section handling, and atomic replacement behavior.</done>
</task>

</tasks>

<verification>
1. `npm run test:run` -- all tests pass (existing + new event normalization tests)
2. `npm run lint` -- no lint errors
3. grep confirms `safeParseArray(EventSchema` in database.js saveEvents
4. grep confirms `IndexedDBService.bulkReplaceEventsForSection` in database.js
5. grep confirms `IndexedDBService.getEventsBySection` in database.js getEvents
6. eventNormalization.test.js exists with 5+ passing tests
</verification>

<success_criteria>
DatabaseService event methods bypass UnifiedStorageService and use direct IndexedDB access with Zod validation. SQLite path is transaction-wrapped. Integration tests verify section-scoped replacement and index-based queries.
</success_criteria>

<output>
After completion, create `.planning/phases/03-events-normalization/03-02-SUMMARY.md`
</output>
