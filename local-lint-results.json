[{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/App.jsx","messages":[{"ruleId":"jsdoc/check-tag-names","severity":2,"message":"Invalid JSDoc tag name \"scout-themed\".","line":18,"column":1,"nodeType":"Block","endLine":18,"endColumn":1},{"ruleId":"jsdoc/check-tag-names","severity":2,"message":"Invalid JSDoc tag name \"offline-aware\".","line":19,"column":1,"nodeType":"Block","endLine":19,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Toaster } from 'react-hot-toast';\nimport AppRouter from './routes/AppRouter.jsx';\nimport './App.css';\n\n/**\n * Main App component for the Viking Event Management mobile application.\n *\n * This is the root component that orchestrates the Scout event management system.\n * It integrates the main routing system with global notification toasts, providing\n * the foundation for offline-first Scout event management and member tracking.\n *\n * The component combines the AppRouter for handling all navigation and the Toaster\n * for displaying user feedback throughout the Scout management workflows.\n *\n * @component\n * @returns {ReactElement} The complete Scout application with routing and notifications\n * @scout-themed\n * @offline-aware\n * @since 1.0.0\n * @example\n * // Basic usage as the root component\n * import App from './App.jsx';\n * \n * createRoot(document.getElementById('root')).render(\n *   <StrictMode>\n *     <App />\n *   </StrictMode>\n * );\n * @example\n * // Integration with native platforms using Capacitor\n * // The App component automatically handles:\n * // - Offline data synchronization for Scout events\n * // - Member movement tracking between sections\n * // - OSM API integration with rate limiting\n * // - Authentication state management\n * \n * npx cap sync  // Sync to native platforms\n * @example\n * // Scout management workflow supported:\n * // 1. View and manage Scout sections (Beavers, Cubs, Scouts, etc.)\n * // 2. Track member movements between sections\n * // 3. Manage Scout events and attendance\n * // 4. Handle offline scenarios with cached data\n * // 5. Sync with OSM (Online Scout Manager) when online\n */\nfunction App() {\n  return (\n    <>\n      <AppRouter />\n      <Toaster />\n    </>\n  );\n}\n\nexport default App;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/config/demoMode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/config/env.js","messages":[],"suppressedMessages":[{"ruleId":"jsdoc/require-jsdoc","severity":2,"message":"Missing JSDoc comment.","line":107,"column":14,"nodeType":"VariableDeclarator","messageId":"missingJsDoc","endLine":108,"endColumn":1,"fix":{"range":[4072,4072],"text":"/**\n *\n */\n"},"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/admin/components/DataClearPage.jsx","messages":[{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":54,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":54,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useAppState } from '../../../shared/contexts/app';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport { clearToken } from '../../../shared/services/auth/tokenService.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n * Administrative page component for clearing all application data and resetting to initial state.\n * \n * @returns {JSX.Element} Data clearing interface with confirmation and progress feedback\n */\nfunction DataClearPage() {\n  const navigate = useNavigate();\n  const { clearNavigationData: _clearNavigationData } = useAppState();\n  const [isClearing, setIsClearing] = useState(false);\n  const [cleared, setCleared] = useState(false);\n\n  const handleClearData = async () => {\n    setIsClearing(true);\n    \n    try {\n      // Clear all localStorage data\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && (key.startsWith('viking_') || key.startsWith('demo_viking_'))) {\n          keysToRemove.push(key);\n        }\n      }\n      \n      keysToRemove.forEach(key => localStorage.removeItem(key));\n      \n      // Clear session storage (tokens)\n      clearToken();\n      sessionStorage.clear();\n      \n      // Clear database if available\n      try {\n        await databaseService.initialize();\n        // Note: Database clearing would need specific implementation\n        // based on the database service capabilities\n      } catch (dbError) {\n        logger.warn('Could not clear database', { error: dbError.message }, LOG_CATEGORIES.APP);\n      }\n      \n      logger.info('All application data cleared successfully', {\n        clearedLocalStorageKeys: keysToRemove.length,\n      }, LOG_CATEGORIES.APP);\n      \n      setCleared(true);\n      \n      // Redirect to dashboard after a brief delay\n      setTimeout(() => {\n        // Don't clear navigation data - let it persist for proper state management\n        // Use React Router navigate instead of window.location to maintain state\n        navigate('/events', { replace: true });\n      }, 2000);\n      \n    } catch (error) {\n      logger.error('Failed to clear application data', { error: error.message }, LOG_CATEGORIES.ERROR);\n      setIsClearing(false);\n    }\n  };\n\n  const handleCancel = () => {\n    navigate('/events', { replace: true });\n  };\n\n  if (cleared) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-gray-50 p-4\">\n        <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm w-full max-w-md p-6 text-center\">\n          <div className=\"mb-4\">\n            <svg className=\"mx-auto h-12 w-12 text-green-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M5 13l4 4L19 7\" />\n            </svg>\n          </div>\n          <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Data Cleared Successfully</h2>\n          <p className=\"text-gray-600 mb-4\">\n            All application data has been cleared. You will be redirected to the dashboard.\n          </p>\n          <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-scout-blue mx-auto\"></div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-gray-50 p-4\">\n      <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm w-full max-w-md p-6\">\n        <div className=\"text-center mb-6\">\n          <div className=\"mb-4\">\n            <svg className=\"mx-auto h-12 w-12 text-red-600\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n            </svg>\n          </div>\n          <h2 className=\"text-lg font-semibold text-gray-900 mb-2\">Clear All Data</h2>\n          <p className=\"text-gray-600 mb-4\">\n            This will permanently delete all cached data including:\n          </p>\n          <ul className=\"text-left text-sm text-gray-600 mb-6 space-y-1\">\n            <li>• Cached events and attendance data</li>\n            <li>• Member information</li>\n            <li>• Authentication tokens</li>\n            <li>• Offline data and preferences</li>\n            <li>• Navigation history</li>\n          </ul>\n          <p className=\"text-sm text-red-600 font-medium mb-6\">\n            This action cannot be undone. You will need to re-authenticate and sync data again.\n          </p>\n        </div>\n\n        <div className=\"flex space-x-3\">\n          <button\n            onClick={handleCancel}\n            disabled={isClearing}\n            className=\"flex-1 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-scout-blue focus:border-scout-blue disabled:opacity-50\"\n          >\n            Cancel\n          </button>\n          <button\n            onClick={handleClearData}\n            disabled={isClearing}\n            className=\"flex-1 px-4 py-2 text-sm font-medium text-white bg-red-600 border border-transparent rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center\"\n          >\n            {isClearing ? (\n              <>\n                <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4 text-white\" fill=\"none\" viewBox=\"0 0 24 24\">\n                  <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n                  <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n                </svg>\n                Clearing...\n              </>\n            ) : (\n              'Clear All Data'\n            )}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default DataClearPage;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/admin/components/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/admin/hooks/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/admin/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/admin/services/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/components/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/hooks/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/hooks/useAuth.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":203,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":203,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":227,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":227,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":301,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":301,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":321,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":321,"endColumn":25},{"ruleId":"no-undef","severity":2,"message":"'Event' is not defined.","line":327,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":327,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":647,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":647,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":652,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":652,"endColumn":20}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file useAuth Hook\n * \n * Comprehensive authentication hook managing OAuth, token expiration, offline mode,\n * and cross-tab synchronization for the Vikings Event Management mobile app.\n * Handles OSM OAuth flow, token lifecycle, cached data access, and user state management.\n * \n * Features:\n * - OSM OAuth authentication flow with callback processing\n * - Proactive token expiration monitoring with user choice dialogs\n * - Offline mode support with cached data access\n * - Cross-tab authentication synchronization\n * - Comprehensive error handling and logging\n * - Sentry integration for monitoring and debugging\n * \n * @module useAuth\n * @version 2.3.7\n * @since 2.3.7\n * @author Vikings Event Management Team\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport * as Sentry from '@sentry/react';\nimport authService, { generateOAuthUrl, getAndClearReturnPath, isTokenExpired } from '../services/auth.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport databaseService from '../../../shared/services/storage/database.js';\n\n// Environment-specific configuration for token expiration monitoring\nconst TOKEN_CONFIG = {\n  // Default token expiration time when OAuth server doesn't provide expires_in\n  DEFAULT_EXPIRATION_SECONDS: 60 * 60, // 1 hour (OSM typical)\n  \n  // How often to check for token expiration (in milliseconds)\n  CHECK_INTERVAL_MS: import.meta.env.DEV ? 30 * 1000 : 60 * 1000, // 30s dev, 60s prod\n};\n\n// Helper function to broadcast auth changes across tabs\nconst broadcastAuthSync = () => {\n  try {\n    // Use localStorage to signal other tabs to refresh auth state\n    localStorage.setItem('auth_sync', String(Date.now()));\n    localStorage.removeItem('auth_sync');\n  } catch {\n    // localStorage not available, silently fail\n  }\n};\n\n/**\n * Custom authentication hook for Vikings Event Management mobile app\n * \n * Provides comprehensive authentication state management including OAuth flow,\n * token lifecycle management, offline mode support, and user session handling.\n * Integrates with OSM OAuth, handles token expiration gracefully, and maintains\n * cross-tab synchronization for seamless user experience.\n * \n * @returns {object} Authentication state and methods with properties:\n *   - isAuthenticated: Whether user has valid authentication\n *   - isLoading: Whether auth check is in progress\n *   - user: Current user information object or null\n *   - isBlocked: Whether application is blocked by OSM\n *   - isOfflineMode: Whether operating in offline mode with cached data\n *   - authState: Enhanced auth state ('authenticated'|'token_expired'|'cached_only'|'no_data')\n *   - lastSyncTime: Timestamp of last successful data sync or null\n *   - showTokenExpiredDialog: Whether token expiration dialog should be shown\n *   - hasCachedData: Whether cached offline data is available\n *   - login: Function to initiate OAuth login flow\n *   - logout: Function to log out and clear all data\n *   - setToken: Function to manually set authentication token\n *   - checkAuth: Function to refresh authentication state\n *   - handleReLogin: Function to handle re-authentication after token expiration\n *   - handleStayOffline: Function to continue in offline mode after token expiration\n * \n * @example\n * // Basic usage in component\n * const { isAuthenticated, isLoading, user, login, logout } = useAuth();\n * \n * if (isLoading) {\n *   return <LoadingSpinner />;\n * }\n * \n * if (!isAuthenticated) {\n *   return <LoginButton onClick={login} />;\n * }\n * \n * return <Dashboard user={user} onLogout={logout} />;\n * \n * @example\n * // Handle token expiration with user choice\n * const {\n *   showTokenExpiredDialog,\n *   hasCachedData,\n *   handleReLogin,\n *   handleStayOffline\n * } = useAuth();\n * \n * if (showTokenExpiredDialog) {\n *   return (\n *     <TokenExpiredDialog\n *       hasCachedData={hasCachedData}\n *       onReLogin={handleReLogin}\n *       onStayOffline={handleStayOffline}\n *     />\n *   );\n * }\n * \n * @example\n * // Monitor offline mode and sync status\n * const { isOfflineMode, authState, lastSyncTime } = useAuth();\n * \n * return (\n *   <StatusBar>\n *     {isOfflineMode && <OfflineIndicator />}\n *     {authState === 'cached_only' && <CacheOnlyWarning />}\n *     {lastSyncTime && <LastSyncDisplay time={lastSyncTime} />}\n *   </StatusBar>\n * );\n * \n * @example\n * // Route protection\n * const ProtectedRoute = ({ children }) => {\n *   const { isAuthenticated, isLoading, authState } = useAuth();\n * \n *   if (isLoading) return <LoadingScreen />;\n *   if (!isAuthenticated && authState === 'no_data') {\n *     return <Navigate to=\"/login\" />;\n *   }\n * \n *   return children;\n * };\n * \n * @hook\n * @since 2.3.7\n */\nexport function useAuth() {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [user, setUser] = useState(null);\n  const [isBlocked, setIsBlocked] = useState(false);\n  const [isOfflineMode, setIsOfflineMode] = useState(false);\n  const [authState, setAuthState] = useState('no_data'); // New: enhanced auth state\n  const [lastSyncTime, setLastSyncTime] = useState(null); // New: track last sync\n  \n  // Token expiration dialog state\n  const [showTokenExpiredDialog, setShowTokenExpiredDialog] = useState(false);\n  const [hasCachedData, setHasCachedData] = useState(false);\n  const [hasHandledExpiredToken, setHasHandledExpiredToken] = useState(false);\n\n\n  // Helper function to determine auth state based on cached data and tokens\n  const determineAuthState = useCallback(async (isAuth) => {\n    try {\n      // Check if we have any cached data\n      const cachedSections = await databaseService.getSections();\n      const hasCache = cachedSections && cachedSections.length > 0;\n      \n      // Get last sync time from cache (side effect kept for compatibility)\n      const lastSync = localStorage.getItem('viking_last_sync');\n      setLastSyncTime(lastSync);\n      \n      // Check if token has expired based on stored expiration time\n      const tokenExpired = isTokenExpired();\n      const hasValidToken = authService.isAuthenticated(); // This checks if token is valid (not expired)\n      \n      // Check if user was previously authenticated (has stored user info)\n      const hasPreviousAuth = !!authService.getUserInfo();\n      \n      if (isAuth && hasValidToken && !tokenExpired) {\n        return 'authenticated';\n      } else if (tokenExpired && hasCache) {\n        // Token expired but we have cached data - show sign in option\n        return 'token_expired';\n      } else if (hasCache && hasPreviousAuth) {\n        // User has cached data and was previously authenticated - likely token expired or cleared\n        return 'token_expired';\n      } else if (hasCache) {\n        return 'cached_only';\n      } else if (hasPreviousAuth && hasValidToken && !hasCache) {\n        // Has valid token and user info but no cached data - likely cache was cleared\n        // Clear user info to force fresh login\n        authService.clearUserInfo();\n        return 'no_data';\n      } else {\n        return 'no_data';\n      }\n    } catch (error) {\n      logger.warn('Error determining auth state', { error: error.message }, LOG_CATEGORIES.ERROR);\n      return isAuth ? 'authenticated' : 'no_data';\n    }\n  }, []);\n\n  // Check authentication status\n  const checkAuth = useCallback(async () => {\n    setIsLoading(true);\n    \n    try {\n      // FIRST: Check for OAuth callback parameters in URL with enhanced error handling\n      let urlParams;\n      let accessToken;\n      let tokenType;\n      let expiresIn;\n      \n      try {\n        urlParams = new URLSearchParams(window.location.search);\n        accessToken = urlParams.get('access_token');\n        tokenType = urlParams.get('token_type');\n        expiresIn = urlParams.get('expires_in');\n        \n        // Debug: Log all OAuth parameters we receive\n        if (accessToken && import.meta.env.DEV) {\n          const allParams = {};\n          for (const [key, value] of urlParams.entries()) {\n            if (key === 'access_token') {\n              allParams[key] = '[REDACTED]';\n            } else {\n              allParams[key] = value;\n            }\n          }\n          logger.debug('OAuth callback parameters received', allParams, LOG_CATEGORIES.AUTH);\n        }\n      } catch (urlError) {\n        // Redact sensitive query params before logging\n        let safeHref = '<unavailable>';\n        let safeSearch = '<unavailable>';\n        try {\n          const loc = typeof window !== 'undefined' ? window.location : null;\n          if (loc) {\n            const safeUrl = new URL(loc.href);\n            const redactKeys = ['access_token','token','token_type','id_token','refresh_token','auth','code'];\n            redactKeys.forEach(k => {\n              if (safeUrl.searchParams.has(k)) safeUrl.searchParams.set(k, '[REDACTED]');\n            });\n            safeHref = safeUrl.toString();\n            safeSearch = safeUrl.search;\n          }\n        } catch (redactError) {\n          // Silently fail - redaction is best effort\n        }\n        logger.error('Error parsing URL parameters in auth flow', {\n          error: urlError.message,\n          url: safeHref,\n          search: safeSearch,\n        }, LOG_CATEGORIES.ERROR);\n        \n        // Capture this specific error with enhanced context\n        Sentry.captureException(urlError, {\n          tags: {\n            section: 'auth',\n            operation: 'url_parsing',\n            category: 'auth',\n          },\n          contexts: {\n            url: {\n              full: safeHref,\n              search: safeSearch,\n              pathname: typeof window !== 'undefined' ? window.location.pathname : '<unavailable>',\n            },\n          },\n        });\n      }\n      \n      if (accessToken) {\n        try {\n          // Store the token via service to reset auth handler and Sentry context\n          authService.setToken(accessToken);\n          // Notify other tabs\n          broadcastAuthSync();\n          // Clear any expired/invalid token flags when storing a new token\n          sessionStorage.removeItem('token_expired');\n          sessionStorage.removeItem('token_invalid');\n          // Reset the handled flag when we get a new token\n          setHasHandledExpiredToken(false);\n          // Clear any stored token expiration choices\n          localStorage.removeItem('token_expiration_choice');\n          if (tokenType) {\n            sessionStorage.setItem('token_type', tokenType);\n          }\n          \n          // Store token expiration time for proactive monitoring\n          let expirationTime;\n          if (expiresIn) {\n            // Use provided expires_in parameter\n            expirationTime = Date.now() + (parseInt(expiresIn, 10) * 1000);\n            logger.info('Token expiration time stored from OAuth response', { \n              expiresInSeconds: expiresIn,\n              expiresAt: new Date(expirationTime).toISOString(),\n            }, LOG_CATEGORIES.AUTH);\n          } else {\n            // Fallback: OSM tokens typically expire after 1 hour\n            expirationTime = Date.now() + (TOKEN_CONFIG.DEFAULT_EXPIRATION_SECONDS * 1000);\n            logger.info('Token expiration time estimated (OSM default)', { \n              expiresInSeconds: TOKEN_CONFIG.DEFAULT_EXPIRATION_SECONDS,\n              expiresAt: new Date(expirationTime).toISOString(),\n              note: 'expires_in not provided by OAuth server, using configured default expiration',\n            }, LOG_CATEGORIES.AUTH);\n          }\n          \n          sessionStorage.setItem('token_expires_at', expirationTime.toString());\n          \n          // Clean the URL without reloading - this is a critical operation that can fail\n          try {\n            const url = new URL(window.location);\n            url.searchParams.delete('access_token');\n            url.searchParams.delete('token_type');\n            url.searchParams.delete('expires_in');\n            window.history.replaceState({}, '', url);\n            \n            logger.info('OAuth callback processed successfully', { \n              tokenStored: true,\n              urlCleaned: true,\n            }, LOG_CATEGORIES.AUTH);\n            \n            // Check if we should restore user to their previous page\n            const returnPath = getAndClearReturnPath();\n            if (returnPath && returnPath !== '/' && returnPath !== window.location.pathname + window.location.search + window.location.hash) {\n              logger.info('Restoring user to previous page after OAuth', { \n                returnPath,\n                currentPath: window.location.pathname + window.location.search + window.location.hash, \n              }, LOG_CATEGORIES.AUTH);\n              \n              // Use a small delay to ensure token processing is complete\n              setTimeout(() => {\n                window.history.replaceState({}, '', returnPath);\n                // Nudge Router to react to the URL change without a full reload\n                try {\n                  window.dispatchEvent(new window.PopStateEvent('popstate'));\n                } catch {\n                  window.dispatchEvent(new Event('popstate'));\n                }\n              }, 100);\n            }\n          } catch (urlCleanError) {\n            // URL cleaning failed but token is stored - continue\n            logger.warn('Failed to clean URL after OAuth callback, but token stored', { \n              error: urlCleanError.message,\n              tokenStored: true,\n            }, LOG_CATEGORIES.AUTH);\n            \n            Sentry.captureException(urlCleanError, {\n              level: 'warning',\n              tags: {\n                section: 'auth',\n                operation: 'url_cleanup',\n                category: 'auth',\n              },\n            });\n          }\n        } catch (tokenStorageError) {\n          // Token storage failed - this is critical\n          logger.error('Failed to store OAuth tokens', { \n            error: tokenStorageError.message,\n            hasAccessToken: !!accessToken,\n            hasTokenType: !!tokenType,\n          }, LOG_CATEGORIES.ERROR);\n          \n          Sentry.captureException(tokenStorageError, {\n            tags: {\n              section: 'auth',\n              operation: 'token_storage',\n              category: 'auth',\n            },\n            contexts: {\n              auth: {\n                hasAccessToken: !!accessToken,\n                hasTokenType: !!tokenType,\n                storageAvailable: (typeof window !== 'undefined' && typeof window.sessionStorage !== 'undefined'),\n              },\n            },\n          });\n        }\n        \n        // Try to get fresh user info from API after successful OAuth\n        try {\n          const userInfo = await authService.fetchUserInfoFromAPI();\n          if (userInfo) {\n            authService.setUserInfo(userInfo);\n            logger.info('User info fetched from API after OAuth', { userFirstname: userInfo.firstname }, LOG_CATEGORIES.AUTH);\n          }\n        } catch (userError) {\n          logger.warn('Could not fetch fresh user info after OAuth, will use cached data if available', { error: userError?.message }, LOG_CATEGORIES.AUTH);\n        }\n\n        // Trigger dashboard data sync after successful OAuth (fast)\n        try {\n          const { default: syncService } = await import('../../../shared/services/storage/sync.js');\n          logger.info('Starting dashboard data sync after successful OAuth', {}, LOG_CATEGORIES.AUTH);\n          await syncService.syncDashboardData();\n          logger.info('Dashboard data sync completed after OAuth', {}, LOG_CATEGORIES.AUTH);\n        } catch (syncError) {\n          logger.warn('Could not sync dashboard data after OAuth, using cached data', { error: syncError?.message }, LOG_CATEGORIES.AUTH);\n        }\n      }\n      // Check if blocked first\n      if (authService.isBlocked()) {\n        setIsBlocked(true);\n        setIsAuthenticated(false);\n        setUser(null);\n        setIsLoading(false);\n        return;\n      }\n      \n      // Clear blocked state if not blocked\n      setIsBlocked(false);\n\n      // Check if token exists (including expired tokens stored in sessionStorage)\n      const hasValidToken = authService.isAuthenticated();\n      const hasStoredToken = !!sessionStorage.getItem('access_token'); // Check for any stored token\n      const tokenExpired = isTokenExpired();\n      \n\n      \n      if (hasValidToken) {\n        // Valid token - normal authenticated state\n        setIsAuthenticated(true);\n        const userInfo = authService.getUserInfo();\n        setUser(userInfo);\n        setIsOfflineMode(false);\n        \n        \n        // Log successful authentication\n        Sentry.addBreadcrumb({\n          category: 'auth',\n          message: 'User authentication successful',\n          level: 'info',\n          data: {\n            hasUserInfo: !!userInfo,\n            userFullname: userInfo?.fullname || 'Unknown',\n            isOfflineMode: false,\n          },\n        });\n      } else if (hasStoredToken && tokenExpired) {\n        try {\n          const cachedSections = await databaseService.getSections();\n          const hasCached = cachedSections && cachedSections.length > 0;\n          if (hasCached) {\n            // Expired token but we have cached data - offline mode\n            setIsAuthenticated(true); // Keep authenticated for UI purposes\n            const userInfo = authService.getUserInfo();\n            setUser(userInfo);\n            setIsOfflineMode(true);\n            \n            // Log offline mode\n            Sentry.addBreadcrumb({\n              category: 'auth',\n              message: 'User authentication successful (offline mode)',\n              level: 'info',\n              data: {\n                hasUserInfo: !!userInfo,\n                userFullname: userInfo?.fullname || 'Unknown',\n                isOfflineMode: true,\n              },\n            });\n          } else {\n            // No cache → require re-auth\n            setIsAuthenticated(false);\n            setUser(null);\n            setIsOfflineMode(false);\n          }\n        } catch {\n          // On error determining cache, prefer safe default: not authenticated\n          setIsAuthenticated(false);\n          setUser(null);\n          setIsOfflineMode(false);\n        }\n      } else {\n        // No token exists - show login\n        setIsAuthenticated(false);\n        setUser(null);\n        setIsOfflineMode(false);\n      }\n      \n      // Determine and set the enhanced auth state\n      // For authState determination, consider both valid and expired tokens as \"having a token\"\n      const currentHasToken = hasValidToken || (hasStoredToken && tokenExpired);\n      const newAuthState = await determineAuthState(currentHasToken);\n      setAuthState(newAuthState);\n      \n    } catch (error) {\n      logger.error('Error checking authentication', { error: error.message }, LOG_CATEGORIES.ERROR);\n      setIsAuthenticated(false);\n      setUser(null);\n      setAuthState('no_data'); // Fallback to no_data state on error\n      \n      // Log authentication error\n      Sentry.captureException(error, {\n        tags: {\n          section: 'auth',\n          operation: 'check_authentication',\n        },\n        extra: {\n          hasToken: !!authService.getToken(),\n          isBlocked: authService.isBlocked(),\n        },\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [determineAuthState]);\n\n  // Login function\n  const login = useCallback(() => {\n    const oauthUrl = generateOAuthUrl();\n    window.location.href = oauthUrl;\n  }, []);\n\n  // Logout function\n  const logout = useCallback(async () => {\n    authService.logout();\n    broadcastAuthSync();\n    setIsAuthenticated(false);\n    setUser(null);\n    setIsBlocked(false);\n    \n    // Clear token expiration choice so user gets the dialog again if they log back in\n    localStorage.removeItem('token_expiration_choice');\n    setHasHandledExpiredToken(false);\n    \n    // Recalculate auth state after logout\n    const newAuthState = await determineAuthState(false);\n    setAuthState(newAuthState);\n  }, [determineAuthState]);\n\n  // Set token (for OAuth callback handling)\n  const setToken = useCallback((token) => {\n    authService.setToken(token);\n    broadcastAuthSync();\n    checkAuth(); // Recheck auth after setting token\n  }, [checkAuth]);\n\n  // Check auth on mount and when storage changes\n  useEffect(() => {\n    let mounted = true;\n    \n    \n    const initializeAuth = async () => {\n      if (!mounted) return; // Prevent duplicate calls in StrictMode\n      \n      // Check if user has already made a choice about expired token\n      const existingChoice = localStorage.getItem('token_expiration_choice');\n      if (existingChoice) {\n        setHasHandledExpiredToken(true);\n      }\n      \n      await checkAuth();\n    };\n    \n    initializeAuth();\n\n    // Listen for storage changes (in case user logs out in another tab)\n    const handleStorageChange = (e) => {\n      if (!mounted) return;\n      if (e.storageArea === localStorage && (e.key === 'auth_sync' || e.key === 'osm_blocked')) {\n        checkAuth();\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    return () => {\n      mounted = false;\n      window.removeEventListener('storage', handleStorageChange);\n    };\n  }, [checkAuth]);\n\n  // Listen for sync completion to update lastSyncTime\n  useEffect(() => {\n    let cleanupFn = null;\n    \n    const handleSyncComplete = (syncStatus) => {\n      if (syncStatus.status === 'completed') {\n        // Use the timestamp from sync status, or get from localStorage as fallback\n        const timestamp = syncStatus.timestamp || localStorage.getItem('viking_last_sync');\n        setLastSyncTime(timestamp);\n        logger.debug('Updated lastSyncTime after sync completion', { timestamp }, LOG_CATEGORIES.AUTH);\n      }\n    };\n\n    // Import and setup sync listener\n    const setupSyncListener = async () => {\n      try {\n        const { default: syncService } = await import('../../../shared/services/storage/sync.js');\n        syncService.addSyncListener(handleSyncComplete);\n        \n        return () => {\n          syncService.removeSyncListener(handleSyncComplete);\n        };\n      } catch (error) {\n        logger.error('Failed to setup sync listener in useAuth', { error: error.message }, LOG_CATEGORIES.ERROR);\n        return null;\n      }\n    };\n\n    setupSyncListener().then((cleanup) => {\n      cleanupFn = cleanup;\n    });\n\n    return () => {\n      if (cleanupFn) {\n        cleanupFn();\n      }\n    };\n  }, []);\n\n  // Helper function to check cached data and show expiration dialog\n  const checkAndShowExpirationDialog = useCallback(async () => {\n    const hasStoredToken = !!sessionStorage.getItem('access_token');\n    const tokenExpired = isTokenExpired();\n    const hasStoredChoice = localStorage.getItem('token_expiration_choice');\n    \n    if (hasStoredToken && tokenExpired && !showTokenExpiredDialog && !hasHandledExpiredToken && !hasStoredChoice) {\n      logger.info('Token expired - showing user choice dialog', {}, LOG_CATEGORIES.AUTH);\n      \n      // Check if we have cached data for user choice\n      try {\n        const cachedSections = await databaseService.getSections();\n        const hasCached = cachedSections && cachedSections.length > 0;\n        setHasCachedData(hasCached);\n        \n        // Show the user choice dialog instead of automatically switching to offline\n        setShowTokenExpiredDialog(true);\n        \n        logger.info('Token expired - awaiting user choice', { \n          hasCachedData: hasCached, \n        }, LOG_CATEGORIES.AUTH);\n      } catch (error) {\n        logger.warn('Could not check cached data after token expiration', { \n          error: error.message, \n        }, LOG_CATEGORIES.ERROR);\n        // Still show dialog even if cached check fails\n        setShowTokenExpiredDialog(true);\n      }\n    }\n  }, [showTokenExpiredDialog, hasHandledExpiredToken]);\n\n  // Check for immediate token expiration on auth state changes\n  useEffect(() => {\n    if (authState === 'token_expired') {\n      checkAndShowExpirationDialog();\n    }\n  }, [authState, checkAndShowExpirationDialog]);\n\n  // Periodic token expiration monitoring\n  useEffect(() => {\n    if (!sessionStorage.getItem('access_token')) {\n      return; // No token to monitor\n    }\n\n    // Check token expiration every minute (as safety net)\n    const intervalId = setInterval(async () => {\n      await checkAndShowExpirationDialog();\n    }, TOKEN_CONFIG.CHECK_INTERVAL_MS);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [authState, showTokenExpiredDialog, hasHandledExpiredToken, checkAndShowExpirationDialog]);\n\n  // Handler for when user chooses to re-login after token expiration\n  const handleReLogin = useCallback(async () => {\n    logger.info('User chose to re-login after token expiration', {}, LOG_CATEGORIES.AUTH);\n    setShowTokenExpiredDialog(false);\n    setHasHandledExpiredToken(true);\n    // Store the choice so it persists across refreshes\n    localStorage.setItem('token_expiration_choice', 'relogin');\n    \n    try {\n      // Generate OAuth URL with return path storage\n      const oauthUrl = generateOAuthUrl(true);\n      \n      logger.info('Redirecting to OAuth for re-authentication', { \n        storedReturnPath: true, \n      }, LOG_CATEGORIES.AUTH);\n      \n      // Redirect to OAuth\n      window.location.href = oauthUrl;\n    } catch (error) {\n      logger.error('Error redirecting to OAuth after token expiration', { \n        error: error.message, \n      }, LOG_CATEGORIES.ERROR);\n    }\n  }, []);\n\n  // Handler for when user chooses to stay offline after token expiration\n  const handleStayOffline = useCallback(async () => {\n    logger.info('User chose to stay offline after token expiration', {}, LOG_CATEGORIES.AUTH);\n    setShowTokenExpiredDialog(false);\n    setHasHandledExpiredToken(true);\n    // Store the choice so it persists across refreshes\n    localStorage.setItem('token_expiration_choice', 'offline');\n    \n    try {\n      // Update auth state to reflect token expiration and offline mode\n      const hadToken = !!sessionStorage.getItem('access_token');\n      const newAuthState = await determineAuthState(hadToken);\n      setAuthState(newAuthState);\n      setIsOfflineMode(true);\n      // Mirror offline branch in checkAuth\n      setIsAuthenticated(true);\n      const userInfo = authService.getUserInfo();\n      setUser(userInfo);\n      \n      logger.info('Switched to offline mode per user choice', { \n        newAuthState,\n        hasCachedData: hasCachedData, \n      }, LOG_CATEGORIES.AUTH);\n    } catch (error) {\n      logger.error('Error switching to offline mode', { \n        error: error.message, \n      }, LOG_CATEGORIES.ERROR);\n    }\n  }, [determineAuthState, hasCachedData]);\n\n  return {\n    isAuthenticated,\n    isLoading,\n    user,\n    isBlocked,\n    isOfflineMode,\n    authState,        // New: enhanced auth state\n    lastSyncTime,     // New: last sync timestamp\n    \n    // Token expiration dialog\n    showTokenExpiredDialog,\n    hasCachedData,\n    handleReLogin,\n    handleStayOffline,\n    \n    login,\n    logout,\n    setToken,\n    checkAuth,\n  };\n}\n\nexport default useAuth;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/hooks/useRouteGuards.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/services/auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/services/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/auth/services/simpleAuthHandler.js","messages":[{"ruleId":"jsdoc/no-undefined-types","severity":2,"message":"The type 'Response' is undefined.","line":60,"column":1,"nodeType":"Block","endLine":60,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Simple Authentication Error Handler\n * \n * Provides minimal authentication error handling to prevent multiple 403/401 errors\n * and provide clear UX feedback. Acts as a circuit breaker pattern for API calls\n * when authentication failures occur.\n * \n * @module simpleAuthHandler\n * @version 2.3.7\n * @since 2.3.7\n * @author Vikings Event Management Team\n */\n\n/**\n * Simple authentication error handler implementing circuit breaker pattern\n * \n * Tracks authentication failures across API calls and prevents cascading errors\n * by blocking subsequent API calls after the first authentication failure. \n * Provides callback mechanism for components to react to auth failures.\n * \n * @class SimpleAuthHandler\n * @example\n * // Check before making API call\n * if (authHandler.shouldMakeAPICall()) {\n *   const response = await fetch('/api/data');\n *   const isAuthOk = authHandler.handleAPIResponse(response, 'getData');\n *   if (!isAuthOk) {\n *     // Handle auth failure\n *   }\n * }\n * \n * @example\n * // Set up auth error callback\n * authHandler.onAuthError = () => {\n *   notifyError('Authentication failed. Please log in again.');\n *   navigate('/login');\n * };\n * \n * @example\n * // Reset after new token\n * authHandler.reset();\n * const token = await getNewToken();\n * // Can now make API calls again\n * \n * @since 2.3.7\n */\nclass SimpleAuthHandler {\n  constructor() {\n    this.hasShownAuthError = false;\n    this.onAuthError = null; // Callback for components to react to auth failures\n  }\n\n  /**\n   * Handle API response and track authentication failures\n   * \n   * Examines HTTP response status codes for authentication errors (401/403) and\n   * implements circuit breaker logic to prevent cascading auth failures. Sets\n   * internal state to block future API calls and triggers auth error callback.\n   * \n   * @param {Response} response - Fetch response object from API call\n   * @param {string} _apiName - Name of the API call for logging (unused in current implementation)\n   * @returns {boolean} True if authentication is valid, false if auth failed\n   * \n   * @example\n   * // Check API response after fetch\n   * const response = await fetch('/api/sections', { headers: { Authorization: `Bearer ${token}` } });\n   * const isAuthOk = authHandler.handleAPIResponse(response, 'getSections');\n   * if (!isAuthOk) {\n   *   // Authentication failed - stop making API calls\n   *   return null;\n   * }\n   * const data = await response.json();\n   * \n   * @example\n   * // Wrapper function for API calls\n   * const apiCall = async (url, options, apiName) => {\n   *   const response = await fetch(url, options);\n   *   if (!authHandler.handleAPIResponse(response, apiName)) {\n   *     throw new Error('Authentication failed');\n   *   }\n   *   return response.json();\n   * };\n   * \n   * @since 2.3.7\n   */\n  handleAPIResponse(response, _apiName) {\n    if (response.status === 401 || response.status === 403) {\n      if (!this.hasShownAuthError) {\n        this.hasShownAuthError = true;\n        // Authentication failed - blocked further API calls this session\n        \n        // Notify components about auth failure\n        if (this.onAuthError) {\n          this.onAuthError();\n        }\n      }\n      return false; // Signal auth failure\n    }\n    return true; // Auth OK\n  }\n\n  /**\n   * Check if we should make an API call (circuit breaker pattern)\n   * \n   * Determines whether it's safe to make API calls based on previous authentication\n   * failures. Implements circuit breaker pattern to prevent cascading failures\n   * when authentication has already failed in the current session.\n   * \n   * @returns {boolean} True if safe to make API calls, false if blocked due to auth failure\n   * \n   * @example\n   * // Check before expensive API operation\n   * if (authHandler.shouldMakeAPICall()) {\n   *   const data = await loadSectionsData();\n   *   setState(data);\n   * } else {\n   *   console.log('Skipping API call - auth already failed');\n   *   setState(cachedData);\n   * }\n   * \n   * @example\n   * // Conditional data fetching\n   * const fetchUserData = async () => {\n   *   if (!authHandler.shouldMakeAPICall()) {\n   *     return getCachedUserData();\n   *   }\n   *   \n   *   try {\n   *     const response = await fetch('/api/user');\n   *     if (authHandler.handleAPIResponse(response, 'getUser')) {\n   *       return await response.json();\n   *     }\n   *   } catch (error) {\n   *     console.error('API call failed:', error);\n   *   }\n   *   \n   *   return getCachedUserData();\n   * };\n   * \n   * @since 2.3.7\n   */\n  shouldMakeAPICall() {\n    if (!this.hasShownAuthError) {\n      return true;\n    }\n    // Skipping API call - authentication already failed this session\n    return false;\n  }\n\n  /**\n   * Reset authentication error state\n   * \n   * Clears the circuit breaker state to allow API calls again. Should be called\n   * when user obtains a new authentication token, reconnects, or when starting\n   * a fresh session. Enables recovery from authentication failures.\n   * \n   * @example\n   * // Reset after successful login\n   * const handleLogin = async (token) => {\n   *   setToken(token);\n   *   authHandler.reset(); // Clear previous auth failures\n   *   notifySuccess('Login successful');\n   * };\n   * \n   * @example\n   * // Reset when switching demo mode\n   * const enableDemoMode = () => {\n   *   authHandler.reset(); // Allow API calls in demo mode\n   *   setDemoMode(true);\n   * };\n   * \n   * @example\n   * // Reset on app initialization\n   * useEffect(() => {\n   *   if (hasValidToken()) {\n   *     authHandler.reset(); // Start fresh session\n   *   }\n   * }, []);\n   * \n   * @since 2.3.7\n   */\n  reset() {\n    // Resetting auth error state\n    this.hasShownAuthError = false;\n  }\n\n  /**\n   * Check if authentication has failed this session\n   * \n   * Returns the current circuit breaker state indicating whether authentication\n   * errors have occurred. Used to determine if the application should show\n   * offline mode indicators or prevent certain user actions.\n   * \n   * @returns {boolean} True if authentication has failed in current session\n   * \n   * @example\n   * // Show offline indicator\n   * const StatusBar = () => (\n   *   <div className=\"status-bar\">\n   *     {authHandler.hasAuthFailed() && (\n   *       <div className=\"offline-warning\">\n   *         Operating in offline mode\n   *       </div>\n   *     )}\n   *   </div>\n   * );\n   * \n   * @example\n   * // Disable save operations when offline\n   * const handleSave = () => {\n   *   if (authHandler.hasAuthFailed()) {\n   *     notifyWarning('Cannot save while offline');\n   *     return;\n   *   }\n   *   performSave();\n   * };\n   * \n   * @example\n   * // Conditional feature access\n   * const canAccessFeature = () => {\n   *   return isAuthenticated() && !authHandler.hasAuthFailed();\n   * };\n   * \n   * @since 2.3.7\n   */\n  hasAuthFailed() {\n    return this.hasShownAuthError;\n  }\n}\n\n// Export singleton instance\nexport const authHandler = new SimpleAuthHandler();\n\nexport default authHandler;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/AttendanceGrid.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.data\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.data\n */\nfunction AttendanceGrid({ data }) {\n  const getStatusColor = (status) => {\n    switch (status) {\n    case 'attending':\n      return 'text-green-800';\n    case 'notAttending':\n      return 'text-red-800';\n    case 'invited':\n      return 'text-scout-blue';\n    case 'notInvited':\n      return 'text-gray-800';\n    default:\n      return 'text-gray-800';\n    }\n  };\n\n  const StatusCell = ({ count, status }) => (\n    <td\n      className={`px-3 py-2 text-center text-sm font-medium ${getStatusColor(status)}`}\n      data-oid=\"r-rv-8e\"\n    >\n      {count}\n    </td>\n  );\n\n  const PersonTypeRow = ({ type, typeData }) => (\n    <tr className=\"border-b border-gray-200\" data-oid=\"wcrvaky\">\n      <td\n        className=\"px-3 py-2 text-sm font-medium text-gray-900 bg-gray-50\"\n        data-oid=\"ipjjxor\"\n      >\n        {type}\n      </td>\n      <StatusCell\n        count={typeData.attending}\n        status=\"attending\"\n        data-oid=\"bfb88h_\"\n      />\n\n      <StatusCell\n        count={typeData.notAttending}\n        status=\"notAttending\"\n        data-oid=\"k37_.00\"\n      />\n\n      <StatusCell\n        count={typeData.invited}\n        status=\"invited\"\n        data-oid=\"apl7abw\"\n      />\n\n      <StatusCell\n        count={typeData.notInvited}\n        status=\"notInvited\"\n        data-oid=\"64xxv1a\"\n      />\n    </tr>\n  );\n\n  const getTotalByStatus = (status) => {\n    return Object.values(data).reduce(\n      (total, typeData) => total + typeData[status],\n      0,\n    );\n  };\n\n  return (\n    <div\n      className=\"overflow-hidden\"\n      data-oid=\"cvq.bwo\"\n    >\n      <table className=\"min-w-full divide-y divide-gray-200\" data-oid=\"epucw:u\">\n        <thead className=\"bg-gray-50\" data-oid=\"pd8zbk-\">\n          <tr data-oid=\"_3hhftv\">\n            <th\n              className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\"\n              data-oid=\"7is:5yj\"\n            >\n              Section\n            </th>\n            <th\n              className=\"px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider\"\n              data-oid=\"013_x-k\"\n            >\n              <span data-oid=\"19qz455\">Yes</span>\n            </th>\n            <th\n              className=\"px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider\"\n              data-oid=\"-xiy5up\"\n            >\n              <span data-oid=\"_5eyt2i\">No</span>\n            </th>\n            <th\n              className=\"px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider\"\n              data-oid=\"zbtmyf3\"\n            >\n              <span data-oid=\":kaigd-\">Invited</span>\n            </th>\n            <th\n              className=\"px-3 py-2 text-center text-xs font-medium text-gray-500 uppercase tracking-wider\"\n              data-oid=\"-_rgu-m\"\n            >\n              <span data-oid=\"wv3vvfh\">Not Invited</span>\n            </th>\n          </tr>\n        </thead>\n        <tbody className=\"bg-white divide-y divide-gray-200\" data-oid=\"g60igun\">\n          {Object.entries(data).map(([type, typeData]) => (\n            <PersonTypeRow\n              key={type}\n              type={type}\n              typeData={typeData}\n              data-oid=\"3hj1pvm\"\n            />\n          ))}\n\n          {/* Totals row */}\n          <tr className=\"bg-gray-50 font-medium\" data-oid=\"l-hkkjw\">\n            <td className=\"px-3 py-2 text-sm text-gray-900\" data-oid=\"t:8zsrm\">\n              Total\n            </td>\n            <td\n              className=\"px-3 py-2 text-center text-sm text-green-800\"\n              data-oid=\"bf5k-5c\"\n            >\n              {getTotalByStatus('attending')}\n            </td>\n            <td\n              className=\"px-3 py-2 text-center text-sm text-red-800\"\n              data-oid=\"o1hy_fp\"\n            >\n              {getTotalByStatus('notAttending')}\n            </td>\n            <td\n              className=\"px-3 py-2 text-center text-sm text-yellow-800\"\n              data-oid=\"m1b8uey\"\n            >\n              {getTotalByStatus('invited')}\n            </td>\n            <td\n              className=\"px-3 py-2 text-center text-sm text-gray-800\"\n              data-oid=\".66ttp.\"\n            >\n              {getTotalByStatus('notInvited')}\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nexport default AttendanceGrid;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/CampGroupCard.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":27,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { cn } from '../../../shared/utils/cn';\nimport DraggableMember from './DraggableMember.jsx';\n\n/**\n * CampGroupCard - Individual card component for displaying camp group members\n * Shows group name, leaders/young leaders in header, young people in body\n * Enhanced with drag & drop functionality for moving members between groups\n * \n * Error Handling Contract:\n * - onMemberMove callback handles all auth/network failures with user-facing error messages\n * - Provides contextual error information including from/to group details\n * - Implements optimistic UI updates with rollback on failure\n * - Uses toast notifications for consistent error UX across the application\n * \n * @param {object} props - Component props\n * @param {object} props.group - Group data with name, leaders, youngPeople arrays\n * @param {Function} props.onMemberClick - Optional callback when member is clicked\n * @param {Function} props.onMemberMove - Callback when a member is dropped into this group\n *   Expected to handle failures gracefully with user notifications and state rollback\n * @param {Function} props.onDragStart - Callback when drag operation starts from this group\n * @param {Function} props.onDragEnd - Callback when drag operation ends\n * @param {boolean} props.isDragInProgress - Whether any drag operation is in progress\n * @param {string} props.draggingMemberId - ID of member currently being dragged\n * @param {boolean} props.dragDisabled - Whether drag & drop functionality is disabled\n * @param {string} props.className - Additional CSS classes\n */\nfunction CampGroupCard({\n  group,\n  onMemberClick,\n  onMemberMove,\n  onDragStart,\n  onDragEnd,\n  isDragInProgress = false,\n  draggingMemberId = null,\n  dragDisabled = false,\n  className = '',\n}) {\n  // Drop zone state\n  const [isDragOver, setIsDragOver] = useState(false);\n  const [canDrop, setCanDrop] = useState(false);\n  const cardRef = useRef(null);\n\n  const { name, leaders = [], youngPeople = [] } = group || {};\n\n  const handleMemberClick = (member) => {\n    if (onMemberClick && typeof onMemberClick === 'function') {\n      onMemberClick(member);\n    }\n  };\n\n  // Drag and drop handlers\n  const handleDragOver = (e) => {\n    e.preventDefault(); // Allow drop\n    if (!isDragOver) {\n      setIsDragOver(true);\n    }\n    // Check if drop is acceptable to show correct visual feedback\n    let acceptable = false;\n    if (!dragDisabled) {\n      try {\n        const dragData = JSON.parse(\n          e.dataTransfer.getData('application/json') || '{}',\n        );\n        // Don't allow dropping on the same group\n        acceptable = String(dragData.fromGroupNumber) !== String(group.number);\n      } catch (_) {\n        // If we can't parse drag data, assume it's acceptable for visual feedback\n        acceptable = true;\n      }\n    }\n    setCanDrop(acceptable);\n    e.dataTransfer.dropEffect = acceptable ? 'move' : 'none';\n  };\n\n  const handleDragLeave = (e) => {\n    // Only clear if we're actually leaving the drop zone\n    // (not just moving to a child element)\n    const rect = e.currentTarget.getBoundingClientRect();\n    const x = e.clientX;\n    const y = e.clientY;\n    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n      setIsDragOver(false);\n      setCanDrop(false);\n    }\n  };\n\n  const handleDrop = useCallback(async (e) => {\n    e.preventDefault();\n    setIsDragOver(false);\n    setCanDrop(false);\n    // Don't process drops if dragging is disabled\n    if (dragDisabled) {\n      return;\n    }\n    if (!onMemberMove) {\n      return;\n    }\n    \n    let dragData;\n    try {\n      // Handle both desktop drag/drop and mobile touch drop\n      if (e.type === 'mobile-drop') {\n        dragData = e.detail;\n      } else {\n        dragData = JSON.parse(e.dataTransfer.getData('application/json'));\n      }\n\n\n      // Don't allow dropping on the same group\n      if (String(dragData.fromGroupNumber) === String(group.number)) {\n        return;\n      }\n\n      // Note: We proceed with the move and let the API handler deal with auth/network issues\n      // This allows for proper error handling and user feedback through the onMemberMove callback\n      // Since only Young People are displayed and draggable (per DRAGGABLE_MEMBER_TYPES),\n      // we can safely create a member object with person_type: 'Young People'\n      // Prefer dragData.member when available (complete object from drag source)\n      let member;\n      if (dragData.member) {\n        // Use complete member object from drag data\n        member = dragData.member;\n      } else {\n        // Fall back to constructing minimal object from dragData fields\n        member = {\n          scoutid: dragData.memberId,\n          name: dragData.memberName,\n          person_type: 'Young People',\n          sectionid: dragData.sectionid,\n        };\n        \n        // Last resort: lookup in drop target group for missing fields (may not find anything)\n        const originalMember = [...(group.youngPeople || [])].find(m => \n          String(m.scoutid) === String(dragData.memberId),\n        );\n        if (originalMember) {\n          member = { ...member, ...originalMember };\n        }\n      }\n      \n      // TODO: Ensure DraggableMember emits a full member object on mobile drags \n      // so dragData.member is provided to the drop handler\n\n\n      // Call the move handler\n      onMemberMove({\n        member: member,\n        fromGroupNumber: dragData.fromGroupNumber,\n        fromGroupName: dragData.fromGroupName,\n        toGroupNumber: group.number,\n        toGroupName: group.name,\n      });\n    } catch (error) {\n      // Silently ignore malformed drag data - validation happens during drop\n    }\n  }, [dragDisabled, onMemberMove, group]);\n\n  // Add mobile drop event listener\n  useEffect(() => {\n    const cardElement = cardRef.current;\n    if (!cardElement) return;\n\n    const handleMobileDrop = (e) => {\n      handleDrop(e);\n    };\n\n    cardElement.addEventListener('mobile-drop', handleMobileDrop);\n    \n    return () => {\n      cardElement.removeEventListener('mobile-drop', handleMobileDrop);\n    };\n  }, [handleDrop]);\n\n  if (!group) {\n    return null;\n  }\n\n  const MemberName = ({ member }) => (\n    <span\n      className={`text-sm break-words ${\n        member.SignedOutBy || member.SignedOutWhen || member.vikingEventData?.SignedOutBy || member.vikingEventData?.SignedOutWhen ? 'text-gray-400' : ''\n      } ${onMemberClick ? 'cursor-pointer hover:text-scout-blue hover:underline' : ''}`}\n      onClick={() => handleMemberClick(member)}\n      title={`${member.firstname} ${member.lastname}`}\n    >\n      {member.firstname} {member.lastname}\n    </span>\n  );\n\n\n  return (\n    <div\n      ref={cardRef}\n      className={cn(\n        'bg-white rounded-lg border border-gray-200 shadow-sm camp-group-card transition-all duration-200 w-full',\n        isDragInProgress && 'drop-zone-available',\n        isDragOver && canDrop && 'bg-scout-blue/10 border-scout-blue border-2 shadow-lg',\n        isDragOver && !canDrop && 'bg-red-50 border-red-300 border-2',\n        className,\n      )}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      data-drop-zone=\"true\"\n      data-group-number={group.number}\n    >\n      {/* Header with group name and leaders */}\n      <div className={cn('px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg pb-2')}>\n        <div className=\"flex items-center justify-between\">\n          <div className=\"min-w-0 flex-1\">\n            <h3 className=\"text-lg font-semibold text-gray-900 break-words whitespace-normal\">\n              {name} <span className=\"text-base font-medium text-gray-600\">({youngPeople.length})</span>\n            </h3>\n          </div>\n        </div>\n\n        {/* Leaders section */}\n        {leaders.length > 0 && (\n          <div className=\"mt-2 pt-2 border-t border-gray-100\">\n            <div className=\"flex items-center gap-1 mb-1\">\n              <svg\n                className=\"w-3 h-3 text-scout-purple\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n              <span className=\"text-xs font-medium text-gray-700\">\n                Leaders ({leaders.length})\n              </span>\n            </div>\n\n            <div className=\"space-y-1\">\n              {leaders.map((leader) => (\n                <div key={leader.scoutid} className=\"flex items-center gap-1\">\n                  <span\n                    className={cn(\n                      'inline-flex items-center font-medium rounded-full px-2.5 py-0.5 text-xs flex-shrink-0',\n                      leader.person_type === 'Leaders'\n                        ? 'bg-scout-purple text-white'\n                        : 'bg-scout-blue text-white',\n                    )}\n                  >\n                    {leader.person_type === 'Leaders' ? 'L' : 'YL'}\n                  </span>\n                  <div className=\"min-w-0 flex-1\">\n                    <MemberName member={leader} />\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Body with young people */}\n      <div className={cn('p-4 pt-0')}>\n        {youngPeople.length > 0 ? (\n          <div>\n            <div className=\"flex items-center gap-1 mb-2\">\n              <svg\n                className=\"w-3 h-3 text-scout-green\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n              <span className=\"text-xs font-medium text-gray-700\">\n                Young People ({youngPeople.length})\n              </span>\n            </div>\n\n            <div className=\"grid grid-cols-2 gap-2\">\n              {youngPeople.map((youngPerson) => (\n                <DraggableMember\n                  key={youngPerson.scoutid}\n                  member={youngPerson}\n                  group={group}\n                  onMemberClick={handleMemberClick}\n                  onDragStart={onDragStart}\n                  onDragEnd={onDragEnd}\n                  isDragging={\n                    String(draggingMemberId) === String(youngPerson.scoutid)\n                  }\n                  disabled={dragDisabled}\n                />\n              ))}\n            </div>\n          </div>\n        ) : (\n          <div\n            className={`\n            text-center py-4 text-gray-500 transition-all\n            ${isDragInProgress ? 'py-8 border-2 border-dashed border-gray-300 bg-gray-50/50 rounded-lg' : ''}\n          `}\n          >\n            <svg\n              className=\"mx-auto h-8 w-8 text-gray-400 mb-2\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\"\n              stroke=\"currentColor\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-1a5 5 0 11-5 5 5 5 0 015-5z\"\n              />\n            </svg>\n            <p className=\"text-sm\">\n              {isDragInProgress\n                ? 'Drop member here'\n                : 'No young people assigned'}\n            </p>\n          </div>\n        )}\n      </div>\n\n      {/* Footer with additional info if needed */}\n      {leaders.length === 0 && youngPeople.length === 0 && (\n        <div className={cn('px-4 py-3 border-t border-gray-200 bg-gray-50 rounded-b-lg text-center text-gray-500 text-sm')}>\n          No members assigned to this group\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default CampGroupCard;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/CampGroupsView.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":12,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"summaryStats\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"pendingMoves\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"recentlyCompletedMoves\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":113,"column":1,"nodeType":"Block","endLine":123,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"props.vikingEventData\" description.","line":122,"column":1,"nodeType":"Block","endLine":122,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":378,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":378,"endColumn":19}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo } from 'react';\nimport { Alert } from '../../../shared/components/ui';\nimport CampGroupCard from './CampGroupCard.jsx';\nimport { MemberDetailModal } from '../../../shared/components/ui';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport { isMobileLayout } from '../../../shared/utils/platform.js';\nimport { assignMemberToCampGroup, extractFlexiRecordContext } from '../services/campGroupAllocationService.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\nimport { notifyError, notifyInfo, notifySuccess } from '../../../shared/utils/notifications.js';\nimport databaseService from '../../../shared/services/storage/database.js';\n\n/**\n * Simple function to organize summaryStats by camp groups\n * Similar to RegisterTab's approach - just group the pre-processed data\n * @param summaryStats\n * @param pendingMoves\n * @param recentlyCompletedMoves\n */\nfunction organizeByCampGroups(summaryStats, pendingMoves = new Map(), recentlyCompletedMoves = new Map()) {\n  if (!summaryStats || summaryStats.length === 0) {\n    return {\n      groups: {},\n      summary: {\n        totalGroups: 0,\n        totalMembers: 0,\n        hasUnassigned: false,\n        vikingEventDataAvailable: false,\n      },\n    };\n  }\n\n  const groups = {};\n  let totalMembers = 0;\n  \n  // Filter to only young people (exclude leaders like RegisterTab does)\n  const youngPeople = summaryStats.filter(member => \n    member.person_type !== 'Leaders' && member.person_type !== 'Young Leaders',\n  );\n\n  // Apply optimistic updates to the data\n  const allMoves = new Map([...pendingMoves, ...recentlyCompletedMoves]);\n  \n  youngPeople.forEach((member) => {\n    let campGroup = member.vikingEventData?.CampGroup;\n    \n    // Check if this member has a pending or completed move\n    for (const [, moveData] of allMoves.entries()) {\n      if (moveData && moveData.member && moveData.member.scoutid === member.scoutid) {\n        // Apply the optimistic update\n        campGroup = moveData.toGroupNumber === 'Unassigned' ? '' : moveData.toGroupNumber;\n        break;\n      }\n    }\n    \n    const groupName = campGroup ? `Group ${campGroup}` : 'Group Unassigned';\n    \n    if (!groups[groupName]) {\n      groups[groupName] = {\n        name: groupName,\n        number: campGroup || 'Unassigned',\n        youngPeople: [],\n        totalMembers: 0,\n      };\n    }\n    \n    // Create updated member with optimistic camp group data\n    const memberWithOptimisticUpdate = {\n      ...member,\n      vikingEventData: {\n        ...member.vikingEventData,\n        CampGroup: campGroup,\n      },\n    };\n    \n    groups[groupName].youngPeople.push(memberWithOptimisticUpdate);\n    groups[groupName].totalMembers++;\n    totalMembers++;\n  });\n  \n  // Sort groups by number (Unassigned goes last)\n  const sortedGroups = {};\n  Object.keys(groups)\n    .sort((a, b) => {\n      if (a === 'Group Unassigned') return 1;\n      if (b === 'Group Unassigned') return -1;\n      const aNum = parseInt(a.replace('Group ', '')) || 0;\n      const bNum = parseInt(b.replace('Group ', '')) || 0;\n      return aNum - bNum;\n    })\n    .forEach(groupName => {\n      const group = groups[groupName];\n      // Sort members within each group by name\n      group.youngPeople.sort((a, b) => (a.name || '').localeCompare(b.name || ''));\n      sortedGroups[groupName] = group;\n    });\n\n  const hasVikingEventData = summaryStats.some(member => \n    member.vikingEventData?.CampGroup !== undefined,\n  );\n\n  return {\n    groups: sortedGroups,\n    summary: {\n      totalGroups: Object.keys(sortedGroups).length,\n      totalMembers,\n      hasUnassigned: !!sortedGroups['Group Unassigned'],\n      vikingEventDataAvailable: hasVikingEventData,\n    },\n  };\n}\n\n\n/**\n * CampGroupsView - Simple component for displaying camp groups\n * Uses pre-processed summaryStats like RegisterTab - no complex state management\n *\n * @param {object} props - Component props\n * @param {Array} props.summaryStats - Pre-processed member data with Viking Event data\n * @param {Array} props.events - Array of event data (for context)  \n * @param {Array} props.members - Array of all member data (for member details)\n * @param {Function} props.onMemberClick - Member click handler\n * @param props.vikingEventData\n */\nfunction CampGroupsView({\n  summaryStats = [],\n  events = [],\n  members: _members = [],\n  vikingEventData,\n  onMemberClick,\n}) {\n  // Simple state for modal\n  const [selectedMember, setSelectedMember] = useState(null);\n  const [showMemberModal, setShowMemberModal] = useState(false);\n  \n  // State for optimistic updates - track member camp group changes\n  const [pendingMoves, setPendingMoves] = useState(new Map());\n  const [recentlyCompletedMoves, setRecentlyCompletedMoves] = useState(new Map());\n\n  const isMobile = isMobileLayout();\n\n  // Simple data organization like RegisterTab - just group the pre-processed summaryStats\n  // Include optimistic updates for immediate UI feedback\n  const { groups, summary } = useMemo(() => \n    organizeByCampGroups(summaryStats, pendingMoves, recentlyCompletedMoves), \n  [summaryStats, pendingMoves, recentlyCompletedMoves],\n  );\n\n  // Handle member click - simple version like RegisterTab\n  const handleMemberClick = (member) => {\n    if (onMemberClick) {\n      onMemberClick(member);\n    } else {\n      // Fallback - show basic member modal\n      setSelectedMember(member);\n      setShowMemberModal(true);\n    }\n  };\n\n  // Handle modal close\n  const handleModalClose = () => {\n    setShowMemberModal(false);\n    setSelectedMember(null);\n  };\n\n  // Simple drag handlers - placeholder implementation for basic functionality\n  const handleDragStart = () => {\n    // Basic drag start - could add more functionality later\n  };\n\n  const handleDragEnd = () => {\n    // Basic drag end - could add more functionality later\n  };\n\n  const handleMemberMove = async (moveData) => {\n    const moveId = `${moveData.member.scoutid}_${Date.now()}`;\n    try {\n      const token = getToken();\n      if (!token) {\n        notifyError('Please sign in to OSM to move members between camp groups.');\n        return;\n      }\n\n      // Add optimistic update immediately for instant UI feedback\n      setPendingMoves(prev => new Map(prev).set(moveId, moveData));\n\n      // Extract FlexiRecord context from the member's Viking Event data\n      const member = moveData.member;\n      const sectionId = member.sectionid;\n      const event = events.find(e => e.sectionid === sectionId);\n      const termId = event?.termid || 'current';\n      \n      // Try to get the real section type from section cache (e.g., 'beavers', 'cubs', 'scouts')\n      // The OSM API expects section type, not section name\n      const sectionsData = await databaseService.getSections();\n      const sectionData = sectionsData.find(s => String(s.sectionid) === String(sectionId));\n      const realSectionType = sectionData?.sectiontype || 'Unknown Section Type';\n      \n      if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n        logger.debug('Section type resolution', {\n          eventSectionName: event?.sectionname,\n          finalSectionType: realSectionType,\n          sectionId,\n          totalSections: sectionsData.length,\n        }, LOG_CATEGORIES.COMPONENT);\n        \n        logger.debug('Member move operation', {\n          memberId: member.scoutid,\n          sectionId,\n          termId,\n          realSectionType,\n          fromGroup: moveData.fromGroupNumber,\n          toGroup: moveData.toGroupNumber,\n        }, LOG_CATEGORIES.COMPONENT);\n        \n        logger.debug('Viking event data map state', {\n          hasMap: !!vikingEventData,\n          mapSize: vikingEventData?.size || 0,\n          lookupKey: String(sectionId),\n          hasDataForSection: vikingEventData?.has(String(sectionId)) || false,\n        }, LOG_CATEGORIES.COMPONENT);\n      }\n\n      // Get Viking Event data structure for this section from the Map\n      logger.info('DEBUG: vikingEventData Map inspection', {\n        hasVikingEventData: !!vikingEventData,\n        mapSize: vikingEventData?.size || 0,\n        mapKeys: vikingEventData ? Array.from(vikingEventData.keys()) : [],\n        requestedSectionId: sectionId,\n        requestedSectionIdString: String(sectionId),\n      }, LOG_CATEGORIES.APP);\n      \n      let sectionVikingEventData = vikingEventData?.get(String(sectionId));\n      \n      // Fallback: if Map is empty, try to load directly from localStorage\n      if (!sectionVikingEventData && (!vikingEventData || vikingEventData.size === 0)) {\n        if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n          logger.debug('Loading Viking Event data from localStorage fallback', { sectionId }, LOG_CATEGORIES.COMPONENT);\n        }\n        try {\n          // Look for Viking Event structure data in localStorage\n          const structureKeys = Object.keys(localStorage).filter(key => \n            key.includes('viking_flexi_structure_') && key.includes('offline'),\n          );\n          if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n            logger.debug('Found Viking Event structure keys', { count: structureKeys.length }, LOG_CATEGORIES.COMPONENT);\n          }\n          \n          // Look for Viking Event data for this specific section\n          const dataKeys = Object.keys(localStorage).filter(key => \n            key.includes('viking_flexi_data_') && key.includes(`_${sectionId}_`) && key.includes('offline'),\n          );\n          if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n            logger.debug('Found Viking Event data keys for section', { sectionId, count: dataKeys.length }, LOG_CATEGORIES.COMPONENT);\n          }\n          \n          if (structureKeys.length > 0 && dataKeys.length > 0) {\n            // Try to find a structure that has a CampGroup field\n            let foundStructure = null;\n            for (const structureKey of structureKeys) {\n              try {\n                const structureData = JSON.parse(localStorage.getItem(structureKey));\n                \n                // Check if this structure has a CampGroup field in its fieldMapping\n                const fieldMapping = structureData?.fieldMapping || {};\n                \n                // Look for CampGroup field (try different variations)\n                const hasCampGroupField = Object.values(fieldMapping).some(field => {\n                  const name = field.name?.toLowerCase();\n                  return name === 'campgroup' || name === 'camp group' || name === 'camp_group' || \n                         name?.includes('camp') || name?.includes('group');\n                });\n                \n                if (hasCampGroupField) {\n                  if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n                    logger.debug('Found structure with CampGroup field', { structureKey }, LOG_CATEGORIES.COMPONENT);\n                  }\n                  foundStructure = structureData;\n                  break;\n                }\n              } catch (error) {\n                console.warn('🐛 Failed to parse structure:', structureKey, error);\n              }\n            }\n            \n            if (foundStructure) {\n              if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n                logger.debug('Using structure with CampGroup field', { hasStructure: !!foundStructure }, LOG_CATEGORIES.COMPONENT);\n              }\n              sectionVikingEventData = { structure: foundStructure };\n            } else {\n              if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n                logger.debug('No structure found with CampGroup field, creating fallback structure', {}, LOG_CATEGORIES.COMPONENT);\n              }\n              \n              // Check if any member in summaryStats has CampGroup data\n              const memberWithCampGroup = summaryStats.find(m => m.vikingEventData?.CampGroup !== undefined);\n              if (memberWithCampGroup && dataKeys.length > 0) {\n                if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n                  logger.debug('Found member with CampGroup data', { \n                    memberId: memberWithCampGroup.scoutid,\n                    hasCampGroup: !!memberWithCampGroup.vikingEventData?.CampGroup, \n                  }, LOG_CATEGORIES.COMPONENT);\n                }\n                \n                // Extract the real flexirecordid from the data key\n                // Format: viking_flexi_data_FLEXIID_SECTIONID_TERMID_offline\n                const dataKey = dataKeys[0];\n                const keyParts = dataKey.replace('viking_flexi_data_', '').replace('_offline', '').split('_');\n                const realFlexiRecordId = keyParts[0];\n                const realTermId = keyParts[2];\n                \n                if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n                  logger.debug('Extracted flexi record metadata', { realFlexiRecordId, realTermId }, LOG_CATEGORIES.COMPONENT);\n                }\n                \n                // Create a structure with the real flexi record ID in the correct format\n                sectionVikingEventData = {\n                  _structure: {\n                    flexirecordid: realFlexiRecordId,\n                    config: JSON.stringify([{\n                      id: 'f_1',\n                      name: 'CampGroup',\n                      width: '150',\n                    }]),\n                    fieldMapping: {\n                      f_1: {\n                        name: 'CampGroup',\n                        columnId: 'f_1',\n                      },\n                    },\n                  },\n                };\n                if (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development') {\n                  logger.debug('Created fallback structure', { realFlexiRecordId }, LOG_CATEGORIES.COMPONENT);\n                }\n              }\n            }\n          }\n        } catch (error) {\n          console.error('🐛 Fallback localStorage load failed:', error);\n        }\n      }\n      \n      logger.info('DEBUG: sectionVikingEventData for section', {\n        sectionId,\n        hasSectionData: !!sectionVikingEventData,\n        sectionDataKeys: sectionVikingEventData ? Object.keys(sectionVikingEventData) : null,\n      }, LOG_CATEGORIES.APP);\n      \n      const flexiRecordContext = extractFlexiRecordContext(sectionVikingEventData, sectionId, termId, realSectionType);\n\n      if (!flexiRecordContext) {\n        notifyError('No Viking Event Management flexi record found for this section.');\n        return;\n      }\n\n      const memberName = member.name || `${member.firstname} ${member.lastname}`;\n      \n      // Show loading notification\n      notifyInfo(`Moving ${memberName} to ${moveData.toGroupName}...`);\n\n      // Call the API service\n      const result = await assignMemberToCampGroup(moveData, flexiRecordContext, token);\n\n      if (result.success) {\n        notifySuccess(`${memberName} successfully moved to ${moveData.toGroupName}`);\n        \n        // Move from pending to recently completed\n        setPendingMoves(prev => {\n          const newMap = new Map(prev);\n          newMap.delete(moveId);\n          return newMap;\n        });\n        \n        setRecentlyCompletedMoves(prev => new Map(prev).set(moveId, moveData));\n        \n        // Clear from recently completed after a delay to allow data refresh\n        setTimeout(() => {\n          setRecentlyCompletedMoves(prev => {\n            const newMap = new Map(prev);\n            newMap.delete(moveId);\n            return newMap;\n          });\n        }, 5000); // Keep for 5 seconds to allow data refresh\n        \n      } else {\n        throw new Error(result.error || 'Move failed');\n      }\n\n    } catch (error) {\n      logger.error('Failed to move member between camp groups', {\n        error: error.message,\n        moveData,\n      }, LOG_CATEGORIES.COMPONENT);\n\n      // Remove from pending moves on error to revert optimistic update\n      setPendingMoves(prev => {\n        const newMap = new Map(prev);\n        newMap.delete(moveId);\n        return newMap;\n      });\n\n      notifyError(`Failed to move member: ${error.message}`, error);\n    }\n  };\n\n  // Simple sorted groups list like RegisterTab uses sorted data\n  const sortedGroups = useMemo(() => {\n    if (!groups || Object.keys(groups).length === 0) {\n      return [];\n    }\n\n    return Object.values(groups).sort((a, b) => {\n      if (a.name === 'Group Unassigned') return 1;\n      if (b.name === 'Group Unassigned') return -1;\n      const aNum = parseInt(a.number) || 0;\n      const bNum = parseInt(b.number) || 0;\n      return aNum - bNum;\n    });\n  }, [groups]);\n\n  if (!summaryStats || summaryStats.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"text-gray-500 mb-4\">\n          <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z\" />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Members Found</h3>\n        <p className=\"text-gray-600\">No members found for camp groups.</p>\n      </div>\n    );\n  }\n\n  if (!sortedGroups || sortedGroups.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"text-gray-500 mb-4\">\n          <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0\" />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Camp Groups Found</h3>\n        <p className=\"text-gray-600\">No camp group assignments found for this event.</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"camp-groups-view\">\n      {/* Header with summary stats */}\n      <div className=\"mb-6\">\n        <div className=\"flex flex-wrap gap-4 mb-4\">\n          <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-sm bg-scout-blue text-white\">\n            {summary.totalGroups || 0} Groups\n          </span>\n          <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-sm bg-scout-green text-white\">\n            {summary.totalMembers || 0} Members\n          </span>\n        </div>\n\n        {!summary.vikingEventDataAvailable && (\n          <Alert variant=\"warning\" className=\"mb-4\">\n            <Alert.Title>No Viking Event Management Data</Alert.Title>\n            <Alert.Description>\n              No &quot;Viking Event Mgmt&quot; flexirecord found for the sections involved in these events. \n              All members will be shown in the &quot;Unassigned&quot; group.\n            </Alert.Description>\n          </Alert>\n        )}\n      </div>\n\n      {/* Simple groups grid - similar to RegisterTab's table */}\n      <div className={`grid gap-4 ${isMobile ? 'gap-2' : ''}`} \n        style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))' }}>\n        {sortedGroups.map((group) => (\n          <CampGroupCard\n            key={group.name}\n            group={group}\n            onMemberClick={handleMemberClick}\n            onMemberMove={handleMemberMove}\n            onDragStart={handleDragStart}\n            onDragEnd={handleDragEnd}\n            // Enable drag and drop functionality\n            dragDisabled={false}\n            className=\"h-fit\"\n          />\n        ))}\n      </div>\n\n      {/* Member Detail Modal */}\n      <MemberDetailModal\n        member={selectedMember}\n        isOpen={showMemberModal}\n        onClose={handleModalClose}\n      />\n    </div>\n  );\n}\n\nexport default CampGroupsView;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/CompactAttendanceFilter.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.filters\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onFiltersChange\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.filters\n * @param root0.onFiltersChange\n */\nfunction CompactAttendanceFilter({ filters, onFiltersChange }) {\n  const handleFilterToggle = (status) => {\n    const newFilters = {\n      ...filters,\n      [status]: !filters[status],\n    };\n    onFiltersChange(newFilters);\n  };\n\n  const statusConfig = [\n    {\n      key: 'yes',\n      label: 'Yes',\n      activeStyles: 'bg-scout-green text-white',\n      inactiveStyles: 'bg-white text-scout-green border border-scout-green',\n    },\n    {\n      key: 'no',\n      label: 'No',\n      activeStyles: 'bg-red-500 text-white',\n      inactiveStyles: 'bg-white text-red-500 border border-red-500',\n    },\n    {\n      key: 'invited',\n      label: 'Invited',\n      activeStyles: 'bg-scout-blue text-white',\n      inactiveStyles: 'bg-white text-scout-blue border border-scout-blue',\n    },\n    {\n      key: 'notInvited',\n      label: 'Not Invited',\n      activeStyles: 'bg-gray-500 text-white',\n      inactiveStyles: 'bg-white text-gray-500 border border-gray-500',\n    },\n  ];\n\n  return (\n    <div\n      className=\"flex gap-2\"\n      role=\"group\"\n      aria-label=\"Attendance status filters\"\n      data-oid=\"7m451x6\"\n    >\n      {statusConfig.map(({ key, label, activeStyles, inactiveStyles }) => (\n        <button\n          key={key}\n          onClick={() => handleFilterToggle(key)}\n          className={`px-3 py-1 text-xs font-medium rounded-full transition-all duration-200 hover:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-gray-300 ${filters[key] ? activeStyles : inactiveStyles}`}\n          type=\"button\"\n          aria-pressed={filters[key]}\n          aria-label={`Filter by ${label} attendance status`}\n          data-oid=\"yzgje2b\"\n        >\n          {label}\n        </button>\n      ))}\n    </div>\n  );\n}\n\nexport default CompactAttendanceFilter;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/DraggableMember.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.member\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.group\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onMemberClick\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDragStart\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDragEnd\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isDragging\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.disabled\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n *\n * @param root0\n * @param root0.member\n * @param root0.group\n * @param root0.onMemberClick\n * @param root0.onDragStart\n * @param root0.onDragEnd\n * @param root0.isDragging\n * @param root0.disabled\n * @param root0.className\n */\nfunction DraggableMember({ \n  member, \n  group,\n  onMemberClick,\n  onDragStart, \n  onDragEnd, \n  isDragging = false,\n  disabled = false,\n  className = '',\n}) {\n  const [touchStartTime, setTouchStartTime] = useState(null);\n  const [touchStartPos, setTouchStartPos] = useState(null);\n  const [isTouchDragging, setIsTouchDragging] = useState(false);\n\n  const handleDragStart = (e) => {\n    if (disabled) {\n      e.preventDefault();\n      return;\n    }\n    \n    if (onDragStart) {\n      onDragStart(e, member, group);\n    }\n\n    // Set drag data for drop handling\n    const dragData = {\n      memberId: member.scoutid,\n      memberName: member.firstname + ' ' + member.lastname,\n      fromGroupNumber: group.number,\n      fromGroupName: group.name,\n      member: member,\n      sectionid: member.sectionid,\n    };\n\n    e.dataTransfer.setData('application/json', JSON.stringify(dragData));\n    e.dataTransfer.effectAllowed = 'move';\n  };\n\n  const handleDragEnd = (e) => {\n    if (onDragEnd) {\n      onDragEnd(e, member);\n    }\n  };\n\n  const handleClick = (e) => {\n    // Don't trigger click if we're dragging\n    if (isTouchDragging) {\n      e.preventDefault();\n      return;\n    }\n\n    if (onMemberClick) {\n      onMemberClick(member);\n    }\n  };\n\n  // Touch handling for mobile drag and drop\n  const handleTouchStart = (e) => {\n    if (disabled) return;\n\n    const touch = e.touches[0];\n    setTouchStartTime(Date.now());\n    setTouchStartPos({ x: touch.clientX, y: touch.clientY });\n    setIsTouchDragging(false);\n  };\n\n  const handleTouchMove = (e) => {\n    if (disabled || !touchStartTime || !touchStartPos) return;\n\n    const touch = e.touches[0];\n    const deltaX = Math.abs(touch.clientX - touchStartPos.x);\n    const deltaY = Math.abs(touch.clientY - touchStartPos.y);\n    const timeDelta = Date.now() - touchStartTime;\n\n    // Start drag if we've moved far enough or held long enough\n    if ((deltaX > 10 || deltaY > 10) || timeDelta > 500) {\n      setIsTouchDragging(true);\n      \n      // Trigger drag start for touch\n      if (onDragStart) {\n        const fakeEvent = {\n          type: 'touchdrag',\n          dataTransfer: {\n            setData: () => {},\n            effectAllowed: 'move',\n          },\n        };\n        onDragStart(fakeEvent, member, group);\n      }\n    }\n  };\n\n  const handleTouchEnd = (e) => {\n    if (disabled) return;\n\n    if (isTouchDragging) {\n      // Find drop target\n      const touch = e.changedTouches[0];\n      const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);\n      const dropZone = elementBelow?.closest('[data-drop-zone=\"true\"]');\n      \n      if (dropZone) {\n        const dragData = {\n          memberId: member.scoutid,\n          memberName: member.firstname + ' ' + member.lastname,\n          fromGroupNumber: group.number,\n          fromGroupName: group.name,\n          member: member,\n          sectionid: member.sectionid,\n        };\n\n        // Dispatch custom mobile-drop event\n        const mobileDropEvent = new window.CustomEvent('mobile-drop', {\n          detail: dragData,\n        });\n        dropZone.dispatchEvent(mobileDropEvent);\n      }\n\n      if (onDragEnd) {\n        onDragEnd(e, member);\n      }\n    }\n\n    // Reset touch state\n    setTouchStartTime(null);\n    setTouchStartPos(null);\n    setIsTouchDragging(false);\n  };\n\n  // Determine if member is signed out (for greying)\n  const isSignedOut = member.SignedOutBy || member.SignedOutWhen || \n                     member.vikingEventData?.SignedOutBy || member.vikingEventData?.SignedOutWhen;\n\n  return (\n    <div\n      draggable={!disabled}\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n      onClick={handleClick}\n      className={`\n        relative bg-white border border-gray-200 rounded p-2 transition-all duration-200\n        ${disabled ? 'cursor-default' : 'cursor-grab active:cursor-grabbing'}\n        ${isDragging ? 'opacity-50 transform scale-95 shadow-lg border-scout-blue bg-scout-blue/5' : 'hover:shadow-md hover:border-gray-300'}\n        ${isTouchDragging ? 'opacity-75 transform scale-105 shadow-lg z-10' : ''}\n        ${className}\n      `}\n      style={{\n        touchAction: disabled ? 'auto' : 'none',\n      }}\n    >\n      {/* Drag handle icon */}\n      {!disabled && (\n        <div className=\"absolute top-1 right-1 text-gray-400 hover:text-gray-600\">\n          <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M7 16V4a1 1 0 00-1-1H4a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1zM15 16V4a1 1 0 00-1-1h-2a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1zM19 20H5a1 1 0 01-1-1v-2a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1z\" />\n          </svg>\n        </div>\n      )}\n\n      {/* Member info */}\n      <div className={`text-sm font-medium transition-colors ${\n        isSignedOut ? 'text-gray-400' : 'text-gray-900'\n      }`}>\n        {member.firstname} {member.lastname}\n      </div>\n      \n      {/* Additional member info if available */}\n      {member.patrol && (\n        <div className=\"text-xs text-gray-500 mt-1\">{member.patrol}</div>\n      )}\n      \n      {/* Visual feedback for dragging */}\n      {isDragging && (\n        <div className=\"absolute inset-0 bg-scout-blue/20 rounded pointer-events-none\" />\n      )}\n    </div>\n  );\n}\n\nDraggableMember.propTypes = {\n  member: PropTypes.shape({\n    scoutid: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    firstname: PropTypes.string,\n    lastname: PropTypes.string,\n    sectionid: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    patrol: PropTypes.string,\n    SignedOutBy: PropTypes.string,\n    SignedOutWhen: PropTypes.string,\n    vikingEventData: PropTypes.object,\n  }).isRequired,\n  group: PropTypes.shape({\n    name: PropTypes.string,\n    number: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  }).isRequired,\n  onMemberClick: PropTypes.func,\n  onDragStart: PropTypes.func,\n  onDragEnd: PropTypes.func,\n  isDragging: PropTypes.bool,\n  disabled: PropTypes.bool,\n  className: PropTypes.string,\n};\n\nexport default DraggableMember;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventCard.jsx","messages":[{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.id\" does not exist on props","line":29,"column":1,"nodeType":"Block","endLine":29,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.name\" does not exist on props","line":30,"column":1,"nodeType":"Block","endLine":30,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.events\" does not exist on props","line":31,"column":1,"nodeType":"Block","endLine":31,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.events[].startdate\" does not exist on props","line":32,"column":1,"nodeType":"Block","endLine":32,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.events[].enddate\" does not exist on props","line":33,"column":1,"nodeType":"Block","endLine":33,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.location\" does not exist on props","line":34,"column":1,"nodeType":"Block","endLine":34,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"props.eventCard.attendanceData\" does not exist on props","line":35,"column":1,"nodeType":"Block","endLine":35,"endColumn":1}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file EventCard component for displaying Scout event information\n * \n * Responsive card component that displays event details including name, dates,\n * location, and attendance information. Features Scout-themed styling with\n * Tailwind classes and supports both single and multi-date events.\n * \n * @module EventCard\n * @version 2.3.7\n * @since 2.3.7 - Created as part of Tailwind-first component redesign\n * @author Vikings Event Management Team\n */\n\nimport React, { useMemo } from 'react';\nimport { cn } from '../../../shared/utils/cn';\nimport AttendanceGrid from './AttendanceGrid.jsx';\n\n/**\n * EventCard component displays Scout event information in a card layout\n * \n * Renders event details including name, date range, location, and attendance\n * information in a responsive card format. Automatically handles date formatting\n * for both single and multi-date events. Uses Scout theme colors and supports\n * loading states for async data operations.\n * \n * @component\n * @param {object} props - Component props\n * @param {object} props.eventCard - Event data object containing event details\n * @param {string} props.eventCard.id - Unique event identifier\n * @param {string} props.eventCard.name - Event name/title\n * @param {Array} props.eventCard.events - Array of event date objects\n * @param {string} props.eventCard.events[].startdate - Event start date (ISO string)\n * @param {string} props.eventCard.events[].enddate - Event end date (ISO string)\n * @param {string} [props.eventCard.location] - Event location/venue\n * @param {Array} [props.eventCard.attendanceData] - Attendance records for the event\n * @param {Function} [props.onViewAttendees] - Callback when \"View Attendees\" is clicked\n * @param {boolean} [props.loading=false] - Loading state indicator\n * \n * @returns {JSX.Element} Rendered event card component\n * \n * @example\n * // Basic event card\n * <EventCard \n *   eventCard={{\n *     id: 'summer-camp-2024',\n *     name: 'Summer Camp 2024',\n *     events: [{\n *       startdate: '2024-07-15',\n *       enddate: '2024-07-20'\n *     }],\n *     location: 'Camp Wohelo',\n *     attendanceData: attendanceRecords\n *   }}\n *   onViewAttendees={handleViewAttendees}\n * />\n * \n * @example\n * // Multi-date event card\n * <EventCard \n *   eventCard={{\n *     id: 'weekly-meetings',\n *     name: 'Scout Meetings',\n *     events: [\n *       { startdate: '2024-07-01', enddate: '2024-07-01' },\n *       { startdate: '2024-07-08', enddate: '2024-07-08' },\n *       { startdate: '2024-07-15', enddate: '2024-07-15' }\n *     ],\n *     location: 'Scout Hall'\n *   }}\n * />\n * \n * @example\n * // Loading state\n * <EventCard \n *   eventCard={eventData}\n *   loading={true}\n *   onViewAttendees={handleViewAttendees}\n * />\n * \n * @example\n * // Event card with attendance grid\n * const handleViewAttendees = (eventId) => {\n *   navigate(`/events/${eventId}/attendance`);\n * };\n * \n * <EventCard \n *   eventCard={{\n *     id: 'badge-ceremony',\n *     name: 'Badge Ceremony',\n *     events: [{ startdate: '2024-08-01', enddate: '2024-08-01' }],\n *     attendanceData: memberAttendance\n *   }}\n *   onViewAttendees={handleViewAttendees}\n * />\n * \n * @since 2.3.7\n */\nfunction EventCard({ eventCard, onViewAttendees, loading = false }) {\n  const slug = useMemo(() => {\n    const base = (eventCard?.name ?? '')\n      .toString()\n      .trim()\n      .toLowerCase()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '')\n      .slice(0, 64) || 'event';\n    return eventCard?.id ? `${base}-${eventCard.id}` : base;\n  }, [eventCard?.name, eventCard?.id]);\n\n  const formatDate = (dateString) => {\n    try {\n      const date = new Date(dateString);\n      return date.toLocaleDateString('en-GB', {\n        day: 'numeric',\n        month: 'short',\n        year: 'numeric',\n      });\n    } catch {\n      return dateString;\n    }\n  };\n\n  const formatDateRange = (events) => {\n    if (events.length === 1) {\n      const event = events[0];\n      if (event.startdate === event.enddate) {\n        return formatDate(event.startdate);\n      }\n      return `${formatDate(event.startdate)} - ${formatDate(event.enddate)}`;\n    }\n\n    // Multiple events - show range from earliest to latest\n    const sortedEvents = [...events].sort(\n      (a, b) => new Date(a.startdate) - new Date(b.startdate),\n    );\n    const firstEvent = sortedEvents[0];\n    const lastEvent = sortedEvents[sortedEvents.length - 1];\n\n    return `${formatDate(firstEvent.startdate)} - ${formatDate(lastEvent.enddate)}`;\n  };\n\n  const buildAttendanceGrid = (events) => {\n    // Initialize grid structure by section\n    const grid = {};\n\n    // Check if any event has shared event data (synthetic attendees from all sections)\n    const hasSharedEventData = events.some(\n      (e) =>\n        Array.isArray(e.attendanceData) &&\n        e.attendanceData.some((a) => a.scoutid?.startsWith('synthetic-')),\n    );\n\n    if (hasSharedEventData) {\n      // For shared events, we need to merge detailed section data with shared data\n\n      // First, get all sections from synthetic attendees across all events\n      // Filter out null/undefined section names\n      const allSections = [\n        ...new Set(\n          events\n            .flatMap((e) => e.attendanceData || [])\n            .filter((a) => a.scoutid?.startsWith('synthetic-'))\n            .map((a) => a.sectionname)\n            .filter((sectionName) => !!sectionName && sectionName !== 'null'),\n        ),\n      ];\n\n      // Get sections we have direct access to (from events)\n      const accessibleSections = new Set(\n        events.map((event) => event.sectionname),\n      );\n\n      // Initialize grid for all sections\n      allSections.forEach((sectionName) => {\n        grid[sectionName] = {\n          attending: 0,\n          notAttending: 0,\n          invited: 0,\n          notInvited: 0,\n        };\n      });\n\n      // Process detailed data for sections we have access to (priority over shared data)\n      events.forEach((event) => {\n        if (\n          event.attendanceData &&\n          Array.isArray(event.attendanceData) &&\n          event.sectionname &&\n          accessibleSections.has(event.sectionname)\n        ) {\n          const sectionName = event.sectionname;\n\n          // Check if this is real attendance data (not synthetic)\n          const hasRealData = event.attendanceData.some(\n            (person) =>\n              !person.scoutid || !person.scoutid.startsWith('synthetic-'),\n          );\n\n          if (import.meta?.env?.DEV) {\n            const syntheticCount = event.attendanceData.filter((p) =>\n              p.scoutid?.startsWith('synthetic-'),\n            ).length;\n            const realCount = event.attendanceData.length - syntheticCount;\n            console.debug(`EventCard: Processing section ${sectionName}`, {\n              totalAttendees: event.attendanceData.length,\n              hasRealData,\n              syntheticCount,\n              realCount,\n            });\n          }\n\n          if (hasRealData) {\n            // Use detailed section-specific data\n            event.attendanceData.forEach((person) => {\n              // Skip synthetic attendees for sections we have real data for\n              if (person.scoutid && person.scoutid.startsWith('synthetic-'))\n                return;\n\n              // Ensure grid entry exists for this person's section (safety check)\n              const personSectionName = person.sectionname || sectionName;\n              if (!grid[personSectionName]) {\n                grid[personSectionName] = {\n                  attending: 0,\n                  notAttending: 0,\n                  invited: 0,\n                  notInvited: 0,\n                };\n              }\n\n              if (person.attending === 'Yes') {\n                grid[personSectionName].attending++;\n              } else if (person.attending === 'No') {\n                grid[personSectionName].notAttending++;\n              } else if (person.attending === 'Invited') {\n                grid[personSectionName].invited++;\n              } else {\n                grid[personSectionName].notInvited++;\n              }\n            });\n          }\n        }\n      });\n\n      // Fill in gaps with synthetic data for sections we don't have access to\n      // Process synthetic data from all events\n      events.forEach((event) => {\n        if (Array.isArray(event.attendanceData)) {\n          event.attendanceData.forEach((person) => {\n            const sectionName = person.sectionname;\n\n            // Only use synthetic data if we don't have real data for this section\n            if (\n              person.scoutid &&\n              person.scoutid.startsWith('synthetic-') &&\n              !accessibleSections.has(sectionName)\n            ) {\n              // Ensure grid entry exists for this section (safety check)\n              if (!grid[sectionName]) {\n                grid[sectionName] = {\n                  attending: 0,\n                  notAttending: 0,\n                  invited: 0,\n                  notInvited: 0,\n                };\n              }\n\n              if (person.attending === 'Yes') {\n                grid[sectionName].attending++;\n              }\n              // Note: shared data only provides \"Yes\" counts, no No/Invited/NotInvited for non-accessible sections\n            }\n          });\n        }\n      });\n\n      return grid;\n    }\n\n    // Regular events: get unique sections from events\n    const sections = [\n      ...new Set(events.map((event) => event.sectionname).filter(Boolean)),\n    ];\n\n    // Initialize each section in grid\n    sections.forEach((sectionName) => {\n      grid[sectionName] = {\n        attending: 0,\n        notAttending: 0,\n        invited: 0,\n        notInvited: 0,\n      };\n    });\n\n    // Process attendance data by section (regular events)\n    events.forEach((event) => {\n      if (\n        event.attendanceData &&\n        Array.isArray(event.attendanceData) &&\n        event.sectionname\n      ) {\n        const sectionName = event.sectionname;\n\n        event.attendanceData.forEach((person) => {\n          // Ensure grid entry exists for this person's section (safety check)\n          const personSectionName = person.sectionname || sectionName;\n          if (!personSectionName) return; // skip unknown sections\n          if (!grid[personSectionName]) {\n            grid[personSectionName] = {\n              attending: 0,\n              notAttending: 0,\n              invited: 0,\n              notInvited: 0,\n            };\n          }\n\n          if (person.attending === 'Yes') {\n            grid[personSectionName].attending++;\n          } else if (person.attending === 'No') {\n            grid[personSectionName].notAttending++;\n          } else if (person.attending === 'Invited') {\n            grid[personSectionName].invited++;\n          } else {\n            // Empty string, null, or any other value means not invited\n            grid[personSectionName].notInvited++;\n          }\n        });\n      }\n    });\n\n    return grid;\n  };\n\n  const getEventStatus = (event) => {\n    const now = new Date();\n    const eventStart = new Date(event.startdate);\n    const eventEnd = new Date(event.enddate);\n\n    // Create a date for the day after the event ends\n    const dayAfterEventEnd = new Date(eventEnd);\n    dayAfterEventEnd.setDate(dayAfterEventEnd.getDate() + 1);\n\n    if (now < eventStart) {\n      return 'upcoming';\n    } else if (now >= eventStart && now < dayAfterEventEnd) {\n      return 'ongoing';\n    } else {\n      return 'past';\n    }\n  };\n\n  // Compute aggregated status once to avoid inline IIFE\n  const aggregatedStatus = useMemo(() => {\n    const statuses = new Set(eventCard.events.map((e) => getEventStatus(e)));\n    if (statuses.has('ongoing')) return 'ongoing';\n    if (statuses.has('upcoming')) return 'upcoming';\n    if (statuses.has('past')) return 'past';\n    return null;\n  }, [eventCard.events]);\n\n  const attendanceGrid = buildAttendanceGrid(eventCard.events);\n  const hasAttendanceData = eventCard.events.some(\n    (event) => event.attendanceData && event.attendanceData.length > 0,\n  );\n\n  return (\n    <div \n      className={cn('bg-white rounded-lg border border-gray-200 shadow-sm h-full flex flex-col break-inside-avoid')}\n      role=\"article\"\n      aria-labelledby={`event-title-${slug}`}\n      data-oid=\"3kxvx32\"\n    >\n      <div className={cn('px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg pb-3')} data-oid=\"20kbjde\">\n        <div className=\"flex justify-between items-start\" data-oid=\"oey::ov\">\n          <div className=\"flex-1\" data-oid=\"0w-_rn.\">\n            <h3\n              className={cn('text-lg font-semibold text-gray-900 m-0 mb-1')}\n              id={`event-title-${slug}`}\n              data-oid=\"pqa5tp.\"\n            >\n              {eventCard.name}\n            </h3>\n            <p \n              className=\"text-sm text-gray-600 mb-2\" \n              id={`event-${slug}-description`}\n              data-oid=\"4fslyto\"\n            >\n              {formatDateRange(eventCard.events)}\n            </p>\n          </div>\n          <div className=\"flex flex-col items-end gap-1\" data-oid=\"--y.h.3\">\n            {aggregatedStatus === 'ongoing' ? (\n              <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-sm bg-scout-green text-white\" data-oid=\"ei1z:j_\">\n                Ongoing\n              </span>\n            ) : aggregatedStatus === 'upcoming' ? (\n              <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-sm bg-scout-blue text-white\" data-oid=\"v1xw_so\">\n                Upcoming\n              </span>\n            ) : aggregatedStatus === 'past' ? (\n              <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-sm bg-gray-50 text-gray-600 border border-gray-200\" data-oid=\"qex6lwv\">\n                Past\n              </span>\n            ) : null}\n          </div>\n        </div>\n      </div>\n\n      <div className={cn('p-4 flex-1 pt-0')} data-oid=\"6ll9qi7\">\n        {hasAttendanceData ? (\n          <div className=\"mt-3 -mx-4\">\n            <AttendanceGrid data={attendanceGrid} data-oid=\"g_kymnd\" />\n          </div>\n        ) : (\n          <div className=\"text-center py-4\" data-oid=\"_t7fg-:\">\n            <div className=\"text-gray-400 mb-2\" data-oid=\"64422ln\">\n              <svg\n                className=\"mx-auto h-8 w-8\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n                data-oid=\"chp6dte\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth=\"2\"\n                  d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\"\n                  data-oid=\"nm81inc\"\n                />\n              </svg>\n            </div>\n            <p className=\"text-sm text-gray-500\" data-oid=\"13n62x.\">\n              No attendance data available\n            </p>\n          </div>\n        )}\n      </div>\n\n      <div className={cn('px-4 py-3 border-t border-gray-200 bg-gray-50 rounded-b-lg pt-3')} data-oid=\"bfx2bop\">\n        <button\n          onClick={() => onViewAttendees(eventCard)}\n          className=\"w-full inline-flex items-center justify-center gap-2 rounded-md font-medium px-4 py-2 text-base bg-scout-blue text-white hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light active:bg-scout-blue-dark transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n          type=\"button\"\n          disabled={loading}\n          aria-labelledby={`event-title-${slug} view-attendees-label-${slug}`}\n          aria-describedby={`event-${slug}-description`}\n          data-oid=\"5s0-rzy\"\n        >\n          {loading ? (\n            <>\n              <svg\n                className=\"animate-spin h-4 w-4\"\n                fill=\"none\"\n                viewBox=\"0 0 24 24\"\n                data-oid=\"stn251d\"\n              >\n                <circle\n                  className=\"opacity-25\"\n                  cx=\"12\"\n                  cy=\"12\"\n                  r=\"10\"\n                  stroke=\"currentColor\"\n                  strokeWidth=\"4\"\n                  data-oid=\"thmt3ef\"\n                ></circle>\n                <path\n                  className=\"opacity-75\"\n                  fill=\"currentColor\"\n                  d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z\"\n                  data-oid=\"stejrrd\"\n                ></path>\n              </svg>\n              <span id={`view-attendees-label-${slug}`} className=\"sr-only\">View Attendees</span>\n              Loading Members...\n            </>\n          ) : (\n            <>\n              <svg\n                className=\"h-4 w-4\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n                data-oid=\"6w_ii9m\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth=\"2\"\n                  d=\"M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z\"\n                  data-oid=\"8ll3aah\"\n                />\n              </svg>\n              <span id={`view-attendees-label-${slug}`}>View Attendees</span>\n            </>\n          )}\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default EventCard;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventDashboard.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":26,"column":1,"nodeType":"Block","endLine":31,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":26,"column":1,"nodeType":"Block","endLine":31,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":28,"column":1,"nodeType":"Block","endLine":28,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onNavigateToMembers\" description.","line":29,"column":1,"nodeType":"Block","endLine":29,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onNavigateToAttendance\" description.","line":30,"column":1,"nodeType":"Block","endLine":30,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":140,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":150,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":152,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":152,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":157,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":157,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":167,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":167,"endColumn":20},{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":169,"column":11,"endLine":169,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":308,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":308,"endColumn":56}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport {\n  getUserRoles,\n  getListOfMembers,\n  getAPIQueueStats,\n} from '../../../shared/services/api/api.js';\nimport { getToken, generateOAuthUrl } from '../../../shared/services/auth/tokenService.js';\nimport { authHandler } from '../../../shared/services/auth/authHandler.js';\nimport { useAuth } from '../../auth/hooks/useAuth.js';\nimport LoadingScreen from '../../../shared/components/LoadingScreen.jsx';\nimport EventCard from './EventCard.jsx';\nimport { SectionsList } from '../../sections';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport { Alert } from '../../../shared/components/ui';\nimport ConfirmModal from '../../../shared/components/ui/ConfirmModal';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport {\n  fetchAllSectionEvents,\n  fetchEventAttendance,\n  groupEventsByName,\n  buildEventCard,\n  filterEventsByDateRange,\n  expandSharedEvents,\n} from '../../../shared/utils/eventDashboardHelpers.js';\n\n/**\n *\n * @param root0\n * @param root0.onNavigateToMembers\n * @param root0.onNavigateToAttendance\n */\nfunction EventDashboard({ onNavigateToMembers, onNavigateToAttendance }) {\n  useAuth(); // Initialize auth hook\n  const [sections, setSections] = useState([]);\n  const [eventCards, setEventCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [lastSync, setLastSync] = useState(null);\n\n  // Debug: Expose sections.length globally for console debugging\n  useEffect(() => {\n    if (import.meta.env.DEV) {\n      window.debugSectionsLength = sections.length;\n      window.debugEventCardsLength = eventCards.length;\n      window.debugLoading = loading;\n    }\n  }, [sections.length, eventCards.length, loading]);\n\n  // Override loading state for design mode compatibility\n  const [forceLoaded, setForceLoaded] = useState(false);\n\n  useEffect(() => {\n    // Force loading to complete after any render\n    setForceLoaded(true);\n  }, []);\n\n  // Override the loading condition completely\n  const isActuallyLoading = loading && !forceLoaded;\n  const [queueStats, setQueueStats] = useState({\n    queueLength: 0,\n    processing: false,\n    totalRequests: 0,\n  });\n  const [loadingAttendees, setLoadingAttendees] = useState(null); // Track which event card is loading attendees\n  const [loadingSection, setLoadingSection] = useState(null); // Track which section is loading members\n\n  // Simple view toggle state\n  const [currentView] = useState('events'); // 'events' or 'sections'\n\n  // Section selection state for the Sections card\n  const [selectedSections, setSelectedSections] = useState([]);\n\n  // Handle section selection for the Sections card\n  const handleSectionToggleForCard = (section) => {\n    setSelectedSections((prev) => {\n      const isSelected = prev.some((s) => s.sectionid === section.sectionid);\n      if (isSelected) {\n        return prev.filter((s) => s.sectionid !== section.sectionid);\n      } else {\n        return [...prev, section];\n      }\n    });\n  };\n\n  // Modal state for confirmation dialogs\n  const [showConfirmModal, setShowConfirmModal] = useState(false);\n  const [confirmModalData, setConfirmModalData] = useState({\n    title: '',\n    message: '',\n    onConfirm: null,\n    onCancel: null,\n    confirmText: 'Confirm',\n    cancelText: 'Cancel',\n  });\n\n  // Component mount tracking and timeout management\n  const isMountedRef = useRef(false);\n  const backgroundSyncTimeoutIdRef = useRef(null);\n\n  useEffect(() => {\n    let mounted = true;\n    isMountedRef.current = true;\n\n    const initializeDashboard = async () => {\n      if (!mounted) return; // Prevent duplicate calls in StrictMode\n\n      // Additional StrictMode protection: use a global flag to prevent multiple initializations\n      const initKey = 'eventdashboard_initializing';\n      if (sessionStorage.getItem(initKey) === 'true') {\n        if (import.meta.env.DEV) {\n          console.log(\n            'EventDashboard: Skipping duplicate initialization (StrictMode protection)',\n          );\n        }\n        return; // Skip duplicate initialization\n      }\n\n      // Additional protection: prevent initialization if already loading or loaded\n      if (loading === false && (sections.length > 0 || eventCards.length > 0)) {\n        if (import.meta.env.DEV) {\n          console.log(\n            'EventDashboard: Skipping initialization - data already loaded',\n          );\n        }\n        return;\n      }\n\n      try {\n        sessionStorage.setItem(initKey, 'true');\n        await loadInitialData();\n\n        if (!mounted) return; // Check again after async operation\n      } finally {\n        // Clear the flag after initialization completes (success or failure)\n        sessionStorage.removeItem(initKey);\n      }\n    };\n\n    // Add a small delay to prevent race conditions in StrictMode\n    const timeoutId = setTimeout(() => {\n      if (mounted) {\n        initializeDashboard();\n      }\n    }, 50);\n\n    // Cleanup timeout if component unmounts before initialization\n    const originalCleanup = () => {\n      mounted = false;\n      isMountedRef.current = false;\n      clearTimeout(timeoutId);\n      if (backgroundSyncTimeoutIdRef.current) {\n        clearTimeout(backgroundSyncTimeoutIdRef.current);\n      }\n    };\n\n    // Update queue stats every second\n    const interval = setInterval(() => {\n      if (!mounted) return;\n      const stats = getAPIQueueStats();\n      if (stats) {\n        setQueueStats(stats);\n      }\n    }, 1000);\n\n    return () => {\n      originalCleanup();\n      clearInterval(interval);\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Listen for dashboard data completion and refresh\n  useEffect(() => {\n    let mounted = true;\n    let cleanupFn = null;\n\n    const handleDashboardDataComplete = async (syncStatus) => {\n      if (!mounted) return;\n\n      if (syncStatus.status === 'dashboard_complete') {\n        logger.info(\n          '🎯 Dashboard data sync completed - refreshing event cards',\n          {\n            timestamp: syncStatus.timestamp,\n          },\n          LOG_CATEGORIES.COMPONENT,\n        );\n\n        try {\n          const sectionsData = await databaseService.getSections();\n          if (sectionsData.length > 0 && mounted) {\n            setSections(sectionsData);\n            // Use token to enable shared events detection with freshly cached data\n            const currentToken = getToken();\n            const cards = await buildEventCards(sectionsData, currentToken);\n            if (mounted) {\n              setEventCards(cards);\n              setLoading(false);\n            }\n          }\n        } catch (error) {\n          logger.error(\n            'Error refreshing event cards after sync',\n            { error: error.message },\n            LOG_CATEGORIES.COMPONENT,\n          );\n        }\n      }\n    };\n\n    // Setup sync listener for dashboard completion\n    const setupSyncListener = async () => {\n      try {\n        const { default: syncService } = await import('../../../shared/services/storage/sync.js');\n        syncService.addSyncListener(handleDashboardDataComplete);\n\n        return () => {\n          syncService.removeSyncListener(handleDashboardDataComplete);\n        };\n      } catch (error) {\n        logger.error(\n          'Failed to setup sync listener in EventDashboard',\n          { error: error.message },\n          LOG_CATEGORIES.COMPONENT,\n        );\n        return null;\n      }\n    };\n\n    setupSyncListener().then((cleanup) => {\n      cleanupFn = cleanup;\n    });\n\n    // Also load immediately if sections are already available\n    const loadInitialCards = async () => {\n      if (!mounted) return;\n\n      try {\n        const sectionsData = await databaseService.getSections();\n        if (sectionsData.length > 0 && mounted) {\n          setSections(sectionsData);\n          // Use token for shared events detection during initial load\n          const currentToken = getToken();\n          const cards = await buildEventCards(sectionsData, currentToken);\n          if (mounted) {\n            setEventCards(cards);\n            setLoading(false);\n          }\n        }\n      } catch (error) {\n        logger.error(\n          'Error loading initial event cards',\n          { error: error.message },\n          LOG_CATEGORIES.COMPONENT,\n        );\n      }\n    };\n\n    loadInitialCards();\n\n    return () => {\n      mounted = false;\n      if (cleanupFn) {\n        cleanupFn();\n      }\n    };\n  }, []); // Run once - listen for sync events\n\n  const loadInitialData = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Initialize demo mode if enabled (moved from main.jsx)\n      const { isDemoMode, initializeDemoMode } = await import(\n        '../../../config/demoMode.js'\n      );\n      if (isDemoMode()) {\n        await initializeDemoMode();\n      } else {\n        // Clean up any demo cache data when not in demo mode\n        const { cleanupDemoCache } = await import('../../../shared/utils/cacheCleanup.js');\n        cleanupDemoCache();\n      }\n\n      // Check if we have offline data\n      const hasOfflineData = await databaseService.hasOfflineData();\n\n      // Check if data is recent enough (less than 30 minutes old)\n      const lastSyncEpoch = localStorage.getItem('viking_last_sync');\n      const lastSyncMs = Number(lastSyncEpoch);\n      const isDataFresh =\n        lastSyncEpoch &&\n        Number.isFinite(lastSyncMs) &&\n        Date.now() - lastSyncMs < 30 * 60 * 1000; // 30 minutes\n\n      // EventDashboard initialization - minimal logging\n\n      if (hasOfflineData && isDataFresh) {\n        // Recent cached data available - use cache\n        // Using fresh cached data\n        await loadCachedData();\n      } else if (hasOfflineData && !isDataFresh) {\n        // Stale cached data - load cache first, then auto-sync in background\n        // Using stale cached data, will sync in background\n        await loadCachedData();\n\n        // Auto-sync in background only if auth hasn't failed\n        backgroundSyncTimeoutIdRef.current = setTimeout(async () => {\n          try {\n            if (!isMountedRef.current) return;\n\n            if (authHandler.hasAuthFailed()) {\n              return;\n            }\n\n            const backgroundToken = getToken();\n            if (!backgroundToken) {\n              return;\n            }\n\n            // Starting background sync\n            await syncData();\n          } catch (error) {\n            // Error handling is now done in the API layer via simple auth handler\n            // Don't show error - this is background sync\n            if (import.meta.env.DEV) {\n              logger.debug(\n                'Background sync failed',\n                { error: error.message },\n                LOG_CATEGORIES.COMPONENT,\n              );\n            }\n          }\n        }, 1000);\n      } else {\n        // No cached data - check if we should attempt sync\n        if (import.meta.env.DEV) {\n          logger.debug(\n            'No cached data found - attempting sync',\n            {},\n            LOG_CATEGORIES.COMPONENT,\n          );\n        }\n\n        if (authHandler.hasAuthFailed()) {\n          if (import.meta.env.DEV) {\n            logger.debug(\n              'Sync skipped - auth already failed',\n              {},\n              LOG_CATEGORIES.COMPONENT,\n            );\n          }\n          setError(\n            'Authentication expired and no cached data available. Please reconnect to OSM.',\n          );\n          return;\n        }\n\n        const syncToken = getToken();\n        if (!syncToken) {\n          if (import.meta.env.DEV) {\n            logger.debug(\n              'Sync skipped - no token available',\n              {},\n              LOG_CATEGORIES.COMPONENT,\n            );\n          }\n          return;\n        }\n\n        if (import.meta.env.DEV) {\n          logger.debug(\n            'Loading data from database (sync handled by useAuth)',\n            {},\n            LOG_CATEGORIES.COMPONENT,\n          );\n        }\n        // Load data from database - useAuth handles the actual syncing\n        const sectionsData = await databaseService.getSections();\n        setSections(sectionsData);\n\n        if (sectionsData.length > 0) {\n          // In demo mode, force cache-only mode (no API calls)\n          const { isDemoMode } = await import('../../../config/demoMode.js');\n          const token = isDemoMode() ? null : syncToken;\n          const cards = await buildEventCards(sectionsData, token);\n          setEventCards(cards);\n        }\n      }\n    } catch (err) {\n      logger.error(\n        'Error loading initial data',\n        { error: err },\n        LOG_CATEGORIES.COMPONENT,\n      );\n\n      // Check if this is an auth error and we have some cached sections\n      const cachedSections = await databaseService\n        .getSections()\n        .catch(() => []);\n      if (\n        err &&\n        (err.status === 401 ||\n          err.status === 403 ||\n          (err.message && err.message.includes('Authentication failed'))) &&\n        cachedSections.length > 0\n      ) {\n        logger.info(\n          'Auth error during initial load but cached data available - enabling offline mode',\n        );\n        setSections(cachedSections);\n\n        // Try to load cached event cards\n        try {\n          const cards = await buildEventCards(cachedSections);\n          setEventCards(cards);\n        } catch (cardError) {\n          logger.warn('Failed to build cached event cards', {\n            error: cardError,\n          });\n        }\n\n        // Set last sync time from localStorage if available\n        const lastSyncEpoch = localStorage.getItem('viking_last_sync');\n        if (lastSyncEpoch) {\n          const lastSyncMs = Number(lastSyncEpoch);\n          if (Number.isFinite(lastSyncMs)) {\n            setLastSync(new Date(lastSyncMs));\n          } else {\n            // Fallback for old ISO string format\n            setLastSync(new Date(lastSyncEpoch));\n          }\n        }\n      } else {\n        setError(err.message);\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadCachedData = async () => {\n    try {\n      // Load sections from cache\n      const cachedSections = await databaseService.getSections();\n      setSections(cachedSections);\n\n      // Load events and build cards\n      const cards = await buildEventCards(cachedSections);\n      setEventCards(cards);\n\n      // Set last sync time from localStorage\n      const lastSyncEpoch = localStorage.getItem('viking_last_sync');\n      if (lastSyncEpoch) {\n        const lastSyncMs = Number(lastSyncEpoch);\n        if (Number.isFinite(lastSyncMs)) {\n          setLastSync(new Date(lastSyncMs));\n        } else {\n          // Fallback for old ISO string format\n          setLastSync(new Date(lastSyncEpoch));\n        }\n      }\n    } catch (err) {\n      logger.error(\n        'Error loading cached data',\n        { error: err },\n        LOG_CATEGORIES.COMPONENT,\n      );\n      throw err;\n    }\n  };\n\n  // Only function that triggers OSM API calls - user must explicitly click sync button\n  const syncData = async () => {\n    // Skip sync entirely in demo mode to prevent loops\n    const { isDemoMode } = await import('../../../config/demoMode.js');\n    if (isDemoMode()) {\n      logger.debug(\n        'Demo mode: Skipping syncData entirely',\n        {},\n        LOG_CATEGORIES.SYNC,\n      );\n      return;\n    }\n\n    let dataSource = 'api'; // Track whether data came from API or cache\n\n    try {\n      // Starting sync process\n      setError(null);\n\n      const syncDataToken = getToken();\n      if (import.meta.env.DEV) {\n        logger.debug(\n          'syncData: Token available',\n          { hasToken: !!syncDataToken },\n          LOG_CATEGORIES.SYNC,\n        );\n      }\n\n      // 1. Fetch all sections\n      if (import.meta.env.DEV) {\n        logger.debug(\n          'syncData: Fetching user roles/sections',\n          {},\n          LOG_CATEGORIES.SYNC,\n        );\n      }\n      // In demo mode, skip API call and return early\n      const { isDemoMode } = await import('../../../config/demoMode.js');\n      if (isDemoMode()) {\n        logger.info(\n          'Demo mode: Skipping getUserRoles API call',\n          {},\n          LOG_CATEGORIES.SYNC,\n        );\n        return loadInitialData(null);\n      }\n\n      const sectionsData = await getUserRoles(syncDataToken);\n      if (import.meta.env.DEV) {\n        logger.debug(\n          'syncData: Received sections',\n          { count: sectionsData.length },\n          LOG_CATEGORIES.SYNC,\n        );\n      }\n      setSections(sectionsData);\n      await databaseService.saveSections(sectionsData);\n\n      // 2. Fetch events for each section and build cards\n      if (import.meta.env.DEV) {\n        logger.debug('syncData: Building event cards', {}, LOG_CATEGORIES.SYNC);\n      }\n      // In demo mode, force cache-only mode (no API calls)\n      const token = isDemoMode ? null : syncDataToken;\n      const cards = await buildEventCards(sectionsData, token);\n      if (import.meta.env.DEV) {\n        logger.debug(\n          'syncData: Built event cards',\n          { count: cards.length },\n          LOG_CATEGORIES.SYNC,\n        );\n      }\n      setEventCards(cards);\n\n      // 3. Proactively load member data in background (non-blocking)\n      loadMemberDataInBackground(sectionsData, syncDataToken);\n\n      // Update last sync time\n      const now = new Date();\n      setLastSync(now);\n      localStorage.setItem('viking_last_sync', now.getTime().toString());\n\n      // Data was successfully synced from API if we reached this point\n      dataSource = 'api';\n      if (import.meta.env.DEV) {\n        logger.debug(\n          'syncData: Sync completed successfully',\n          { dataSource },\n          LOG_CATEGORIES.SYNC,\n        );\n      }\n    } catch (err) {\n      logger.error('Error syncing data', { error: err }, LOG_CATEGORIES.SYNC);\n\n      // Check if auth failed and we have cached data\n      if (authHandler.hasAuthFailed() && sections.length > 0) {\n        logger.info(\n          'Auth failed but cached data available - enabling offline mode',\n        );\n        setError(null); // Clear error since we can show cached data\n        dataSource = 'cache'; // Explicitly mark as cached data\n\n        // Load cached event cards instead of making more API calls\n        try {\n          const cards = await buildEventCards(sections); // Use cached sections, no token\n          setEventCards(cards);\n        } catch (cardError) {\n          logger.warn('Failed to build cached event cards after auth error', {\n            error: cardError,\n          });\n        }\n      } else {\n        setError(err.message);\n      }\n    }\n  };\n\n  // Load member data proactively in background\n  const loadMemberDataInBackground = async (sectionsData, token) => {\n    try {\n      if (!token || authHandler.hasAuthFailed()) {\n        return;\n      }\n\n      // Use getListOfMembers which already handles caching properly\n      await getListOfMembers(sectionsData, token);\n    } catch (error) {\n      // Don't show error to user - this is background loading\n      logger.warn(\n        'Background member loading failed',\n        {\n          error: error.message,\n          sectionCount: sectionsData.length,\n        },\n        LOG_CATEGORIES.COMPONENT,\n      );\n    }\n  };\n\n  const buildEventCards = async (sectionsData, token = null) => {\n    logger.debug(\n      'buildEventCards called',\n      {\n        sectionCount: sectionsData?.length || 0,\n        mode: token ? 'API' : 'CACHE',\n      },\n      LOG_CATEGORIES.COMPONENT,\n    );\n\n    const now = new Date();\n    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\n    // Fetch events for all sections with optimized terms loading\n    const allEvents = await fetchAllSectionEvents(sectionsData, token);\n\n    // Filter for future events and events from last week\n    const filteredEvents = filterEventsByDateRange(allEvents, oneWeekAgo);\n\n    // Fetch attendance data for filtered events (with shared event checking)\n    const attendanceMap = new Map();\n    for (const event of filteredEvents) {\n      try {\n        const attendanceData = await fetchEventAttendance(\n          event,\n          token,\n          filteredEvents,\n        );\n        if (attendanceData) {\n          attendanceMap.set(event.eventid, attendanceData);\n        }\n      } catch (err) {\n        logger.error(\n          'Error fetching attendance for event {eventId}',\n          {\n            error: err,\n            eventId: event.eventid,\n            eventName: event.name,\n          },\n          LOG_CATEGORIES.COMPONENT,\n        );\n      }\n    }\n\n    // Expand shared events to include all sections\n    const expandedEvents = expandSharedEvents(filteredEvents, attendanceMap);\n\n    // Group events by name\n    const eventGroups = groupEventsByName(expandedEvents);\n\n    // Convert groups to cards with attendance data\n    const cards = [];\n    for (const [eventName, events] of eventGroups) {\n      // Enrich events with attendance data without mutating originals\n      const eventsWithAttendance = events.map((event) => ({\n        ...event,\n        attendanceData: attendanceMap.get(event.eventid) || [],\n      }));\n\n      const card = buildEventCard(eventName, eventsWithAttendance);\n      // Store original events for navigation (preserves termid integrity)\n      card.originalEvents = events;\n      cards.push(card);\n    }\n\n    // Sort cards by earliest event date\n    cards.sort((a, b) => a.earliestDate - b.earliestDate);\n\n    return cards;\n  };\n\n  const _handleSectionSelect = async (section) => {\n    try {\n      // Set loading state for this specific section\n      setLoadingSection(section.sectionid);\n\n      // Try to load cached members first\n      let members = [];\n      try {\n        members = await databaseService.getMembers([section.sectionid]);\n      } catch (cacheError) {\n        // Ignore cache errors - will fallback to empty array\n      }\n      if (members.length > 0) {\n        onNavigateToMembers(section, members);\n      } else {\n        // No cached data - ask user if they want to fetch from OSM\n        setConfirmModalData({\n          title: 'Fetch Member Data',\n          message: `No member data found for \"${section.sectionname}\".\\n\\nWould you like to connect to OSM to fetch member data?`,\n          onConfirm: () => {\n            setShowConfirmModal(false);\n            // Redirect to OSM OAuth since we know the token is expired/invalid\n            const oauthUrl = generateOAuthUrl();\n            window.location.href = oauthUrl;\n          },\n          onCancel: () => {\n            setShowConfirmModal(false);\n            setLoadingSection(null);\n            // Handle cancel - show empty members screen for this specific section\n            onNavigateToMembers(section, []);\n          },\n          confirmText: 'Fetch Data',\n          cancelText: 'Use Empty',\n        });\n        setShowConfirmModal(true);\n\n        // The modal will handle the user's response\n        return;\n      }\n    } catch (err) {\n      logger.error(\n        'Error loading members for section',\n        {\n          error: err,\n          sectionId: section.sectionid,\n          sectionName: section.sectionname,\n        },\n        LOG_CATEGORIES.COMPONENT,\n      );\n      setError(`Failed to load members: ${err.message}`);\n\n      // Fallback to empty members screen\n      onNavigateToMembers(section, []);\n    } finally {\n      // Clear loading state\n      setLoadingSection(null);\n    }\n  };\n\n  const handleViewAttendees = async (eventCard) => {\n    try {\n      // Set loading state for this specific event card\n      setLoadingAttendees(eventCard.id);\n\n      // Extract all unique section IDs from the events in this card\n      const sectionIds = Array.from(\n        new Set(eventCard.events.map((event) => event.sectionid)),\n      );\n\n      // Stage 3: On-demand member loading with guaranteed data\n      let members = [];\n      try {\n        // First, try to load from cache\n        members = await databaseService.getMembers(sectionIds);\n\n        if (members.length === 0) {\n          logger.info(\n            'No cached members found - fetching on-demand',\n            {\n              sectionIds,\n              eventName: eventCard.name,\n            },\n            LOG_CATEGORIES.COMPONENT,\n          );\n\n          // No cached members - fetch immediately\n          const currentToken = getToken();\n          if (!currentToken) {\n            const oauthUrl = generateOAuthUrl();\n            window.location.href = oauthUrl;\n            return;\n          }\n\n          // Find the corresponding section objects for these IDs\n          const involvedSections = sections.filter((section) =>\n            sectionIds.includes(section.sectionid),\n          );\n\n          try {\n            members = await getListOfMembers(involvedSections, currentToken);\n            logger.info(\n              'Successfully fetched members on-demand',\n              {\n                memberCount: members.length,\n                sectionCount: involvedSections.length,\n              },\n              LOG_CATEGORIES.COMPONENT,\n            );\n          } catch (apiError) {\n            // Check if it's an authentication error\n            if (\n              apiError &&\n              typeof apiError === 'object' &&\n              (apiError.status === 401 ||\n                apiError.status === 403 ||\n                apiError.message?.includes('Invalid access token') ||\n                apiError.message?.includes('Token expired') ||\n                apiError.message?.includes('Unauthorized'))\n            ) {\n              const oauthUrl = generateOAuthUrl();\n              window.location.href = oauthUrl;\n              return;\n            }\n            throw apiError; // Re-throw non-auth errors\n          }\n        } else {\n          logger.info(\n            'Using cached members for attendance view',\n            {\n              memberCount: members.length,\n              sectionIds,\n            },\n            LOG_CATEGORIES.COMPONENT,\n          );\n        }\n      } catch (cacheErr) {\n        logger.warn(\n          'Error accessing member cache',\n          { error: cacheErr.message },\n          LOG_CATEGORIES.COMPONENT,\n        );\n        // Continue with empty members array - better than failing completely\n      }\n\n      // Navigate to attendance view with original events (preserves termid integrity)\n      const eventsToNavigate = eventCard.originalEvents || eventCard.events;\n      onNavigateToAttendance(eventsToNavigate, members);\n    } catch (err) {\n      logger.error(\n        'Error loading members for attendance view',\n        {\n          error: err,\n          eventName: eventCard.name,\n          eventCount: eventCard.events.length,\n        },\n        LOG_CATEGORIES.COMPONENT,\n      );\n      setError(`Failed to load members: ${err.message}`);\n    } finally {\n      // Clear loading state\n      setLoadingAttendees(null);\n    }\n  };\n\n  if (isActuallyLoading) {\n    return <LoadingScreen message=\"Loading dashboard...\" data-oid=\"g6pwk17\" />;\n  }\n\n  if (error) {\n    return (\n      <Alert variant=\"error\" className=\"m-4\" data-oid=\"3oq.x.h\">\n        <Alert.Title data-oid=\"d:fjt2d\">Error Loading Dashboard</Alert.Title>\n        <Alert.Description data-oid=\"4uunsvb\">{error}</Alert.Description>\n        <Alert.Actions data-oid=\"bd0v.w-\">\n          <button\n            onClick={loadInitialData}\n            type=\"button\"\n            className=\"inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base bg-scout-blue text-white hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light active:bg-scout-blue-dark transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n            data-oid=\"ahnj4wa\"\n          >\n            Retry\n          </button>\n        </Alert.Actions>\n      </Alert>\n    );\n  }\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\" data-oid=\"c47cc:8\">\n      {/* Header with sync info */}\n      <div\n        className=\"bg-white shadow-sm border-b border-gray-200 mb-6\"\n        data-oid=\"pprvno2\"\n      >\n        <div\n          className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4\"\n          data-oid=\"09tusng\"\n        >\n          <div className=\"flex justify-between items-center\" data-oid=\"3562u3z\">\n            <div data-oid=\"dk-vy.7\">\n              {/* Show queue stats if active */}\n              {(queueStats.processing || queueStats.queueLength > 0) && (\n                <div className=\"mt-2\" data-oid=\"t::a22m\">\n                  <p className=\"text-xs text-blue-600\" data-oid=\"mvnlyr9\">\n                    API Queue: {queueStats.processing ? 'Processing' : 'Idle'} •\n                    {queueStats.queueLength} pending •{' '}\n                    {queueStats.totalRequests} total\n                  </p>\n                </div>\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div\n        className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\"\n        data-oid=\"zza2fzu\"\n      >\n        {/* Sections Card */}\n        {currentView === 'sections' && (\n          <div className=\"mb-8\" id=\"sections-panel\" data-testid=\"sections-list\" data-oid=\"883.3lx\">\n            <SectionsList\n              sections={sections}\n              selectedSections={selectedSections}\n              onSectionToggle={handleSectionToggleForCard}\n              loadingSection={loadingSection}\n              allSections={sections}\n              data-oid=\"dmp670d\"\n            />\n          </div>\n        )}\n\n        {/* Events Card */}\n        {currentView === 'events' && (\n          <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" id=\"events-panel\" data-oid=\"ve3fjt:\">\n            <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"gycj.jl\">\n              <h2\n                className=\"text-lg font-semibold text-gray-900 m-0\"\n                data-oid=\"96:-cg1\"\n              >\n                Upcoming Events{' '}\n                {eventCards.length > 0 && `(${eventCards.length})`}\n              </h2>\n            </div>\n            <div className=\"p-4\" data-oid=\"tw4z.r8\">\n              {eventCards.length > 0 ? (\n                <div\n                  className=\"grid grid-cols-1 min-[830px]:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-6\"\n                  data-oid=\"0lg715h\"\n                >\n                  {eventCards.map((card) => (\n                    <EventCard\n                      key={card.id}\n                      eventCard={card}\n                      onViewAttendees={handleViewAttendees}\n                      loading={loadingAttendees === card.id}\n                      data-oid=\"9uno.dz\"\n                    />\n                  ))}\n                </div>\n              ) : (\n                <div className=\"text-center py-12\" data-oid=\"h2.dcru\">\n                  <div className=\"text-gray-500 mb-4\" data-oid=\"04h4e3l\">\n                    <svg\n                      className=\"mx-auto h-12 w-12 text-gray-400\"\n                      fill=\"none\"\n                      stroke=\"currentColor\"\n                      viewBox=\"0 0 24 24\"\n                      data-oid=\"vbk6.13\"\n                    >\n                      <path\n                        strokeLinecap=\"round\"\n                        strokeLinejoin=\"round\"\n                        strokeWidth=\"2\"\n                        d=\"M8 7V3a2 2 0 012-2h4a2 2 0 012 2v4m-6 4v10a2 2 0 002 2h4a2 2 0 002-2V11M9 7h6\"\n                        data-oid=\"n_dlzww\"\n                      />\n                    </svg>\n                  </div>\n                  <h3\n                    className=\"text-lg font-semibold text-gray-900 mb-2\"\n                    data-oid=\"dvun05:\"\n                  >\n                    No Upcoming Events\n                  </h3>\n                  <p className=\"text-gray-600 mb-4\" data-oid=\"p1iqx11\">\n                    {!lastSync\n                      ? 'Click \"Sign in to OSM\" in the header to retrieve event data.'\n                      : 'No events found for the next week or events from the past week. Click \"Sign in to OSM\" in the header to get the latest data.'}\n                  </p>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Confirmation Modal */}\n      <ConfirmModal\n        isOpen={showConfirmModal}\n        title={confirmModalData.title}\n        message={confirmModalData.message}\n        confirmText={confirmModalData.confirmText}\n        cancelText={confirmModalData.cancelText}\n        onConfirm={confirmModalData.onConfirm}\n        onCancel={\n          confirmModalData.onCancel ||\n          (() => {\n            setShowConfirmModal(false);\n            setLoadingSection(null);\n          })\n        }\n        data-oid=\"7pfgrfw\"\n      />\n    </div>\n  );\n}\n\nexport default EventDashboard;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventsCampGroups.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":11,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":11,"column":1,"nodeType":"Block","endLine":13,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useLocation, useNavigate, Link } from 'react-router-dom';\nimport LoadingScreen from '../../../shared/components/LoadingScreen.jsx';\nimport CampGroupsView from './CampGroupsView.jsx';\nimport { useAttendanceData } from '../hooks/useAttendanceData.js';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport { getUniqueSectionsFromEvents } from '../../../shared/utils/sectionHelpers.js';\nimport { notifyError } from '../../../shared/utils/notifications.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n *\n */\nfunction EventsCampGroups() {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const [events, setEvents] = useState([]);\n  const [members, setMembers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const {\n    attendanceData,\n    vikingEventData,\n    loading: attendanceLoading,\n    error: attendanceError,\n  } = useAttendanceData(events);\n\n  useEffect(() => {\n    const loadEventsData = async () => {\n      try {\n        setLoading(true);\n        \n        const stateEvents = location.state?.events;\n        const stateMembers = location.state?.members;\n        \n        if (stateEvents && stateEvents.length > 0) {\n          setEvents(stateEvents);\n          setMembers(stateMembers || []);\n        } else {\n          const eventsData = await databaseService.getEvents();\n          setEvents(eventsData || []);\n          \n          if (eventsData && eventsData.length > 0) {\n            const sectionsInvolved = Array.from(new Set(eventsData.map((e) => e.sectionid)));\n            const membersData = await databaseService.getMembers(sectionsInvolved);\n            setMembers(membersData || []);\n          }\n        }\n      } catch (err) {\n        logger.error('Failed to load events data for camp groups', { error: err.message }, LOG_CATEGORIES.ERROR);\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadEventsData();\n  }, [location.state]);\n\n  const getSummaryStats = () => {\n    if (!attendanceData || !members) return [];\n    \n    return attendanceData.map((record) => {\n      const memberData = members.find(m => parseInt(m.scoutid, 10) === parseInt(record.scoutid, 10));\n      if (!memberData) return null;\n\n      const shouldIncludeInSummary = (record) => {\n        const memberDetails = members.find(\n          (m) => parseInt(m.scoutid, 10) === parseInt(record.scoutid, 10),\n        );\n        if (!memberDetails) return true;\n\n        const personType = memberDetails.person_type;\n        return personType !== 'Leaders' && personType !== 'Young Leaders';\n      };\n\n      if (!shouldIncludeInSummary(record)) return null;\n\n      return {\n        scoutid: memberData.scoutid,\n        name: `${memberData.firstname} ${memberData.lastname}`,\n        firstname: memberData.firstname,\n        lastname: memberData.lastname,\n        person_type: memberData.person_type,\n        patrol_id: memberData.patrol_id,\n        patrolid: memberData.patrolid,\n        sectionid: record.sectionid,\n        vikingEventData: record.vikingEventData,\n        events: memberData.events,\n      };\n    }).filter(Boolean);\n  };\n\n  const handleBackToDashboard = () => {\n    navigate('/events');\n  };\n\n  const handleNavigateToRegister = () => {\n    navigate('/events/register', { state: { events, members } });\n  };\n\n  if (loading || attendanceLoading) {\n    return <LoadingScreen message=\"Loading camp groups...\" />;\n  }\n\n  if (error || attendanceError) {\n    return (\n      <div className=\"p-6\">\n        <div className=\"max-w-4xl mx-auto\">\n          <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6\">\n            <div className=\"text-red-600\">\n              <h2 className=\"text-lg font-semibold mb-2\">Error Loading Camp Groups</h2>\n              <p>{error || attendanceError}</p>\n              <button\n                onClick={handleBackToDashboard}\n                className=\"mt-4 px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark\"\n              >\n                Back to Events Dashboard\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (events.length === 0) {\n    return (\n      <div className=\"p-6\">\n        <div className=\"max-w-4xl mx-auto\">\n          <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6\">\n            <div className=\"text-center py-12\">\n              <div className=\"text-gray-500 mb-4\">\n                <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M8 7V3a1 1 0 011-1h6a1 1 0 011 1v4h3a1 1 0 110 2h-1v9a2 2 0 01-2 2H8a2 2 0 01-2-2V9H5a1 1 0 110-2h3zM9 3h6v4H9V3zm0 6h6v9H9V9z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Events Available</h3>\n              <p className=\"text-gray-600 mb-4\">\n                No events found for camp group management.\n              </p>\n              <button\n                onClick={handleBackToDashboard}\n                className=\"px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark\"\n              >\n                Back to Dashboard\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const summaryStats = getSummaryStats();\n  const uniqueSections = getUniqueSectionsFromEvents(events);\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"max-w-6xl mx-auto\">\n        {/* Navigation Tabs */}\n        <div className=\"border-b border-gray-200 mb-6\">\n          <nav className=\"-mb-px flex space-x-8\">\n            <Link\n              to=\"/events/overview\"\n              className=\"border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Overview\n            </Link>\n            <Link\n              to=\"/events/register\"\n              className=\"border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Register\n            </Link>\n            <span className=\"border-scout-blue text-scout-blue border-b-2 py-2 px-1 text-sm font-medium\">\n              Camp Groups\n            </span>\n          </nav>\n        </div>\n\n        {/* Camp Groups Header */}\n        <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6 mb-6\">\n          <div className=\"flex items-start justify-between mb-4\">\n            <div>\n              <h2 className=\"text-2xl font-bold text-gray-900\">Camp Groups Management</h2>\n              <p className=\"text-gray-600 mt-1\">\n                Manage camp group assignments for event attendees\n              </p>\n            </div>\n            <div className=\"flex space-x-3\">\n              <button\n                onClick={handleNavigateToRegister}\n                className=\"px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm\"\n              >\n                View Register\n              </button>\n              <button\n                onClick={handleBackToDashboard}\n                className=\"px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark text-sm\"\n              >\n                Back to Dashboard\n              </button>\n            </div>\n          </div>\n\n          {/* Quick Stats */}\n          <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">\n            <div className=\"bg-gray-50 p-4 rounded-lg\">\n              <div className=\"text-sm text-gray-600\">Total Events</div>\n              <div className=\"text-2xl font-bold text-gray-900\">{events.length}</div>\n            </div>\n            <div className=\"bg-gray-50 p-4 rounded-lg\">\n              <div className=\"text-sm text-gray-600\">Total Sections</div>\n              <div className=\"text-2xl font-bold text-gray-900\">{uniqueSections.length}</div>\n            </div>\n            <div className=\"bg-gray-50 p-4 rounded-lg\">\n              <div className=\"text-sm text-gray-600\">Eligible Members</div>\n              <div className=\"text-2xl font-bold text-gray-900\">{summaryStats.length}</div>\n            </div>\n            <div className=\"bg-gray-50 p-4 rounded-lg\">\n              <div className=\"text-sm text-gray-600\">Assigned to Groups</div>\n              <div className=\"text-2xl font-bold text-gray-900\">\n                {summaryStats.filter(member => member.vikingEventData?.CampGroup).length}\n              </div>\n            </div>\n          </div>\n\n          <div className=\"mt-4\">\n            <div className=\"text-sm text-gray-600\">\n              Note: Leaders and Young Leaders are automatically excluded from camp group assignments.\n            </div>\n          </div>\n        </div>\n\n        {/* Camp Groups Management */}\n        <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6\">\n          <CampGroupsView\n            events={events}\n            summaryStats={summaryStats}\n            members={members}\n            vikingEventData={vikingEventData}\n            onError={(errorMsg) => {\n              logger.error('Camp groups error', { error: errorMsg }, LOG_CATEGORIES.ERROR);\n              notifyError(`Camp groups error: ${errorMsg}`);\n            }}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default EventsCampGroups;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventsContainer.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":8,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":8,"column":1,"nodeType":"Block","endLine":10,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport EventDashboard from './EventDashboard.jsx';\nimport { EventAttendance } from './attendance';\nimport { notifyError, notifyWarning } from '../../../shared/utils/notifications.js';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n *\n */\nfunction EventsContainer() {\n  const [currentView, setCurrentView] = useState('dashboard');\n  const [navigationData, setNavigationData] = useState({});\n  // Notification handlers are now imported directly\n\n  const handleNavigateToAttendance = async (events, members = null) => {\n    try {\n      // If members are provided (from fresh API call), use them\n      // Otherwise, load cached members data for the attendance view\n      let membersData = members;\n\n      if (!membersData) {\n        const sectionsInvolved = Array.from(\n          new Set(events.map((e) => e.sectionid)),\n        );\n        \n        membersData = await databaseService.getMembers(sectionsInvolved);\n\n        // If no cached members found, show warning\n        if (!membersData || membersData.length === 0) {\n          notifyWarning(\n            'Member data not yet available. Please wait for sync to complete or try refreshing.',\n            { duration: 6000 },\n          );\n          return;\n        }\n      }\n\n      // Set new navigation data (will replace any existing data)\n      setNavigationData({ events, members: membersData });\n      setCurrentView('attendance');\n    } catch (error) {\n      logger.error(\n        'Error loading cached members',\n        { error: error.message },\n        LOG_CATEGORIES.ERROR,\n      );\n      notifyError(\n        'Unable to load member data for attendance view. Please try refreshing the page.',\n      );\n    }\n  };\n\n  const handleBackToDashboard = () => {\n    setCurrentView('dashboard');\n    setNavigationData({}); // Clear navigation data for proper state management\n  };\n\n  const renderCurrentView = () => {\n    switch (currentView) {\n    case 'attendance':\n      return (\n        <EventAttendance\n          events={navigationData.events || []}\n          members={navigationData.members || []}\n          onBack={handleBackToDashboard}\n        />\n      );\n    default:\n      return (\n        <EventDashboard\n          onNavigateToAttendance={handleNavigateToAttendance}\n        />\n      );\n    }\n  };\n\n  return renderCurrentView();\n}\n\nexport default EventsContainer;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventsLayout.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":10,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":10,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":81,"column":1,"nodeType":"Block","endLine":83,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":81,"column":1,"nodeType":"Block","endLine":83,"endColumn":4}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Outlet, useNavigate } from 'react-router-dom';\nimport { useAuth } from '../../auth';\nimport ResponsiveLayout from '../../../shared/components/layout/ResponsiveLayout.jsx';\nimport { notifyError, notifyInfo } from '../../../shared/utils/notifications.js';\nimport TokenExpiredDialog from '../../../shared/components/TokenExpiredDialog.jsx';\nimport MainNavigation from '../../../shared/components/layout/MainNavigation.jsx';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n *\n */\nfunction EventsLayoutContent() {\n  const navigate = useNavigate();\n  const {\n    user,\n    isOfflineMode,\n    authState,\n    lastSyncTime,\n    showTokenExpiredDialog,\n    hasCachedData,\n    handleReLogin,\n    handleStayOffline,\n    login,\n    logout,\n  } = useAuth();\n  \n  const [isRefreshing, setIsRefreshing] = React.useState(false);\n\n  const handleRefresh = async () => {\n    if (isOfflineMode) {\n      notifyInfo('Refresh is unavailable while offline.');\n      return;\n    }\n    if (isRefreshing) return;\n    setIsRefreshing(true);\n    try {\n      const { default: syncService } = await import('../../../shared/services/storage/sync.js');\n      await syncService.syncAll();\n    } catch (error) {\n      logger.error('Manual refresh failed', { error: error.message }, LOG_CATEGORIES.ERROR);\n      notifyError('Refresh failed. Please try again.');\n    } finally {\n      setIsRefreshing(false);\n    }\n  };\n\n  const handleNavigateToSectionMovements = () => {\n    navigate('/movers');\n  };\n\n  return (\n    <div className=\"events-layout\">\n      <ResponsiveLayout\n        user={user}\n        onLogout={logout}\n        onLogin={login}\n        onRefresh={handleRefresh}\n        currentView=\"events\"\n        isOfflineMode={isOfflineMode}\n        authState={authState}\n        lastSyncTime={lastSyncTime}\n        isRefreshing={isRefreshing}\n      >\n        <MainNavigation onNavigateToSectionMovements={handleNavigateToSectionMovements} />\n        {/* This is where nested route components will render */}\n        <Outlet />\n      </ResponsiveLayout>\n      \n      {/* Token expiration user choice dialog */}\n      <TokenExpiredDialog\n        isOpen={showTokenExpiredDialog}\n        onReLogin={handleReLogin}\n        onStayOffline={handleStayOffline}\n        hasCachedData={hasCachedData}\n      />\n    </div>\n  );\n}\n\n/**\n *\n */\nfunction EventsLayout() {\n  return <EventsLayoutContent />;\n}\n\nexport default EventsLayout;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventsOverview.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":17,"column":1,"nodeType":"Block","endLine":21,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":17,"column":1,"nodeType":"Block","endLine":21,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":19,"column":1,"nodeType":"Block","endLine":19,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onNavigateToAttendance\" description.","line":20,"column":1,"nodeType":"Block","endLine":20,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { Link, useLocation, useNavigate } from 'react-router-dom';\nimport LoadingScreen from '../../../shared/components/LoadingScreen.jsx';\nimport EventCard from './EventCard.jsx';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport {\n  fetchAllSectionEvents,\n  fetchEventAttendance,\n  groupEventsByName,\n  buildEventCard,\n  filterEventsByDateRange,\n  expandSharedEvents,\n} from '../../../shared/utils/eventDashboardHelpers.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\n\n/**\n *\n * @param root0\n * @param root0.onNavigateToAttendance\n */\nfunction EventsOverview({ onNavigateToAttendance: _onNavigateToAttendance }) {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const [eventCards, setEventCards] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [loadingAttendees, setLoadingAttendees] = useState(null);\n\n  // Build event cards similar to EventDashboard\n  useEffect(() => {\n    const buildEventCardsFromCache = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Load sections from cache\n        const sections = await databaseService.getSections();\n        \n        if (sections && sections.length > 0) {\n          logger.debug('Building event cards from cached data', {\n            sectionsCount: sections.length,\n          }, LOG_CATEGORIES.APP);\n          \n          // Use token if available for shared event detection, otherwise cache-only mode\n          const currentToken = getToken();\n          const cards = await buildEventCards(sections, currentToken);\n          setEventCards(cards);\n          \n          logger.debug('Event cards built successfully', {\n            cardsCount: cards.length,\n          }, LOG_CATEGORIES.APP);\n        } else {\n          logger.debug('No cached sections found', {}, LOG_CATEGORIES.APP);\n          setEventCards([]);\n        }\n      } catch (err) {\n        logger.error('Failed to build event cards for overview', { error: err.message }, LOG_CATEGORIES.ERROR);\n        setError(err.message);\n        setEventCards([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    buildEventCardsFromCache();\n  }, [location.state]);\n\n  // Build event cards function - copied from EventDashboard\n  const buildEventCards = async (sectionsData, token = null) => {\n    logger.debug(\n      'buildEventCards called',\n      {\n        sectionCount: sectionsData?.length || 0,\n        mode: token ? 'API' : 'CACHE',\n      },\n      LOG_CATEGORIES.COMPONENT,\n    );\n\n    const now = new Date();\n    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\n    // Fetch events for all sections with optimized terms loading\n    const allEvents = await fetchAllSectionEvents(sectionsData, token);\n\n    // Filter for future events and events from last week\n    const filteredEvents = filterEventsByDateRange(allEvents, oneWeekAgo);\n\n    // Fetch attendance data for filtered events (with shared event checking)\n    const attendanceMap = new Map();\n    for (const event of filteredEvents) {\n      try {\n        const attendanceData = await fetchEventAttendance(\n          event,\n          token,\n          filteredEvents,\n        );\n        if (attendanceData) {\n          attendanceMap.set(event.eventid, attendanceData);\n        }\n      } catch (err) {\n        logger.error(\n          'Error fetching attendance for event {eventId}',\n          {\n            error: err,\n            eventId: event.eventid,\n            eventName: event.name,\n          },\n          LOG_CATEGORIES.COMPONENT,\n        );\n      }\n    }\n\n    // Expand shared events to include all sections\n    const expandedEvents = expandSharedEvents(filteredEvents, attendanceMap);\n\n    // Group events by name\n    const eventGroups = groupEventsByName(expandedEvents);\n\n    // Convert groups to cards with attendance data\n    const cards = [];\n    for (const [eventName, events] of eventGroups) {\n      // Enrich events with attendance data without mutating originals\n      const eventsWithAttendance = events.map((event) => ({\n        ...event,\n        attendanceData: attendanceMap.get(event.eventid) || [],\n      }));\n\n      const card = buildEventCard(eventName, eventsWithAttendance);\n      // Store original events for navigation (preserves termid integrity)\n      card.originalEvents = events;\n      cards.push(card);\n    }\n\n    // Sort cards by earliest event date\n    cards.sort((a, b) => a.earliestDate - b.earliestDate);\n\n    return cards;\n  };\n\n  // Handle view attendees - copied from EventDashboard\n  const handleViewAttendees = async (eventCard) => {\n    try {\n      // Set loading state for this specific event card\n      setLoadingAttendees(eventCard.id);\n\n      // Navigate to attendance view with state\n      const eventsToNavigate = eventCard.originalEvents || eventCard.events;\n      navigate('/events/detail/' + encodeURIComponent(eventCard.name), {\n        state: {\n          events: eventsToNavigate,\n          members: [], // Will be loaded in detail view\n        },\n      });\n    } catch (err) {\n      logger.error(\n        'Error navigating to attendance view',\n        {\n          error: err,\n          eventName: eventCard.name,\n          eventCount: eventCard.events.length,\n        },\n        LOG_CATEGORIES.COMPONENT,\n      );\n      setError(`Failed to navigate: ${err.message}`);\n    } finally {\n      // Clear loading state\n      setLoadingAttendees(null);\n    }\n  };\n\n  // Debug logging\n  if (import.meta.env.DEV) {\n    console.log('EventsOverview Debug:', {\n      loading,\n      error,\n      eventCardsCount: eventCards.length,\n      locationState: location.state,\n    });\n  }\n\n  if (loading) {\n    return <LoadingScreen message=\"Loading events overview...\" />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-6\">\n        <div className=\"max-w-4xl mx-auto\">\n          <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6\">\n            <div className=\"text-red-600\">\n              <h2 className=\"text-lg font-semibold mb-2\">Error Loading Overview</h2>\n              <p>{error}</p>\n              <button\n                onClick={() => navigate('/events')}\n                className=\"mt-4 px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark\"\n              >\n                Back to Events Dashboard\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"max-w-6xl mx-auto\">\n        {/* Navigation Tabs */}\n        <div className=\"border-b border-gray-200 mb-6\">\n          <nav className=\"-mb-px flex space-x-8\">\n            <Link\n              to=\"/events/overview\"\n              className=\"border-scout-blue text-scout-blue border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Overview\n            </Link>\n            <Link\n              to=\"/events/register\"\n              className=\"border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Register\n            </Link>\n            <Link\n              to=\"/events/camp-groups\"\n              className=\"border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Camp Groups\n            </Link>\n          </nav>\n        </div>\n\n        {/* Events Overview Content */}\n        <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6\">\n          <div className=\"mb-6\">\n            <h2 className=\"text-2xl font-bold text-gray-900\">Events Overview</h2>\n            <p className=\"text-gray-600 mt-1\">\n              Upcoming events grouped by name with attendance data\n            </p>\n          </div>\n\n          {eventCards.length === 0 ? (\n            <div className=\"text-center py-12\">\n              <div className=\"text-gray-500 mb-4\">\n                <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M8 7V3a2 2 0 012-2h4a2 2 0 012 2v4m-6 4v10a2 2 0 002 2h4a2 2 0 002-2V11M9 7h6\" />\n                </svg>\n              </div>\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Upcoming Events</h3>\n              <p className=\"text-gray-600 mb-4\">\n                No events found for the next week or events from the past week. Make sure you&apos;re connected and data has been synced.\n              </p>\n              <Link\n                to=\"/events\"\n                className=\"px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark\"\n              >\n                Back to Events Dashboard\n              </Link>\n            </div>\n          ) : (\n            <div className=\"grid grid-cols-1 min-[830px]:grid-cols-2 lg:grid-cols-2 xl:grid-cols-3 gap-6\">\n              {eventCards.map((card) => (\n                <EventCard\n                  key={card.id}\n                  eventCard={card}\n                  onViewAttendees={handleViewAttendees}\n                  loading={loadingAttendees === card.id}\n                />\n              ))}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default EventsOverview;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventsRegister.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":16,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":16,"column":1,"nodeType":"Block","endLine":18,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from 'react';\nimport { Link, useLocation, useNavigate } from 'react-router-dom';\nimport { cn } from '../../../shared/utils/cn';\nimport LoadingScreen from '../../../shared/components/LoadingScreen.jsx';\nimport { MemberDetailModal } from '../../../shared/components/ui';\nimport SignInOutButton from './SignInOutButton.jsx';\nimport CompactAttendanceFilter from './CompactAttendanceFilter.jsx';\nimport { useAttendanceData } from '../hooks/useAttendanceData.js';\nimport { useSignInOut } from '../../../shared/hooks/useSignInOut.js';\nimport { notifyError, notifyWarning } from '../../../shared/utils/notifications.js';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport { getUniqueSectionsFromEvents } from '../../../shared/utils/sectionHelpers.js';\nimport { findMemberSectionName } from '../../../shared/utils/sectionHelpers.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n *\n */\nfunction EventsRegister() {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const [events, setEvents] = useState([]);\n  const [members, setMembers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Modal and UI state\n  const [selectedMember, setSelectedMember] = useState(null);\n  const [showMemberModal, setShowMemberModal] = useState(false);\n  \n  // Filtering state\n  const [attendanceFilters, setAttendanceFilters] = useState({\n    yes: true,\n    no: true,\n    invited: true,\n    notInvited: true,\n  });\n\n  const [sectionFilters, setSectionFilters] = useState({});\n\n  // Sorting state\n  const [sortConfig, setSortConfig] = useState({ key: 'member', direction: 'asc' });\n\n\n  // Get events data from navigation state or load from database\n  useEffect(() => {\n    const loadEventsData = async () => {\n      try {\n        setLoading(true);\n        \n        // Try to get events from router state first (if navigated from dashboard)\n        const stateEvents = location.state?.events;\n        const stateMembers = location.state?.members;\n        \n        if (stateEvents && stateEvents.length > 0) {\n          setEvents(stateEvents);\n          setMembers(stateMembers || []);\n        } else {\n          // Fallback: load events from database\n          const eventsData = await databaseService.getEvents();\n          setEvents(eventsData || []);\n          \n          if (eventsData && eventsData.length > 0) {\n            const sectionsInvolved = Array.from(new Set(eventsData.map((e) => e.sectionid)));\n            const membersData = await databaseService.getMembers(sectionsInvolved);\n            setMembers(membersData || []);\n          }\n        }\n      } catch (err) {\n        logger.error('Failed to load events data for register', { error: err.message }, LOG_CATEGORIES.ERROR);\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadEventsData();\n  }, [location.state]);\n\n  // Use attendance data hook for registration data\n  const {\n    attendanceData,\n    loading: attendanceLoading,\n    error: attendanceError,\n    loadVikingEventData,\n  } = useAttendanceData(events);\n\n  // Use sign in/out hook\n  const { buttonLoading, handleSignInOut } = useSignInOut(\n    events,\n    loadVikingEventData,\n    { notifyError, notifyWarning },\n  );\n\n  // Initialize section filters when events/members load\n  useEffect(() => {\n    if (events.length > 0) {\n      const uniqueSections = getUniqueSectionsFromEvents(events);\n      const initialFilters = {};\n      uniqueSections.forEach((section) => {\n        initialFilters[section.sectionid] = true;\n      });\n      setSectionFilters(initialFilters);\n    }\n  }, [events]);\n\n  // Create summary stats for the register view\n  const summaryStats = useMemo(() => {\n    if (!events.length || !members.length || !attendanceData.length) {\n      return [];\n    }\n\n    // Group attendance data by member\n    const memberStats = {};\n    \n    attendanceData.forEach(attendance => {\n      const scoutidAsNumber = parseInt(attendance.scoutid, 10);\n      const member = members.find(m => m.scoutid === scoutidAsNumber);\n      \n      if (!member) return;\n\n      const memberId = member.scoutid;\n      if (!memberStats[memberId]) {\n        memberStats[memberId] = {\n          scoutid: memberId,\n          name: `${member.firstname} ${member.lastname}`.trim(),\n          sectionname: findMemberSectionName(member, events),\n          events: [],\n        };\n      }\n\n      memberStats[memberId].events.push(attendance);\n    });\n\n    return Object.values(memberStats);\n  }, [events, members, attendanceData]);\n\n  // Filter summary stats based on current filters\n  const filteredSummaryStats = useMemo(() => {\n    return summaryStats.filter(member => {\n      // Section filter\n      const memberSectionId = members.find(m => m.scoutid === member.scoutid)?.sectionid;\n      if (memberSectionId && !sectionFilters[memberSectionId]) {\n        return false;\n      }\n\n      // Attendance filter - check if member has any events matching attendance filters\n      const hasMatchingAttendance = member.events.some(event => {\n        if (event.attending === 'yes' && attendanceFilters.yes) return true;\n        if (event.attending === 'no' && attendanceFilters.no) return true;\n        return false;\n      });\n\n      const isInvited = member.events.length > 0;\n      const isNotInvited = member.events.length === 0;\n\n      if (isInvited && !attendanceFilters.invited) return false;\n      if (isNotInvited && !attendanceFilters.notInvited) return false;\n\n      return hasMatchingAttendance || isNotInvited;\n    });\n  }, [summaryStats, sectionFilters, attendanceFilters, members]);\n\n  // Sort data\n  const sortData = (data, key, direction) => {\n    return [...data].sort((a, b) => {\n      let aValue, bValue;\n\n      switch (key) {\n      case 'member':\n        aValue = a.name?.toLowerCase() || '';\n        bValue = b.name?.toLowerCase() || '';\n        break;\n      case 'attendance':\n        // Sort by primary attendance status\n        aValue = a.events[0]?.attending || 'none';\n        bValue = b.events[0]?.attending || 'none';\n        break;\n      default:\n        aValue = a[key] || '';\n        bValue = b[key] || '';\n      }\n\n      if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n      if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n      return 0;\n    });\n  };\n\n  const handleSort = (key) => {\n    setSortConfig(prev => ({\n      key,\n      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc',\n    }));\n  };\n\n  const getSortIcon = (key) => {\n    if (sortConfig.key !== key) return '↕️';\n    return sortConfig.direction === 'asc' ? '↑' : '↓';\n  };\n\n  // Handle member click for detailed view\n  const handleMemberClick = (member) => {\n    setSelectedMember(member);\n    setShowMemberModal(true);\n  };\n\n  // Get comprehensive member data for modal\n  const getComprehensiveMemberData = (memberData) => {\n    const scoutidAsNumber = parseInt(memberData.scoutid, 10);\n    const cachedMember = members?.find((m) => m.scoutid === scoutidAsNumber);\n    \n    if (!cachedMember) {\n      return {\n        name: `${memberData.firstname || ''} ${memberData.lastname || ''}`.trim(),\n        section: memberData.sectionname || '',\n        attendance: 'Unknown',\n        patrol: '',\n        age: '',\n      };\n    }\n\n    return {\n      ...cachedMember,\n      name: `${cachedMember.firstname || ''} ${cachedMember.lastname || ''}`.trim(),\n      section: findMemberSectionName(cachedMember, events),\n    };\n  };\n\n  if (loading || attendanceLoading) {\n    return <LoadingScreen message=\"Loading events register...\" />;\n  }\n\n  if (error || attendanceError) {\n    return (\n      <div className=\"p-6\">\n        <div className=\"max-w-4xl mx-auto\">\n          <div className={cn('bg-white rounded-lg border border-gray-200 shadow-sm p-6')}>\n            <div className=\"text-red-600\">\n              <h2 className=\"text-lg font-semibold mb-2\">Error Loading Register</h2>\n              <p>{error || attendanceError}</p>\n              <button\n                onClick={() => navigate('/events')}\n                className=\"mt-4 px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark\"\n              >\n                Back to Events Dashboard\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"max-w-6xl mx-auto\">\n        {/* Navigation Tabs */}\n        <div className=\"border-b border-gray-200 mb-6\">\n          <nav className=\"-mb-px flex space-x-8\">\n            <Link\n              to=\"/events/overview\"\n              className=\"border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Overview\n            </Link>\n            <Link\n              to=\"/events/register\"\n              className=\"border-scout-blue text-scout-blue border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Register\n            </Link>\n            <Link\n              to=\"/events/camp-groups\"\n              className=\"border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 border-b-2 py-2 px-1 text-sm font-medium\"\n            >\n              Camp Groups\n            </Link>\n          </nav>\n        </div>\n\n        <div className={cn('bg-white rounded-lg border border-gray-200 shadow-sm p-6')}>\n          <div className=\"mb-6\">\n            <h2 className=\"text-2xl font-bold text-gray-900\">Event Registration</h2>\n            <p className=\"text-gray-600 mt-1\">\n              Manage event attendance and sign-in/out for members\n            </p>\n          </div>\n\n          {/* Filters */}\n          {events.length > 0 && (\n            <div className=\"mb-6\">\n              <CompactAttendanceFilter\n                attendanceFilters={attendanceFilters}\n                onAttendanceFilterChange={setAttendanceFilters}\n                sectionFilters={sectionFilters}\n                onSectionFilterChange={setSectionFilters}\n                uniqueSections={getUniqueSectionsFromEvents(events)}\n              />\n            </div>\n          )}\n\n          {events.length === 0 ? (\n            <div className=\"text-center py-12\">\n              <div className=\"text-gray-500 mb-4\">\n                <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M8 7V3a1 1 0 011-1h6a1 1 0 011 1v4h3a1 1 0 110 2h-1v9a2 2 0 01-2 2H8a2 2 0 01-2-2V9H5a1 1 0 110-2h3zM9 3h6v4H9V3zm0 6h6v9H9V9z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Events Available</h3>\n              <p className=\"text-gray-600 mb-4\">\n                No events found for registration. Make sure you&apos;re connected and data has been synced.\n              </p>\n              <Link\n                to=\"/events\"\n                className=\"px-4 py-2 bg-scout-blue text-white rounded hover:bg-scout-blue-dark\"\n              >\n                Back to Dashboard\n              </Link>\n            </div>\n          ) : filteredSummaryStats.length === 0 ? (\n            <div className=\"text-center py-12\">\n              <div className=\"text-gray-500 mb-4\">\n                <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z\" />\n                </svg>\n              </div>\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Records Match Filters</h3>\n              <p className=\"text-gray-600 mb-4\">\n                No attendance records match your current filter settings. Try adjusting the filters above.\n              </p>\n              <button\n                className=\"inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base bg-scout-blue text-white hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light active:bg-scout-blue-dark transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n                onClick={() => {\n                  setAttendanceFilters({\n                    yes: true,\n                    no: true,\n                    invited: true,\n                    notInvited: true,\n                  });\n                  // Reset section filters to show all sections\n                  const allSectionsEnabled = {};\n                  getUniqueSectionsFromEvents(events).forEach((section) => {\n                    allSectionsEnabled[section.sectionid] = true;\n                  });\n                  setSectionFilters(allSectionsEnabled);\n                }}\n                type=\"button\"\n              >\n                Show All Records\n              </button>\n            </div>\n          ) : (\n            <div className=\"overflow-x-auto\">\n              <table className=\"min-w-full divide-y divide-gray-200\">\n                <thead className=\"bg-gray-50\">\n                  <tr>\n                    <th\n                      className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100\"\n                      onClick={() => handleSort('member')}\n                    >\n                      <div className=\"flex items-center\">\n                        Member {getSortIcon('member')}\n                      </div>\n                    </th>\n                    <th className=\"px-2 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                      Actions\n                    </th>\n                    <th\n                      className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100\"\n                      onClick={() => handleSort('attendance')}\n                    >\n                      <div className=\"flex items-center\">\n                        Status {getSortIcon('attendance')}\n                      </div>\n                    </th>\n                    <th className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                      Section\n                    </th>\n                    <th className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                      Events Count\n                    </th>\n                  </tr>\n                </thead>\n                <tbody className=\"bg-white divide-y divide-gray-200\">\n                  {sortData(filteredSummaryStats, sortConfig.key, sortConfig.direction).map((member, index) => {\n                    const primaryEvent = member.events[0];\n                    const rawStatus = primaryEvent?.attending ?? '';\n                    const attendanceStatus = String(rawStatus).toLowerCase();\n                    \n                    return (\n                      <tr key={member.scoutid || index} className=\"hover:bg-gray-50\">\n                        <td className=\"px-3 py-2\">\n                          <button\n                            onClick={() => handleMemberClick({\n                              scoutid: member.scoutid,\n                              firstname: member.name.split(' ')[0],\n                              lastname: member.name.split(' ').slice(1).join(' '),\n                              sectionname: member.sectionname,\n                            })}\n                            className=\"font-semibold text-scout-blue hover:text-scout-blue-dark cursor-pointer transition-colors text-left break-words whitespace-normal leading-tight max-w-[120px] block text-xs\"\n                          >\n                            {member.name}\n                          </button>\n                        </td>\n                        <td className=\"px-2 py-2 text-center\">\n                          <SignInOutButton\n                            member={member}\n                            onSignInOut={handleSignInOut}\n                            loading={buttonLoading?.[member.scoutid] || false}\n                          />\n                        </td>\n                        <td className=\"px-3 py-2 whitespace-nowrap\">\n                          <span\n                            className={cn(\n                              'inline-flex items-center font-medium rounded-full px-3 py-1 text-sm',\n                              (() => {\n                                if (attendanceStatus === 'yes') return 'bg-scout-green text-white';\n                                if (attendanceStatus === 'no') return 'bg-scout-red text-white';\n                                if (attendanceStatus === 'invited') return 'bg-scout-blue text-white';\n                                return 'bg-gray-50 text-gray-600 border border-gray-200';\n                              })(),\n                            )}\n                          >\n                            {(() => {\n                              if (attendanceStatus === 'yes') return 'Attending';\n                              if (attendanceStatus === 'no') return 'Not Attending';\n                              if (attendanceStatus === 'invited') return 'Invited';\n                              return 'Not Invited';\n                            })()}\n                          </span>\n                        </td>\n                        <td className=\"px-3 py-2 whitespace-nowrap text-sm text-gray-900\">\n                          {member.sectionname}\n                        </td>\n                        <td className=\"px-3 py-2 whitespace-nowrap text-sm text-gray-500\">\n                          {member.events.length}\n                        </td>\n                      </tr>\n                    );\n                  })}\n                </tbody>\n              </table>\n            </div>\n          )}\n        </div>\n\n        {/* Member Detail Modal */}\n        {showMemberModal && selectedMember && (\n          <MemberDetailModal\n            memberData={getComprehensiveMemberData(selectedMember)}\n            isOpen={showMemberModal}\n            onClose={() => {\n              setShowMemberModal(false);\n              setSelectedMember(null);\n            }}\n            vikingEventData={getComprehensiveMemberData(selectedMember)}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default EventsRegister;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/EventsRouter.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":7,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":7,"column":1,"nodeType":"Block","endLine":9,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Routes, Route, Navigate } from 'react-router-dom';\nimport { useNavigate } from 'react-router-dom';\nimport MainNavigation from '../../../shared/components/layout/MainNavigation.jsx';\nimport EventsContainer from './EventsContainer.jsx';\n\n/**\n *\n */\nfunction EventsRouter() {\n  const navigate = useNavigate();\n\n  const handleNavigateToSectionMovements = () => {\n    navigate('/movers');\n  };\n\n  return (\n    <>\n      <MainNavigation onNavigateToSectionMovements={handleNavigateToSectionMovements} />\n      <Routes>\n        {/* Default events route - uses state-based navigation like LegacyApp */}\n        <Route index element={<EventsContainer />} />\n        \n        {/* Catch-all redirect for unknown nested routes */}\n        <Route path=\"*\" element={<Navigate to=\"/events\" replace />} />\n      </Routes>\n    </>\n  );\n}\n\nexport default EventsRouter;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/GroupNamesEditModal.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":16,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\nimport { Alert } from '../../../shared/components/ui';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n * Modal for editing camp group names\n * Allows bulk renaming of groups with validation and multi-section support\n *\n * @param {object} props - Component props\n * @param {boolean} props.isOpen - Whether modal is open\n * @param {Function} props.onClose - Close modal callback\n * @param {object} props.groups - Current groups object from organizedGroups.groups\n * @param {Function} props.onRename - Rename callback with (oldName, newName, membersBySection)\n * @param {Function} props.onDelete - Delete callback with (groupName, membersBySection)\n * @param {boolean} props.loading - Whether rename operation is in progress\n */\nfunction GroupNamesEditModal({\n  isOpen,\n  onClose,\n  groups = {},\n  onRename,\n  onDelete,\n  loading = false,\n}) {\n  const [groupNames, setGroupNames] = useState({});\n  const [errors, setErrors] = useState({});\n  const [hasChanges, setHasChanges] = useState(false);\n\n  // Initialize group names when modal opens or groups change\n  useEffect(() => {\n    if (isOpen && groups) {\n      const initialNames = {};\n      Object.entries(groups).forEach(([groupName]) => {\n        // Use group name without \"Group \" prefix for editing\n        const displayName = groupName.replace(/^Group /, '');\n        initialNames[groupName] = displayName;\n      });\n      setGroupNames(initialNames);\n      setErrors({});\n      setHasChanges(false);\n    }\n  }, [isOpen, groups]);\n\n  // Validate group names for uniqueness and constraints\n  const validateNames = useCallback((names) => {\n    const newErrors = {};\n    const usedNames = new Set();\n\n    Object.entries(names).forEach(([originalGroupName, newName]) => {\n      const trimmedName = newName.trim();\n      const lowerName = trimmedName.toLowerCase();\n\n      // Required field\n      if (!trimmedName) {\n        newErrors[originalGroupName] = 'Group name is required';\n        return;\n      }\n\n      // Check for duplicates\n      if (usedNames.has(lowerName)) {\n        newErrors[originalGroupName] = 'Group name must be unique';\n        return;\n      }\n\n      // Check for reserved names - only block \"Unassigned\" for non-unassigned groups\n      if (\n        lowerName === 'unassigned' &&\n        originalGroupName !== 'Group Unassigned'\n      ) {\n        newErrors[originalGroupName] = '\"Unassigned\" is a reserved name';\n        return;\n      }\n\n      // Character validation (basic)\n      if (!/^[a-zA-Z0-9\\s\\-_]+$/.test(trimmedName)) {\n        newErrors[originalGroupName] =\n          'Only letters, numbers, spaces, hyphens and underscores allowed';\n        return;\n      }\n\n      // Length validation\n      if (trimmedName.length > 20) {\n        newErrors[originalGroupName] =\n          'Group name too long (max 20 characters)';\n        return;\n      }\n\n      usedNames.add(lowerName);\n    });\n\n    return newErrors;\n  }, []);\n\n  // Handle name change\n  const handleNameChange = useCallback(\n    (originalGroupName, newValue) => {\n      setGroupNames((prev) => {\n        const updated = { ...prev, [originalGroupName]: newValue };\n\n        // Check if there are changes from original\n        const hasActualChanges = Object.entries(updated).some(\n          ([groupName, newName]) => {\n            const originalDisplayName = groupName.replace(/^Group /, '');\n            return newName.trim() !== originalDisplayName;\n          },\n        );\n\n        setHasChanges(hasActualChanges);\n\n        // Validate on each change\n        const validationErrors = validateNames(updated);\n        setErrors(validationErrors);\n\n        return updated;\n      });\n    },\n    [validateNames],\n  );\n\n  // Handle save\n  const handleSave = useCallback(async () => {\n    if (loading) return;\n\n    const validationErrors = validateNames(groupNames);\n    if (Object.keys(validationErrors).length > 0) {\n      setErrors(validationErrors);\n      return;\n    }\n\n    // Process renames\n    const renames = [];\n    Object.entries(groupNames).forEach(([originalGroupName, newName]) => {\n      const trimmedNewName = newName.trim();\n      const originalDisplayName = originalGroupName.replace(/^Group /, '');\n\n      if (trimmedNewName !== originalDisplayName) {\n        const group = groups[originalGroupName];\n        if (group) {\n          // Organize members by section for multi-section API calls\n          const membersBySection = {};\n\n          [...(group.youngPeople || []), ...(group.leaders || [])].forEach(\n            (member) => {\n              const sectionId = member.sectionid;\n              if (!membersBySection[sectionId]) {\n                membersBySection[sectionId] = [];\n              }\n              membersBySection[sectionId].push(member);\n            },\n          );\n\n          renames.push({\n            oldName: originalGroupName,\n            newName: trimmedNewName,\n            membersBySection,\n            group,\n          });\n        }\n      }\n    });\n\n    if (renames.length === 0) {\n      logger.info('No group names to rename', {}, LOG_CATEGORIES.APP);\n      onClose();\n      return;\n    }\n\n    logger.info(\n      'Processing group renames',\n      {\n        renameCount: renames.length,\n        totalGroups: Object.keys(groups).length,\n      },\n      LOG_CATEGORIES.APP,\n    );\n\n    // Execute renames through callback\n    for (const rename of renames) {\n      try {\n        await onRename(rename.oldName, rename.newName, rename.membersBySection);\n      } catch (error) {\n        logger.error(\n          'Failed to rename group',\n          {\n            oldName: rename.oldName,\n            newName: rename.newName,\n            error: error.message,\n          },\n          LOG_CATEGORIES.ERROR,\n        );\n\n        // Continue with other renames even if one fails\n        continue;\n      }\n    }\n\n    // Close modal after all renames are processed\n    onClose();\n  }, [groupNames, groups, onRename, onClose, loading, validateNames]);\n\n  // Handle delete group\n  const handleDeleteGroup = useCallback(\n    async (groupName) => {\n      if (loading || !onDelete) return;\n\n      const group = groups[groupName];\n      if (!group) return;\n\n      // Organize members by section for multi-section API calls\n      const membersBySection = {};\n\n      [...(group.youngPeople || []), ...(group.leaders || [])].forEach(\n        (member) => {\n          const sectionId = member.sectionid;\n          if (!membersBySection[sectionId]) {\n            membersBySection[sectionId] = [];\n          }\n          membersBySection[sectionId].push(member);\n        },\n      );\n\n      const memberCount = Object.values(membersBySection).reduce(\n        (sum, members) => sum + members.length,\n        0,\n      );\n\n      // Debug: Log exactly which members are being deleted\n      logger.info(\n        'Group delete preparation',\n        {\n          groupName,\n          memberCount,\n          membersToDelete: Object.fromEntries(\n            Object.entries(membersBySection).map(([sectionId, members]) => [\n              sectionId,\n              members.map((m) => ({\n                scoutid: m.scoutid,\n                name: m.name || `${m.firstname} ${m.lastname}`,\n              })),\n            ]),\n          ),\n        },\n        LOG_CATEGORIES.APP,\n      );\n\n      if (memberCount === 0) {\n        logger.info(\n          'No members to delete for empty group',\n          { groupName },\n          LOG_CATEGORIES.APP,\n        );\n        return;\n      }\n\n      // Confirm deletion\n      const confirmed = window.confirm(\n        `Delete \"${groupName}\" and move ${memberCount} member${memberCount !== 1 ? 's' : ''} to Unassigned?`,\n      );\n\n      if (!confirmed) return;\n\n      try {\n        await onDelete(groupName, membersBySection);\n        onClose();\n      } catch (error) {\n        logger.error(\n          'Failed to delete group',\n          {\n            groupName,\n            error: error.message,\n          },\n          LOG_CATEGORIES.ERROR,\n        );\n      }\n    },\n    [groups, onDelete, loading, onClose],\n  );\n\n  // Handle cancel\n  const handleCancel = useCallback(() => {\n    if (loading) return;\n    onClose();\n  }, [onClose, loading]);\n\n  if (!isOpen) return null;\n\n  const groupEntries = Object.entries(groups).sort((a, b) => {\n    // Sort: numbered groups first, then unassigned last\n    const [nameA] = a;\n    const [nameB] = b;\n\n    if (nameA === 'Group Unassigned') return 1;\n    if (nameB === 'Group Unassigned') return -1;\n\n    const numA = parseInt(nameA.replace('Group ', '')) || 0;\n    const numB = parseInt(nameB.replace('Group ', '')) || 0;\n    return numA - numB;\n  });\n\n  return (\n    <div\n      className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\"\n      data-oid=\"ksa0d1_\"\n    >\n      <div\n        className=\"bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden\"\n        data-oid=\"_xzti1v\"\n      >\n        {/* Header */}\n        <div className=\"px-6 py-4 border-b border-gray-200\" data-oid=\"w:j50.b\">\n          <h2\n            className=\"text-xl font-semibold text-gray-900\"\n            data-oid=\"b0x9x7h\"\n          >\n            Edit Group Names\n          </h2>\n          <p className=\"text-sm text-gray-600 mt-1\" data-oid=\"18iiy_7\">\n            Rename camp groups - all members in each group will be updated\n          </p>\n        </div>\n\n        {/* Content */}\n        <div\n          className=\"px-6 py-4 overflow-y-auto max-h-[60vh]\"\n          data-oid=\"fbpcw7a\"\n        >\n          {Object.keys(errors).length > 0 && (\n            <Alert variant=\"error\" className=\"mb-4\" data-oid=\"9i3l0tz\">\n              <Alert.Title data-oid=\"4qhsz54\">Validation Errors</Alert.Title>\n              <Alert.Description data-oid=\"e4spk6t\">\n                Please fix the errors below before saving.\n              </Alert.Description>\n            </Alert>\n          )}\n\n          <div className=\"space-y-4\" data-oid=\"stc4uf5\">\n            {groupEntries.map(([originalGroupName, group]) => {\n              const memberCount =\n                (group.youngPeople?.length || 0) + (group.leaders?.length || 0);\n              const currentValue = groupNames[originalGroupName] || '';\n              const hasError = errors[originalGroupName];\n\n              return (\n                <div\n                  key={originalGroupName}\n                  className=\"flex items-center space-x-4 p-4 border rounded-lg\"\n                  data-oid=\"ilsgv4g\"\n                >\n                  <div\n                    className=\"flex-shrink-0 w-20 text-sm text-gray-600\"\n                    data-oid=\"nszj1qy\"\n                  >\n                    {memberCount} member{memberCount !== 1 ? 's' : ''}\n                  </div>\n\n                  <div className=\"flex-1\" data-oid=\"-ed6jek\">\n                    <input\n                      id={`group-${originalGroupName}`}\n                      type=\"text\"\n                      value={currentValue}\n                      onChange={(e) =>\n                        handleNameChange(originalGroupName, e.target.value)\n                      }\n                      placeholder=\"Enter new group name\"\n                      className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-scout-blue ${\n                        hasError ? 'border-red-500 focus:border-red-500 focus:ring-red-200' : 'border-gray-300'\n                      }`}\n                      disabled={loading}\n                      data-oid=\"vy.2us4\"\n                    />\n\n                    {hasError && (\n                      <p\n                        className=\"text-red-500 text-xs mt-1\"\n                        data-oid=\"zmfjdao\"\n                      >\n                        {hasError}\n                      </p>\n                    )}\n                  </div>\n\n                  {/* Delete button - don't show for Unassigned group */}\n                  {originalGroupName !== 'Group Unassigned' &&\n                    memberCount > 0 && (\n                    <button\n                      onClick={() => handleDeleteGroup(originalGroupName)}\n                      disabled={loading}\n                      className=\"px-3 py-1.5 text-sm border border-scout-red-light text-scout-red hover:text-scout-red-dark hover:bg-scout-red-light hover:bg-opacity-10 disabled:opacity-50 disabled:cursor-not-allowed rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-scout-red-light focus:ring-opacity-50\"\n                      type=\"button\"\n                      title={`Delete ${originalGroupName} (move ${memberCount} member${memberCount !== 1 ? 's' : ''} to Unassigned)`}\n                      data-oid=\":t.ilsz\"\n                    >\n                        Delete\n                    </button>\n                  )}\n                </div>\n              );\n            })}\n          </div>\n\n          {groupEntries.length === 0 && (\n            <div className=\"text-center py-8 text-gray-500\" data-oid=\"wrs_muw\">\n              No groups available to rename\n            </div>\n          )}\n        </div>\n\n        {/* Footer */}\n        <div\n          className=\"px-6 py-4 border-t border-gray-200 flex justify-end space-x-3\"\n          data-oid=\"5st6.ue\"\n        >\n          <button\n            onClick={handleCancel}\n            disabled={loading}\n            className=\"px-4 py-2 border border-gray-300 text-gray-700 hover:text-gray-900 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-scout-blue focus:ring-opacity-50\"\n            type=\"button\"\n            data-oid=\"qsz0ya4\"\n          >\n            Cancel\n          </button>\n          <button\n            onClick={handleSave}\n            disabled={loading || Object.keys(errors).length > 0 || !hasChanges}\n            className=\"px-4 py-2 bg-scout-blue text-white hover:bg-scout-blue-dark disabled:opacity-50 disabled:cursor-not-allowed rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-scout-blue-light focus:ring-opacity-50\"\n            type=\"button\"\n            data-oid=\"a9cq49p\"\n          >\n            {loading ? 'Saving...' : 'Save Changes'}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default GroupNamesEditModal;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/SignInOutButton.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.member\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSignInOut\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.loading\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.disabled\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.member\n * @param root0.onSignInOut\n * @param root0.loading\n * @param root0.disabled\n */\nfunction SignInOutButton({ \n  member, \n  onSignInOut, \n  loading,\n  disabled,\n}) {\n  const isSignedIn = member.isSignedIn;\n\n  const handleClick = () => {\n    const action = isSignedIn ? 'signout' : 'signin';\n    onSignInOut(member, action);\n  };\n\n  return (\n    <button\n      onClick={handleClick}\n      disabled={disabled || loading}\n      className={`inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed ${\n        isSignedIn\n          ? 'bg-error text-white hover:bg-red-600 focus:ring-red-300 active:bg-red-700'\n          : 'bg-scout-green text-white hover:bg-scout-green-dark focus:ring-scout-green-light active:bg-scout-green-dark'\n      }`}\n    >\n      {loading ? 'Processing...' : (isSignedIn ? 'Sign Out' : 'Sign In')}\n    </button>\n  );\n}\n\nexport default SignInOutButton;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/AttendanceFilters.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":5,"column":1,"nodeType":"Block","endLine":17,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":17,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.attendanceFilters\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onAttendanceFiltersChange\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionFilters\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSectionFiltersChange\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sections\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.showDataFilters\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.dataFilters\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDataFiltersChange\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.attendanceData\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport CompactAttendanceFilter from '../CompactAttendanceFilter.jsx';\nimport { SectionFilter } from '../../../../shared/components/ui';\n\n/**\n *\n * @param root0\n * @param root0.attendanceFilters\n * @param root0.onAttendanceFiltersChange\n * @param root0.sectionFilters\n * @param root0.onSectionFiltersChange\n * @param root0.sections\n * @param root0.showDataFilters\n * @param root0.dataFilters\n * @param root0.onDataFiltersChange\n * @param root0.attendanceData\n */\nfunction AttendanceFilters({\n  attendanceFilters,\n  onAttendanceFiltersChange,\n  sectionFilters,\n  onSectionFiltersChange,\n  sections,\n  showDataFilters = false,\n  dataFilters = {},\n  onDataFiltersChange,\n  attendanceData = [],\n}) {\n  if (!attendanceData || attendanceData.length === 0) {\n    return null;\n  }\n\n  const uniqueSections = sections || [];\n\n  return (\n    <div className=\"space-y-3 mb-6 p-3 bg-gray-50 rounded-lg\">\n      <div className=\"flex flex-col sm:flex-row gap-3\">\n        <div className=\"flex-1\">\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n            Attendance Status:\n          </label>\n          <CompactAttendanceFilter\n            filters={attendanceFilters}\n            onFiltersChange={onAttendanceFiltersChange}\n          />\n        </div>\n\n        {uniqueSections.length > 1 && (\n          <div className=\"flex-1\">\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n              Sections:\n            </label>\n            <SectionFilter\n              sectionFilters={sectionFilters}\n              onFiltersChange={onSectionFiltersChange}\n              sections={uniqueSections}\n            />\n          </div>\n        )}\n\n        {showDataFilters && (\n          <div className=\"flex-1\">\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n              Data:\n            </label>\n            <div className=\"flex flex-wrap gap-2\">\n              <button\n                onClick={() => onDataFiltersChange(prev => ({ ...prev, contacts: !prev.contacts }))}\n                className={`px-3 py-1 rounded-md text-sm font-medium border transition-colors ${\n                  dataFilters.contacts\n                    ? 'bg-scout-blue text-white border-scout-blue'\n                    : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'\n                }`}\n                type=\"button\"\n              >\n                Contacts\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default AttendanceFilters;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/AttendanceHeader.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.events\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onBack\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onRefresh\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.canRefresh\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.refreshLoading\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { cn } from '../../../../shared/utils/cn';\n\n/**\n *\n * @param root0\n * @param root0.events\n * @param root0.onBack\n * @param root0.onRefresh\n * @param root0.canRefresh\n * @param root0.refreshLoading\n */\nfunction AttendanceHeader({ \n  events, \n  onBack, \n  onRefresh, \n  canRefresh = true,\n  refreshLoading = false, \n}) {\n  if (!events || events.length === 0) {\n    return null;\n  }\n\n  const eventName = events[0].name;\n  const eventDate = events[0].startdate \n    ? new Date(events[0].startdate).toLocaleDateString()\n    : 'Not specified';\n  const sectionCount = events.length;\n\n  return (\n    <div className={cn('px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg flex flex-col space-y-4 md:flex-row md:items-center md:justify-between md:space-y-0')}>\n      <div>\n        <h1 className=\"text-2xl font-bold text-gray-900\">{eventName}</h1>\n        <p className=\"text-gray-600 mt-1\">\n          {eventDate} • {sectionCount} section{sectionCount !== 1 ? 's' : ''}\n        </p>\n      </div>\n\n      <div className=\"flex space-x-2\">\n        {canRefresh && (\n          <button\n            onClick={onRefresh}\n            disabled={refreshLoading}\n            className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm border-2 border-gray-300 text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n            type=\"button\"\n          >\n            {refreshLoading ? 'Refreshing...' : 'Refresh'}\n          </button>\n        )}\n        <button\n          onClick={onBack}\n          className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm border-2 border-gray-300 text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n          type=\"button\"\n        >\n          Back\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default AttendanceHeader;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/AttendanceTabNavigation.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.activeTab\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onTabChange\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.hasSharedEvents\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.activeTab\n * @param root0.onTabChange\n * @param root0.hasSharedEvents\n */\nfunction AttendanceTabNavigation({ \n  activeTab, \n  onTabChange, \n  hasSharedEvents = false, \n}) {\n  const tabs = [\n    { id: 'overview', label: 'Overview' },\n    { id: 'register', label: 'Register' },\n    { id: 'detailed', label: 'Detailed' },\n    { id: 'campGroups', label: 'Camp Groups' },\n  ];\n\n  if (hasSharedEvents) {\n    tabs.push({ id: 'sharedAttendance', label: 'Shared Attendance' });\n  }\n\n  return (\n    <div className=\"border-b border-gray-200 mb-6\">\n      <nav className=\"-mb-px flex flex-wrap space-x-4 sm:space-x-8\">\n        {tabs.map((tab) => (\n          <button\n            key={tab.id}\n            className={`py-2 px-1 border-b-2 font-medium text-sm whitespace-nowrap ${\n              activeTab === tab.id\n                ? 'border-scout-blue text-scout-blue'\n                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'\n            }`}\n            onClick={() => onTabChange(tab.id)}\n            type=\"button\"\n          >\n            {tab.label}\n          </button>\n        ))}\n      </nav>\n    </div>\n  );\n}\n\nexport default AttendanceTabNavigation;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/DetailedTab.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":7,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":7,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.summaryStats\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.members\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onMemberClick\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.showContacts\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { MedicalDataPill } from '../../../../shared/components/ui';\n// import { formatMedicalDataForDisplay } from '../../../../shared/utils/medicalDataUtils.js';\nimport { calculateAge } from '../../../../shared/utils/ageUtils.js';\nimport { groupContactInfo } from '../../../../shared/utils/contactGroups.js';\n\n/**\n *\n * @param root0\n * @param root0.summaryStats\n * @param root0.members\n * @param root0.onMemberClick\n * @param root0.showContacts\n */\nfunction DetailedTab({ summaryStats, members, onMemberClick, showContacts = false }) {\n  const [_selectedMember, _setSelectedMember] = useState(null);\n  const [_showMemberModal, _setShowMemberModal] = useState(false);\n\n  if (!summaryStats || !Array.isArray(summaryStats) || summaryStats.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"text-gray-500 mb-4\">\n          <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z\" />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Members Found</h3>\n        <p className=\"text-gray-600\">No members match the current filter criteria.</p>\n      </div>\n    );\n  }\n\n  // Get comprehensive member data (same as SectionsList)\n  const getComprehensiveMemberData = (member) => {\n    const contactGroups = groupContactInfo(member);\n    \n    // Helper to get field from any group\n    const getField = (groupNames, fieldNames) => {\n      for (const groupName of Array.isArray(groupNames) ? groupNames : [groupNames]) {\n        const group = contactGroups[groupName];\n        if (group) {\n          for (const fieldName of Array.isArray(fieldNames) ? fieldNames : [fieldNames]) {\n            if (group[fieldName]) return group[fieldName];\n          }\n        }\n      }\n      return '';\n    };\n\n    // Helper to combine multiple fields\n    const combineFields = (groupNames, fieldNames, separator = ', ') => {\n      const values = [];\n      for (const groupName of Array.isArray(groupNames) ? groupNames : [groupNames]) {\n        const group = contactGroups[groupName];\n        if (group) {\n          for (const fieldName of Array.isArray(fieldNames) ? fieldNames : [fieldNames]) {\n            if (group[fieldName]) values.push(group[fieldName]);\n          }\n        }\n      }\n      return values.join(separator);\n    };\n\n    return {\n      // Basic info\n      name: `${member.firstname || member.first_name} ${member.lastname || member.last_name}`,\n      section: member.sections?.[0] || 'Unknown',\n      patrol: member.patrol || '',\n      age: calculateAge(member.date_of_birth),\n      \n      // Primary Contacts (1 and 2)\n      primary_contacts: (() => {\n        const contacts = [];\n        \n        // Primary Contact 1\n        const pc1_name = combineFields(['primary_contact_1'], ['first_name', 'last_name'], ' ') || '';\n        const pc1_phone = combineFields(['primary_contact_1'], ['phone_1', 'phone_2']) || '';\n        const pc1_email = combineFields(['primary_contact_1'], ['email_1', 'email_2']) || '';\n        \n        if (pc1_name || pc1_phone || pc1_email) {\n          contacts.push({ name: pc1_name, phone: pc1_phone, email: pc1_email, label: 'PC1' });\n        }\n        \n        // Primary Contact 2\n        const pc2_name = combineFields(['primary_contact_2'], ['first_name', 'last_name'], ' ') || '';\n        const pc2_phone = combineFields(['primary_contact_2'], ['phone_1', 'phone_2']) || '';\n        const pc2_email = combineFields(['primary_contact_2'], ['email_1', 'email_2']) || '';\n        \n        if (pc2_name || pc2_phone || pc2_email) {\n          contacts.push({ name: pc2_name, phone: pc2_phone, email: pc2_email, label: 'PC2' });\n        }\n        \n        return contacts;\n      })(),\n      \n      // Emergency Contacts\n      emergency_contacts: (() => {\n        const contacts = [];\n        \n        // Emergency Contact\n        const ec_name = combineFields(['emergency_contact'], ['first_name', 'last_name'], ' ') || '';\n        const ec_phone = combineFields(['emergency_contact'], ['phone_1', 'phone_2']) || '';\n        \n        if (ec_name || ec_phone) {\n          contacts.push({ name: ec_name, phone: ec_phone, label: 'Emergency' });\n        }\n        \n        return contacts;\n      })(),\n      \n      // Essential Information (comprehensive approach)\n      essential_information: contactGroups.essential_information || {},\n      allergies: contactGroups.essential_information?.allergies || '',\n      medical_details: contactGroups.essential_information?.medical_details || '',\n      dietary_requirements: contactGroups.essential_information?.dietary_requirements || '',\n      tetanus_year_of_last_jab: contactGroups.essential_information?.tetanus_year_of_last_jab || '',\n      swimmer: contactGroups.essential_information?.swimmer || '',\n      other_useful_information: contactGroups.essential_information?.other_useful_information || '',\n      confirmed_by_parents: contactGroups.essential_information?.confirmed_by_parents || '',\n      \n      // Consents\n      consent_photos: getField(['consents'], ['photographs', 'photos']) || '',\n      consent_sensitive: getField(['consents'], ['sensitive_information']) || '',\n      consent_paracetamol: getField(['consents'], ['paracetamol']) || '',\n      consent_ibuprofen: getField(['consents'], ['ibuprofen']) || '',\n      consent_suncream: getField(['consents'], ['suncream', 'sun_cream']) || '',\n    };\n  };\n\n  // Handle member click\n  const handleMemberClick = (member) => {\n    onMemberClick(member);\n  };\n\n  // Get attendance status for a member (use summaryStats which has attendance info)\n  const getMemberAttendanceStatus = (attendee) => {\n    // The attendee object from summaryStats already contains attendance counts\n    // Determine primary status based on counts (similar to filter logic)\n    if (attendee.yes > 0) return 'Yes';\n    if (attendee.no > 0) return 'No';\n    if (attendee.invited > 0) return 'Invited';\n    if (attendee.notInvited > 0) return 'Not Invited';\n    \n    return 'Unknown';\n  };\n\n  // Get Viking Event data for an attendee\n  const getMemberVikingEventData = (attendee) => {\n    // The attendee object from summaryStats already contains vikingEventData\n    return attendee?.vikingEventData || null;\n  };\n\n  return (\n    <div>\n      <div className=\"overflow-x-auto\">\n        <table className=\"min-w-full divide-y divide-gray-200\">\n          <thead className=\"bg-gray-50\">\n            <tr>\n              {/* Basic Info Headers */}\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider sticky left-0 bg-gray-50\">\n                Member\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-purple-50\">\n                Event Status\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-purple-50\">\n                Camp Group\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                Section\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                Patrol\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                Age\n              </th>\n            \n              {/* Contact Info Headers - conditionally shown */}\n              {showContacts && (\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-blue-50\">\n                  Primary Contacts\n                </th>\n              )}\n            \n              {/* Emergency Contact Headers - conditionally shown */}\n              {showContacts && (\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-red-50\">\n                  Emergency Contacts\n                </th>\n              )}\n            \n              {/* Essential Information Headers */}\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Allergies\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Medical\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Dietary\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Tetanus\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Swimmer\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Other Info\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Confirmed By\n              </th>\n            \n              {/* Consent Headers */}\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Photos\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Sensitive Info\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Paracetamol\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Ibuprofen\n              </th>\n              <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Suncream\n              </th>\n            </tr>\n          </thead>\n          <tbody className=\"bg-white divide-y divide-gray-200\">\n            {summaryStats.map((attendee, index) => {\n              // Get comprehensive member data from the full members list\n              const member = members.find(m => m.scoutid.toString() === attendee.scoutid.toString()) || {};\n              const memberData = getComprehensiveMemberData(member);\n              const attendanceStatus = getMemberAttendanceStatus(attendee);\n              const vikingEventData = getMemberVikingEventData(attendee);\n\n              return (\n                <tr key={member.scoutid || index} className=\"hover:bg-gray-50 text-xs\">\n                  {/* Basic Info Cells */}\n                  <td className=\"px-3 py-2 whitespace-nowrap sticky left-0 bg-white\">\n                    <button\n                      onClick={() => handleMemberClick(member)}\n                      className=\"font-semibold text-scout-blue hover:text-scout-blue-dark cursor-pointer transition-colors text-left\"\n                    >\n                      {memberData.name}\n                    </button>\n                  </td>\n                  \n                  {/* Event Status */}\n                  <td className=\"px-3 py-2 whitespace-nowrap text-center bg-purple-25\">\n                    {(() => {\n                      if (attendanceStatus === 'Yes') return <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-scout-green text-white\">Yes</span>;\n                      if (attendanceStatus === 'No') return <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-scout-red text-white\">No</span>;\n                      if (attendanceStatus === 'Invited') return <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-scout-blue text-white\">Invited</span>;\n                      if (attendanceStatus === 'Not Invited') return <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-gray-50 text-gray-600 border border-gray-200\">Not Invited</span>;\n                      return <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-gray-50 text-gray-600 border border-gray-200\">Unknown</span>;\n                    })()}\n                  </td>\n                  \n                  {/* Camp Group from Viking Event Data */}\n                  <td className=\"px-3 py-2 whitespace-nowrap text-gray-900 bg-purple-25\">\n                    {vikingEventData?.CampGroup || '-'}\n                  </td>\n                  \n                  <td className=\"px-3 py-2 whitespace-nowrap text-gray-900\">\n                    {memberData.section}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap text-gray-900\">\n                    {memberData.patrol}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap text-gray-900\">\n                    {memberData.age}\n                  </td>\n                \n                  {/* Contact Info Cells - conditionally shown */}\n                  {showContacts && (\n                    <td className=\"px-3 py-2 whitespace-nowrap text-gray-900 bg-blue-25\">\n                      {memberData.primary_contacts.length > 0 ? (\n                        <div className=\"space-y-1\">\n                          {memberData.primary_contacts.map((contact, index) => (\n                            <div key={index} className=\"text-xs\">\n                              <div className=\"font-medium\">{contact.label}: {contact.name}</div>\n                              {contact.phone && <div className=\"text-gray-600\">📞 {contact.phone}</div>}\n                              {contact.email && <div className=\"text-gray-600\">📧 {contact.email}</div>}\n                            </div>\n                          ))}\n                        </div>\n                      ) : (\n                        <span className=\"text-gray-400\">None</span>\n                      )}\n                    </td>\n                  )}\n                \n                  {/* Emergency Contact Cells - conditionally shown */}\n                  {showContacts && (\n                    <td className=\"px-3 py-2 whitespace-nowrap text-gray-900 bg-red-25\">\n                      {memberData.emergency_contacts.length > 0 ? (\n                        <div className=\"space-y-1\">\n                          {memberData.emergency_contacts.map((contact, index) => (\n                            <div key={index} className=\"text-xs\">\n                              <div className=\"font-medium\">{contact.name}</div>\n                              {contact.phone && <div className=\"text-gray-600\">📞 {contact.phone}</div>}\n                            </div>\n                          ))}\n                        </div>\n                      ) : (\n                        <span className=\"text-gray-400\">None</span>\n                      )}\n                    </td>\n                  )}\n                \n                  {/* Essential Information Cells - Six comprehensive columns */}\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.allergies} \n                        fieldName=\"allergies\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.medical_details} \n                        fieldName=\"medical_details\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.dietary_requirements} \n                        fieldName=\"dietary_requirements\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.tetanus_year_of_last_jab} \n                        fieldName=\"tetanus_year_of_last_jab\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.swimmer} \n                        fieldName=\"swimmer\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.other_useful_information} \n                        fieldName=\"other_useful_information\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                  <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                    <div className=\"max-w-[8rem] break-words\">\n                      <MedicalDataPill \n                        value={memberData.confirmed_by_parents} \n                        fieldName=\"confirmed_by_parents\"\n                        className=\"text-xs\"\n                      />\n                    </div>\n                  </td>\n                \n                  {/* Consent Cells */}\n                  <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                    {\n                      memberData.consent_photos === 'No' ? (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                        </span>\n                      ) : memberData.consent_photos === 'Yes' ? (\n                        <span className=\"text-xs text-gray-700\">\n                          Yes\n                        </span>\n                      ) : (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                        </span>\n                      )\n                    }\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                    {\n                      memberData.consent_sensitive === 'No' ? (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                        </span>\n                      ) : memberData.consent_sensitive === 'Yes' ? (\n                        <span className=\"text-xs text-gray-700\">\n                          Yes\n                        </span>\n                      ) : (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                        </span>\n                      )\n                    }\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                    {\n                      memberData.consent_paracetamol === 'No' ? (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                        </span>\n                      ) : memberData.consent_paracetamol === 'Yes' ? (\n                        <span className=\"text-xs text-gray-700\">\n                          Yes\n                        </span>\n                      ) : (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                        </span>\n                      )\n                    }\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                    {\n                      memberData.consent_ibuprofen === 'No' ? (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                        </span>\n                      ) : memberData.consent_ibuprofen === 'Yes' ? (\n                        <span className=\"text-xs text-gray-700\">\n                          Yes\n                        </span>\n                      ) : (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                        </span>\n                      )\n                    }\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                    {\n                      memberData.consent_suncream === 'No' ? (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                        </span>\n                      ) : memberData.consent_suncream === 'Yes' ? (\n                        <span className=\"text-xs text-gray-700\">\n                          Yes\n                        </span>\n                      ) : (\n                        <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                        </span>\n                      )\n                    }\n                  </td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n}\n\nexport default DetailedTab;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/EventAttendance.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":18,"column":1,"nodeType":"Block","endLine":24,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":18,"column":1,"nodeType":"Block","endLine":24,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":20,"column":1,"nodeType":"Block","endLine":20,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.events\" description.","line":21,"column":1,"nodeType":"Block","endLine":21,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.members\" description.","line":22,"column":1,"nodeType":"Block","endLine":22,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onBack\" description.","line":23,"column":1,"nodeType":"Block","endLine":23,"endColumn":1}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from 'react';\nimport { SectionCardsFlexMasonry } from '../../../../shared/components/ui';\nimport LoadingScreen from '../../../../shared/components/LoadingScreen.jsx';\nimport { MemberDetailModal } from '../../../../shared/components/ui';\nimport CampGroupsView from '../CampGroupsView.jsx';\nimport { notifyError, notifyWarning } from '../../../../shared/utils/notifications.js';\nimport { useAttendanceData } from '../../hooks/useAttendanceData.js';\nimport { useSignInOut } from '../../../../shared/hooks/useSignInOut.js';\nimport { useSharedAttendance } from '../../hooks/useSharedAttendance.js';\n\nimport AttendanceHeader from './AttendanceHeader.jsx';\nimport AttendanceFilters from './AttendanceFilters.jsx';\nimport AttendanceTabNavigation from './AttendanceTabNavigation.jsx';\nimport OverviewTab from './OverviewTab.jsx';\nimport RegisterTab from './RegisterTab.jsx';\nimport DetailedTab from './DetailedTab.jsx';\n\n/**\n *\n * @param root0\n * @param root0.events\n * @param root0.members\n * @param root0.onBack\n */\nfunction EventAttendance({ events, members, onBack }) {\n  const {\n    attendanceData,\n    loading,\n    error,\n    loadVikingEventData,\n  } = useAttendanceData(events);\n\n\n\n  const { buttonLoading, handleSignInOut } = useSignInOut(\n    events,\n    loadVikingEventData,\n    { notifyError, notifyWarning },\n  );\n\n  const [filteredAttendanceData, setFilteredAttendanceData] = useState([]);\n  const [activeTab, setActiveTab] = useState('overview');\n\n  const { \n    sharedAttendanceData, \n    loadingSharedAttendance, \n    hasSharedEvents, \n  } = useSharedAttendance(events, activeTab);\n\n  // Debug the events being passed and shared events detection\n  console.log('🐛 EventAttendance DEBUG:', {\n    eventsCount: events?.length || 0,\n    hasSharedEvents,\n    eventDetails: events?.map(e => ({\n      name: e.eventname,\n      shared: e.shared,\n      sharedType: typeof e.shared,\n      allProperties: Object.keys(e),\n    })) || [],\n  });\n  \n  // Also log the full first event to see all available properties\n  if (events?.length > 0) {\n    console.log('🐛 FIRST EVENT FULL DATA:', events[0]);\n    console.log('🐛 ALL EVENT PROPERTIES:', Object.keys(events[0]));\n    console.log('🐛 LOOKING FOR SHARED PROPERTIES:', {\n      shared: events[0].shared,\n      isShared: events[0].isShared,\n      shared_event: events[0].shared_event,\n      sharedevent: events[0].sharedevent,\n      is_shared: events[0].is_shared,\n      sharedEvent: events[0].sharedEvent,\n    });\n  }\n  const [sortConfig, setSortConfig] = useState({\n    key: 'attendance',\n    direction: 'desc',\n  });\n  const [selectedMember, setSelectedMember] = useState(null);\n  const [showMemberModal, setShowMemberModal] = useState(false);\n\n  const [attendanceFilters, setAttendanceFilters] = useState({\n    yes: true,\n    no: true,\n    invited: true,\n    notInvited: true,\n  });\n\n  const [dataFilters, setDataFilters] = useState({\n    contacts: false,\n  });\n\n\n  const [sectionFilters, setSectionFilters] = useState(() => {\n    const filters = {};\n    const uniqueSections = [...new Set(events.map((e) => e.sectionid))];\n    uniqueSections.forEach((sectionId) => {\n      const sectionEvent = events.find((e) => e.sectionid === sectionId);\n      const sectionName = sectionEvent?.sectionname?.toLowerCase() || '';\n      filters[sectionId] = !sectionName.includes('adults');\n    });\n    return filters;\n  });\n\n  const uniqueSections = useMemo(() => {\n    return [...new Set(events.map((e) => e.sectionid))].map((sectionId) => {\n      const sectionEvent = events.find((e) => e.sectionid === sectionId);\n      return {\n        sectionid: sectionId,\n        sectionname: sectionEvent?.sectionname || `Section ${sectionId}`,\n      };\n    });\n  }, [events]);\n\n\n  const applyFilters = (attendanceData, attendanceFilters, sectionFilters) => {\n    if (!attendanceData || !Array.isArray(attendanceData)) return [];\n\n    return attendanceData.filter((record) => {\n      // Handle both string and number formats for attending field\n      const attending = record.attending;\n      const statusMatch = \n        ((attending === 1 || attending === 'Yes') && attendanceFilters.yes) ||\n        ((attending === 0 || attending === 'No') && attendanceFilters.no) ||\n        ((attending === 2 || attending === 'Invited') && attendanceFilters.invited) ||\n        ((attending === 3 || attending === 'Not Invited') && attendanceFilters.notInvited);\n\n      // For section filtering, skip if sectionid is missing (common in cached data)\n      // The data should have sectionid added by the hook, but if not, allow it through\n      const recordSectionId = record.sectionid;\n      const sectionMatch = !recordSectionId || sectionFilters[recordSectionId] !== false;\n\n      return statusMatch && sectionMatch;\n    });\n  };\n\n  useEffect(() => {\n    const filtered = applyFilters(attendanceData, attendanceFilters, sectionFilters);\n    setFilteredAttendanceData(filtered);\n  }, [attendanceData, attendanceFilters, sectionFilters]);\n\n  const summaryStats = useMemo(() => {\n    if (!filteredAttendanceData || filteredAttendanceData.length === 0) {\n      return [];\n    }\n\n    const memberMap = new Map();\n\n    filteredAttendanceData.forEach((record) => {\n      const key = record.scoutid;\n      if (!memberMap.has(key)) {\n        memberMap.set(key, {\n          scoutid: record.scoutid,\n          name: `${record.firstname} ${record.lastname}`,\n          firstname: record.firstname,\n          lastname: record.lastname,\n          sectionid: record.sectionid,\n          events: [],\n          yes: 0,\n          no: 0,\n          invited: 0,\n          notInvited: 0,\n          vikingEventData: record.vikingEventData,\n          isSignedIn: Boolean(record.vikingEventData?.SignedInBy && !record.vikingEventData?.SignedOutBy),\n        });\n      }\n\n      const member = memberMap.get(key);\n      member.events.push(record);\n\n      // Update vikingEventData if this record has more recent data\n      if (record.vikingEventData) {\n        member.vikingEventData = record.vikingEventData;\n        // Update isSignedIn based on the latest vikingEventData\n        member.isSignedIn = Boolean(record.vikingEventData?.SignedInBy && !record.vikingEventData?.SignedOutBy);\n      }\n\n      // Handle both string and number formats for attending field\n      const attending = record.attending;\n      if (attending === 1 || attending === 'Yes') member.yes++;\n      else if (attending === 0 || attending === 'No') member.no++;\n      else if (attending === 2 || attending === 'Invited') member.invited++;\n      else if (attending === 3 || attending === 'Not Invited') member.notInvited++;\n    });\n\n    return Array.from(memberMap.values());\n  }, [filteredAttendanceData]);\n\n  const simplifiedSummaryStats = useMemo(() => {\n    if (!filteredAttendanceData || filteredAttendanceData.length === 0) {\n      return { sections: [], totals: null };\n    }\n\n\n    const sectionMap = new Map();\n    \n    uniqueSections.forEach(section => {\n      if (sectionFilters[section.sectionid] !== false) {\n        sectionMap.set(section.sectionid, {\n          name: section.sectionname,\n          yes: { yp: 0, yl: 0, l: 0, total: 0 },\n          no: { yp: 0, yl: 0, l: 0, total: 0 },\n          invited: { yp: 0, yl: 0, l: 0, total: 0 },\n          notInvited: { yp: 0, yl: 0, l: 0, total: 0 },\n          total: { yp: 0, yl: 0, l: 0, total: 0 },\n        });\n      }\n    });\n\n    filteredAttendanceData.forEach((record) => {\n      const section = sectionMap.get(record.sectionid);\n      if (!section) return;\n\n      // Find member data to get person_type for proper role categorization\n      // Convert both scoutids to strings to handle type mismatch (attendance has strings, members has numbers)\n      const memberData = members.find(m => m.scoutid.toString() === record.scoutid.toString());\n      const personType = memberData?.person_type;\n      \n      // Map person_type to role abbreviations\n      let roleType = 'l'; // default to Leaders\n      if (personType === 'Young People') {\n        roleType = 'yp';\n      } else if (personType === 'Young Leaders') {\n        roleType = 'yl';\n      } else if (personType === 'Leaders') {\n        roleType = 'l';\n      }\n\n      const updateCounts = (category) => {\n        section[category][roleType]++;\n        section[category].total++;\n        section.total[roleType]++;\n        section.total.total++;\n      };\n\n      // Handle both string and number formats for attending field\n      const attending = record.attending;\n      if (attending === 1 || attending === 'Yes') updateCounts('yes');\n      else if (attending === 0 || attending === 'No') updateCounts('no');\n      else if (attending === 2 || attending === 'Invited') updateCounts('invited');\n      else if (attending === 3 || attending === 'Not Invited') updateCounts('notInvited');\n    });\n\n    const sections = Array.from(sectionMap.values());\n    \n    const totals = sections.reduce((acc, section) => {\n      ['yes', 'no', 'invited', 'notInvited', 'total'].forEach(category => {\n        acc[category].yp += section[category].yp;\n        acc[category].yl += section[category].yl;\n        acc[category].l += section[category].l;\n        acc[category].total += section[category].total;\n      });\n      return acc;\n    }, {\n      yes: { yp: 0, yl: 0, l: 0, total: 0 },\n      no: { yp: 0, yl: 0, l: 0, total: 0 },\n      invited: { yp: 0, yl: 0, l: 0, total: 0 },\n      notInvited: { yp: 0, yl: 0, l: 0, total: 0 },\n      total: { yp: 0, yl: 0, l: 0, total: 0 },\n    });\n\n    return { sections, totals };\n  }, [filteredAttendanceData, uniqueSections, sectionFilters, members]);\n\n  const handleMemberClick = (member) => {\n    const fullMemberData = members.find((m) => m.scoutid === member.scoutid);\n    if (fullMemberData) {\n      setSelectedMember(fullMemberData);\n      setShowMemberModal(true);\n    }\n  };\n\n  const handleResetFilters = () => {\n    setAttendanceFilters({\n      yes: true,\n      no: true,\n      invited: true,\n      notInvited: true,\n    });\n    const allSectionsEnabled = {};\n    uniqueSections.forEach((section) => {\n      allSectionsEnabled[section.sectionid] = true;\n    });\n    setSectionFilters(allSectionsEnabled);\n  };\n\n  if (loading) {\n    return <LoadingScreen message=\"Loading attendance data...\" />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-6\">\n        <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm p-6\">\n          <div className=\"text-red-600\">\n            <h2 className=\"text-lg font-semibold mb-2\">Error Loading Attendance</h2>\n            <p>{error}</p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n    case 'overview':\n      return (\n        <OverviewTab \n          summaryStats={simplifiedSummaryStats}\n          members={members}\n          onResetFilters={handleResetFilters}\n          uniqueSections={uniqueSections}\n        />\n      );\n      \n    case 'register':\n      return (\n        <RegisterTab \n          summaryStats={summaryStats}\n          members={members}\n          onSignInOut={handleSignInOut}\n          buttonLoading={buttonLoading}\n          onMemberClick={handleMemberClick}\n          sortConfig={sortConfig}\n          onSort={setSortConfig}\n        />\n      );\n      \n    case 'detailed':\n      return (\n        <DetailedTab \n          summaryStats={summaryStats}\n          members={members}\n          onMemberClick={handleMemberClick}\n          showContacts={dataFilters.contacts}\n        />\n      );\n      \n    case 'campGroups':\n      return (\n        <CampGroupsView \n          summaryStats={summaryStats}\n          events={events}\n          members={members}\n          onMemberClick={handleMemberClick}\n        />\n      );\n      \n    case 'sharedAttendance':\n      if (loadingSharedAttendance) {\n        return <LoadingScreen message=\"Loading shared attendance data...\" />;\n      }\n      \n      return (\n        <div>\n          {sharedAttendanceData && sharedAttendanceData.length > 0 ? (\n            <div>\n              {(() => {\n                // Helper function to determine if member is young person or adult based on age\n                const isYoungPerson = (age) => {\n                  if (!age) return true; // Default to young person if no age\n                  return age !== '25+'; // Adults/leaders have '25+', young people have formats like '06 / 08'\n                };\n\n                // Helper function to get numeric age for sorting (handle years/months format)\n                const getNumericAge = (age) => {\n                  if (!age) return 0;\n                  if (age === '25+') return 999; // Put adults at the end\n\n                  // Handle format like '06 / 08' which is years / months\n                  const match = age.match(/^(\\d+)\\s*\\/\\s*(\\d+)$/);\n                  if (match) {\n                    const years = parseInt(match[1], 10);\n                    const months = parseInt(match[2], 10);\n                    // Convert to total months for accurate sorting\n                    return years * 12 + months;\n                  }\n\n                  // Fallback to just first number\n                  const singleMatch = age.match(/^(\\d+)/);\n                  return singleMatch\n                    ? parseInt(singleMatch[1], 10) * 12\n                    : 0; // Convert years to months\n                };\n\n                // Process the data to group by sections\n                const sectionGroups = {};\n                let totalYoungPeople = 0;\n                let totalAdults = 0;\n\n                sharedAttendanceData.forEach((member) => {\n                  const sectionName = member.sectionname;\n                  const isYP = isYoungPerson(member.age);\n\n                  if (isYP) {\n                    totalYoungPeople++;\n                  } else {\n                    totalAdults++;\n                  }\n\n                  if (!sectionGroups[sectionName]) {\n                    sectionGroups[sectionName] = {\n                      sectionid: member.sectionid,\n                      sectionname: sectionName,\n                      members: [],\n                      youngPeopleCount: 0,\n                      adultsCount: 0,\n                    };\n                  }\n\n                  if (isYP) {\n                    sectionGroups[sectionName].youngPeopleCount++;\n                  } else {\n                    sectionGroups[sectionName].adultsCount++;\n                  }\n\n                  sectionGroups[sectionName].members.push(member);\n                });\n\n                // Sort members within each section by age (youngest first, adults last)\n                Object.values(sectionGroups).forEach((section) => {\n                  section.members.sort((a, b) => {\n                    const ageA = getNumericAge(a.age);\n                    const ageB = getNumericAge(b.age);\n                    return ageA - ageB;\n                  });\n                });\n\n                const sections = Object.values(sectionGroups);\n                const totalMembers = totalYoungPeople + totalAdults;\n\n                return (\n                  <>\n                    {/* Overall summary */}\n                    <div className=\"p-4 border-b border-gray-200\">\n                      <div className=\"flex items-center justify-between\">\n                        <h3 className=\"text-lg font-semibold text-gray-900\">\n                          All Sections ({sections.length})\n                        </h3>\n                        <div className=\"flex gap-2 text-sm text-gray-600\">\n                          <span>{totalMembers} total</span>\n                          <span>•</span>\n                          <span>{totalYoungPeople} YP</span>\n                          <span>•</span>\n                          <span>{totalAdults} adults</span>\n                        </div>\n                      </div>\n                    </div>\n\n                    {/* Scrollable masonry container */}\n                    <div className=\"max-h-[600px] overflow-y-auto\">\n                      <SectionCardsFlexMasonry \n                        sections={sections} \n                        isYoungPerson={isYoungPerson}\n                      />\n                    </div>\n                  </>\n                );\n              })()}\n            </div>\n          ) : (\n            <div className=\"text-center py-8 text-gray-500\">\n              No shared attendance data available\n            </div>\n          )}\n        </div>\n      );\n      \n    default:\n      return <div>Tab content not implemented yet</div>;\n    }\n  };\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"max-w-6xl mx-auto\">\n        <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\">\n          <AttendanceHeader \n            events={events}\n            onBack={onBack}\n          />\n\n          <div className=\"p-4\">\n            <AttendanceFilters \n              attendanceFilters={attendanceFilters}\n              onAttendanceFiltersChange={setAttendanceFilters}\n              sectionFilters={sectionFilters}\n              onSectionFiltersChange={setSectionFilters}\n              sections={uniqueSections}\n              showDataFilters={activeTab === 'detailed'}\n              dataFilters={dataFilters}\n              onDataFiltersChange={setDataFilters}\n              attendanceData={attendanceData}\n            />\n\n            <AttendanceTabNavigation \n              activeTab={activeTab}\n              onTabChange={setActiveTab}\n              hasSharedEvents={hasSharedEvents}\n            />\n\n            {renderTabContent()}\n          </div>\n        </div>\n\n        {selectedMember && (\n          <MemberDetailModal\n            isOpen={showMemberModal}\n            onClose={() => setShowMemberModal(false)}\n            member={selectedMember}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default EventAttendance;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/OverviewTab.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.summaryStats\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.members\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onResetFilters\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.uniqueSections\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.summaryStats\n * @param root0.members\n * @param root0.onResetFilters\n * @param root0.uniqueSections\n */\nfunction OverviewTab({ \n  summaryStats,\n  members,\n  onResetFilters,\n  uniqueSections: _uniqueSections, \n}) {\n  if (!summaryStats || !summaryStats.sections) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"text-gray-500 mb-4\">\n          <svg\n            className=\"mx-auto h-12 w-12 text-gray-400\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth=\"2\"\n              d=\"M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z\"\n            />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">\n          No Records Match Filters\n        </h3>\n        <p className=\"text-gray-600 mb-4\">\n          No attendance records match your current filter settings. Try\n          adjusting the filters above to see more data.\n        </p>\n        <button\n          className=\"inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base bg-scout-blue text-white hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light active:bg-scout-blue-dark transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n          onClick={onResetFilters}\n          type=\"button\"\n        >\n          Reset Filters\n        </button>\n      </div>\n    );\n  }\n\n  if (!members || members.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"overflow-x-auto\">\n      <table className=\"min-w-full divide-y divide-gray-200\">\n        <thead className=\"bg-gray-50\">\n          <tr>\n            <th className=\"px-3 py-2 text-left table-header-text text-gray-500 uppercase tracking-wider\">\n              Section\n            </th>\n            <th className=\"px-2 py-2 text-center table-header-text text-green-700 uppercase tracking-wider\">\n              <div>Yes</div>\n              <div className=\"flex justify-center mt-1 text-xs\">\n                <span className=\"w-8 text-center\">YP</span>\n                <span className=\"w-8 text-center\">YL</span>\n                <span className=\"w-8 text-center\">L</span>\n                <span className=\"w-12 text-center\">Total</span>\n              </div>\n            </th>\n            <th className=\"px-2 py-2 text-center table-header-text text-red-700 uppercase tracking-wider\">\n              <div>No</div>\n              <div className=\"flex justify-center mt-1 text-xs\">\n                <span className=\"w-8 text-center\">YP</span>\n                <span className=\"w-8 text-center\">YL</span>\n                <span className=\"w-8 text-center\">L</span>\n                <span className=\"w-12 text-center\">Total</span>\n              </div>\n            </th>\n            <th className=\"px-2 py-2 text-center table-header-text text-scout-blue uppercase tracking-wider\">\n              <div>Invited</div>\n              <div className=\"flex justify-center mt-1 text-xs\">\n                <span className=\"w-8 text-center\">YP</span>\n                <span className=\"w-8 text-center\">YL</span>\n                <span className=\"w-8 text-center\">L</span>\n                <span className=\"w-12 text-center\">Total</span>\n              </div>\n            </th>\n            <th className=\"px-2 py-2 text-center table-header-text text-gray-600 uppercase tracking-wider\">\n              <div>Not Invited</div>\n              <div className=\"flex justify-center mt-1 text-xs\">\n                <span className=\"w-8 text-center\">YP</span>\n                <span className=\"w-8 text-center\">YL</span>\n                <span className=\"w-8 text-center\">L</span>\n                <span className=\"w-12 text-center\">Total</span>\n              </div>\n            </th>\n            <th className=\"px-2 py-2 text-center table-header-text text-gray-500 uppercase tracking-wider\">\n              <div>Total</div>\n              <div className=\"flex justify-center mt-1 text-xs\">\n                <span className=\"w-8 text-center\">YP</span>\n                <span className=\"w-8 text-center\">YL</span>\n                <span className=\"w-8 text-center\">L</span>\n                <span className=\"w-12 text-center\">Total</span>\n              </div>\n            </th>\n          </tr>\n        </thead>\n        <tbody className=\"bg-white divide-y divide-gray-200\">\n          {summaryStats.sections.map((section, index) => (\n            <tr key={index} className=\"hover:bg-gray-50\">\n              <td className=\"px-3 py-3 whitespace-nowrap table-header-text text-gray-900\">\n                {section.name}\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-green-700 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{section.yes.yp}</span>\n                  <span className=\"w-8 text-center\">{section.yes.yl}</span>\n                  <span className=\"w-8 text-center\">{section.yes.l}</span>\n                  <span className=\"w-12 text-center\">{section.yes.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-red-700 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{section.no.yp}</span>\n                  <span className=\"w-8 text-center\">{section.no.yl}</span>\n                  <span className=\"w-8 text-center\">{section.no.l}</span>\n                  <span className=\"w-12 text-center\">{section.no.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-scout-blue font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{section.invited.yp}</span>\n                  <span className=\"w-8 text-center\">{section.invited.yl}</span>\n                  <span className=\"w-8 text-center\">{section.invited.l}</span>\n                  <span className=\"w-12 text-center\">{section.invited.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-gray-600 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{section.notInvited.yp}</span>\n                  <span className=\"w-8 text-center\">{section.notInvited.yl}</span>\n                  <span className=\"w-8 text-center\">{section.notInvited.l}</span>\n                  <span className=\"w-12 text-center\">{section.notInvited.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-gray-900 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{section.total.yp}</span>\n                  <span className=\"w-8 text-center\">{section.total.yl}</span>\n                  <span className=\"w-8 text-center\">{section.total.l}</span>\n                  <span className=\"w-12 text-center\">{section.total.total}</span>\n                </div>\n              </td>\n            </tr>\n          ))}\n          {summaryStats.totals && (\n            <tr className=\"bg-gray-100 font-semibold\">\n              <td className=\"px-3 py-3 whitespace-nowrap table-header-text text-gray-900\">\n                Total\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-green-700 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{summaryStats.totals.yes.yp}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.yes.yl}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.yes.l}</span>\n                  <span className=\"w-12 text-center\">{summaryStats.totals.yes.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-red-700 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{summaryStats.totals.no.yp}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.no.yl}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.no.l}</span>\n                  <span className=\"w-12 text-center\">{summaryStats.totals.no.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-scout-blue font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{summaryStats.totals.invited.yp}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.invited.yl}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.invited.l}</span>\n                  <span className=\"w-12 text-center\">{summaryStats.totals.invited.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-gray-600 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{summaryStats.totals.notInvited.yp}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.notInvited.yl}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.notInvited.l}</span>\n                  <span className=\"w-12 text-center\">{summaryStats.totals.notInvited.total}</span>\n                </div>\n              </td>\n              <td className=\"px-2 py-3 whitespace-nowrap text-center text-gray-900 font-semibold\">\n                <div className=\"flex justify-center\">\n                  <span className=\"w-8 text-center\">{summaryStats.totals.total.yp}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.total.yl}</span>\n                  <span className=\"w-8 text-center\">{summaryStats.totals.total.l}</span>\n                  <span className=\"w-12 text-center\">{summaryStats.totals.total.total}</span>\n                </div>\n              </td>\n            </tr>\n          )}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nexport default OverviewTab;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/RegisterTab.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":74,"column":1,"nodeType":"Block","endLine":84,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":74,"column":1,"nodeType":"Block","endLine":84,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":76,"column":1,"nodeType":"Block","endLine":76,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.summaryStats\" description.","line":77,"column":1,"nodeType":"Block","endLine":77,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.members\" description.","line":78,"column":1,"nodeType":"Block","endLine":78,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSignInOut\" description.","line":79,"column":1,"nodeType":"Block","endLine":79,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.buttonLoading\" description.","line":80,"column":1,"nodeType":"Block","endLine":80,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onMemberClick\" description.","line":81,"column":1,"nodeType":"Block","endLine":81,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sortConfig\" description.","line":82,"column":1,"nodeType":"Block","endLine":82,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSort\" description.","line":83,"column":1,"nodeType":"Block","endLine":83,"endColumn":1}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport SignInOutButton from '../SignInOutButton.jsx';\n\nconst formatUKDateTime = (dateString) => {\n  if (!dateString) return '';\n\n  try {\n    const date = new Date(dateString);\n    const day = date.getDate().toString().padStart(2, '0');\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\n    const year = date.getFullYear();\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n\n    return `${day}/${month}/${year} ${hours}:${minutes}`;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.warn('Failed to format date:', dateString, error);\n    }\n    return dateString;\n  }\n};\n\nconst sortData = (data, key, direction) => {\n  return [...data].sort((a, b) => {\n    let aValue, bValue;\n\n    switch (key) {\n    case 'member':\n      aValue = a.name?.toLowerCase() || '';\n      bValue = b.name?.toLowerCase() || '';\n      break;\n    case 'attendance':\n      aValue = a.yes + a.no + a.invited + a.notInvited;\n      bValue = b.yes + b.no + b.invited + b.notInvited;\n      break;\n    default:\n      aValue = '';\n      bValue = '';\n    }\n\n    if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n    if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n    return 0;\n  });\n};\n\nconst getSortIcon = (columnKey, currentSortKey, direction) => {\n  if (currentSortKey !== columnKey) {\n    return (\n      <span className=\"ml-1 text-gray-400\">\n        <svg className=\"w-4 h-4 inline\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M8 9l4-4 4 4m0 6l-4 4-4-4\" />\n        </svg>\n      </span>\n    );\n  }\n\n  return direction === 'asc' ? (\n    <span className=\"ml-1 text-scout-blue\">\n      <svg className=\"w-4 h-4 inline\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M5 15l7-7 7 7\" />\n      </svg>\n    </span>\n  ) : (\n    <span className=\"ml-1 text-scout-blue\">\n      <svg className=\"w-4 h-4 inline\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M19 9l-7 7-7-7\" />\n      </svg>\n    </span>\n  );\n};\n\n/**\n *\n * @param root0\n * @param root0.summaryStats\n * @param root0.members\n * @param root0.onSignInOut\n * @param root0.buttonLoading\n * @param root0.onMemberClick\n * @param root0.sortConfig\n * @param root0.onSort\n */\nfunction RegisterTab({ \n  summaryStats,\n  members,\n  onSignInOut,\n  buttonLoading,\n  onMemberClick,\n  sortConfig,\n  onSort, \n}) {\n  const handleSort = (key) => {\n    const direction = sortConfig.key === key && sortConfig.direction === 'asc' ? 'desc' : 'asc';\n    onSort({ key, direction });\n  };\n\n  if (!summaryStats || summaryStats.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"text-gray-500 mb-4\">\n          <svg className=\"mx-auto h-12 w-12 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z\" />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">No Members Found</h3>\n        <p className=\"text-gray-600\">No members match the current filter criteria.</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"overflow-x-auto\">\n      <table className=\"min-w-full divide-y divide-gray-200\">\n        <thead className=\"bg-gray-50\">\n          <tr>\n            <th\n              className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100\"\n              onClick={() => handleSort('member')}\n            >\n              <div className=\"flex items-center\">\n                Member {getSortIcon('member', sortConfig.key, sortConfig.direction)}\n              </div>\n            </th>\n            <th className=\"px-2 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider\">\n              Actions\n            </th>\n            <th\n              className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100\"\n              onClick={() => handleSort('attendance')}\n            >\n              <div className=\"flex items-center\">\n                Status {getSortIcon('attendance', sortConfig.key, sortConfig.direction)}\n              </div>\n            </th>\n            <th className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n              Camp Group\n            </th>\n            <th className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n              Signed In\n            </th>\n            <th className=\"px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n              Signed Out\n            </th>\n          </tr>\n        </thead>\n        <tbody className=\"bg-white divide-y divide-gray-200\">\n          {sortData(summaryStats, sortConfig.key, sortConfig.direction).map((member, index) => (\n            <tr key={member.scoutid || index} className=\"hover:bg-gray-50\">\n              <td className=\"px-3 py-2\">\n                <button\n                  onClick={() => {\n                    const fullMember = members.find(m => m.scoutid.toString() === member.scoutid.toString());\n                    if (fullMember) {\n                      onMemberClick(fullMember);\n                    }\n                  }}\n                  className=\"font-semibold text-scout-blue hover:text-scout-blue-dark cursor-pointer transition-colors text-left break-words whitespace-normal leading-tight max-w-[120px] block text-xs\"\n                >\n                  {member.name}\n                </button>\n              </td>\n              <td className=\"px-2 py-2 text-center\">\n                <SignInOutButton\n                  member={member}\n                  onSignInOut={onSignInOut}\n                  loading={buttonLoading?.[member.scoutid] || false}\n                />\n              </td>\n              <td className=\"px-3 py-2 whitespace-nowrap\">\n                <div className=\"flex gap-1 flex-wrap\">\n                  {member.yes > 0 && (\n                    <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-scout-green text-white\">\n                      Yes\n                    </span>\n                  )}\n                  {member.no > 0 && (\n                    <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-scout-red text-white\">\n                      No\n                    </span>\n                  )}\n                  {member.invited > 0 && (\n                    <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-scout-blue text-white\">\n                      Invited\n                    </span>\n                  )}\n                  {member.notInvited > 0 && (\n                    <span className=\"inline-flex items-center font-medium rounded-full px-3 py-1 text-xs bg-gray-50 text-gray-600 border border-gray-200\">\n                      Not Invited\n                    </span>\n                  )}\n                </div>\n              </td>\n              <td className=\"px-3 py-2 whitespace-nowrap text-xs text-gray-900\">\n                {member.vikingEventData?.CampGroup || '-'}\n              </td>\n              <td className=\"px-3 py-2 text-xs\">\n                {member.vikingEventData?.SignedInBy || member.vikingEventData?.SignedInWhen ? (\n                  <div className=\"space-y-0.5\">\n                    <div className=\"text-gray-900 font-medium leading-tight\">\n                      {member.vikingEventData?.SignedInBy || '-'}\n                    </div>\n                    <div className=\"text-gray-500 text-xs leading-tight\">\n                      {member.vikingEventData?.SignedInWhen\n                        ? formatUKDateTime(member.vikingEventData.SignedInWhen)\n                        : '-'\n                      }\n                    </div>\n                  </div>\n                ) : (\n                  <span className=\"text-gray-400\">-</span>\n                )}\n              </td>\n              <td className=\"px-3 py-2 text-xs\">\n                {member.vikingEventData?.SignedOutBy || member.vikingEventData?.SignedOutWhen ? (\n                  <div className=\"space-y-0.5\">\n                    <div className=\"text-gray-900 font-medium leading-tight\">\n                      {member.vikingEventData?.SignedOutBy || '-'}\n                    </div>\n                    <div className=\"text-gray-500 text-xs leading-tight\">\n                      {member.vikingEventData?.SignedOutWhen\n                        ? formatUKDateTime(member.vikingEventData.SignedOutWhen)\n                        : '-'\n                      }\n                    </div>\n                  </div>\n                ) : (\n                  <span className=\"text-gray-400\">-</span>\n                )}\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nexport default RegisterTab;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/attendance/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/components/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/hooks/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/hooks/useAttendanceData.js","messages":[{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":23,"column":17,"endLine":23,"endColumn":67,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useMemo } from 'react';\nimport { getEventAttendance } from '../../../shared/services/api/api.js';\nimport { getVikingEventDataForEvents } from '../services/flexiRecordService.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\nimport { isDemoMode } from '../../../config/demoMode.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n * Custom hook for loading and managing attendance data\n * \n * @param {Array} events - Array of event data\n * @returns {object} Hook state and functions\n */\nexport function useAttendanceData(events) {\n  const [attendanceData, setAttendanceData] = useState([]);\n  const [vikingEventData, setVikingEventData] = useState(new Map());\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Load attendance data when events change\n  useEffect(() => {\n    loadAttendance();\n  }, [events]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const loadAttendance = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      // Skip API calls in demo mode - only use cached data\n      if (isDemoMode()) {\n        logger.debug('Demo mode: Skipping API calls, using cached attendance only', {}, LOG_CATEGORIES.COMPONENT);\n      }\n      \n      // Validate event data integrity\n      const hasInvalidEvents = events.some(event => !event.sectionid || event.termid === null || event.termid === undefined);\n      if (events.length > 0 && hasInvalidEvents) {\n        if (import.meta.env.DEV) {\n          console.error('🚫 Invalid events detected:', events.filter(event => !event.sectionid || event.termid === null || event.termid === undefined));\n        }\n        setError('Invalid event data detected. Please refresh the page to reload.');\n        return;\n      }\n      \n      const allAttendance = [];\n      const sectionSpecificAttendanceData = [];\n      const token = getToken();\n      \n      \n      // Load attendance data for each event\n      for (const event of events) {\n        // Validate that event has required fields (should be included from eventDashboardHelpers)\n        if (!event.sectionid || !event.termid || !event.eventid) {\n          if (import.meta.env.DEV) {\n            console.warn('Event missing required fields:', {\n              name: event.name,\n              sectionid: event.sectionid,\n              termid: event.termid,\n              eventid: event.eventid,\n              availableKeys: Object.keys(event),\n            });\n          }\n          continue; // Skip this event\n        }\n        \n        // Check if we have cached attendance data for this specific event\n        // Try multiple cache key formats for backward compatibility\n        const demoMode = isDemoMode();\n        const prefix = demoMode ? 'demo_' : '';\n        const cacheKeys = [\n          `${prefix}viking_attendance_${event.sectionid}_${event.termid}_${event.eventid}_offline`, // API format with demo prefix\n          `viking_attendance_${event.eventid}_offline`, // Database service format\n        ];\n        \n        let attendanceResponse = null;\n        \n        for (const cacheKey of cacheKeys) {\n          try {\n            const cached = localStorage.getItem(cacheKey);\n            if (cached) {\n              const parsed = JSON.parse(cached);\n              // Safely handle null, arrays, and objects with/without items\n              const attendanceItems = Array.isArray(parsed) ? parsed : \n                (parsed && Array.isArray(parsed.items) ? parsed.items : []);\n              attendanceResponse = { items: attendanceItems };\n              if (import.meta.env.DEV) {\n                console.log(`Found cached attendance for event ${event.name} with key ${cacheKey}:`, attendanceItems.length, 'records');\n              }\n              break; // Found data, stop trying other keys\n            }\n          } catch (error) {\n            if (import.meta.env.DEV) {\n              console.warn(`Failed to parse cached attendance data for key ${cacheKey}:`, error);\n            }\n          }\n        }\n        \n        if (!attendanceResponse && token && !isDemoMode()) {\n          // Fallback to API call if no cached data (skip in demo mode)\n          try {\n            const attendanceItems = await getEventAttendance(\n              event.sectionid, \n              event.eventid, \n              event.termid,\n              token,\n            );\n            \n            attendanceResponse = { items: attendanceItems || [] };\n          } catch (eventError) {\n            if (import.meta.env.DEV) {\n              console.warn(`Error loading attendance for event ${event.name}:`, eventError);\n            }\n            attendanceResponse = { items: [] };\n          }\n        }\n        \n        if (attendanceResponse && attendanceResponse.items) {\n          // Add event info to each attendance record\n          const attendanceWithEvent = attendanceResponse.items.map(record => ({\n            ...record,\n            eventid: event.eventid,\n            eventname: event.name,\n            eventdate: event.startdate,\n            sectionid: event.sectionid,\n            sectionname: event.sectionname,\n          }));\n          \n          // Store section-specific data for potential shared event merging\n          sectionSpecificAttendanceData.push({\n            ...attendanceResponse,\n            items: attendanceWithEvent,\n            eventId: event.eventid,\n            sectionId: event.sectionid,\n          });\n          \n          allAttendance.push(...attendanceWithEvent);\n        }\n      }\n      \n      // Process attendance data for events\n      if (sectionSpecificAttendanceData.length > 0) {\n        await processAttendanceData(\n          sectionSpecificAttendanceData, \n          allAttendance,\n          events,\n        );\n      } else {\n        setAttendanceData(allAttendance);\n      }\n      \n      // Load Viking Event Management data (fresh when possible, cache as fallback)\n      await loadVikingEventData();\n      \n    } catch (err) {\n      if (import.meta.env.DEV) {\n        console.error('Error loading attendance:', err);\n      }\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Process attendance data for events\n  const processAttendanceData = async (\n    sectionSpecificAttendanceData, \n    allAttendance,\n    events,\n  ) => {\n    try {\n      // Group attendance data by event ID\n      const eventAttendanceMap = new Map();\n      sectionSpecificAttendanceData.forEach(data => {\n        if (!eventAttendanceMap.has(data.eventId)) {\n          eventAttendanceMap.set(data.eventId, []);\n        }\n        eventAttendanceMap.get(data.eventId).push(data);\n      });\n      \n      const finalAttendanceData = [];\n      \n      // Process each unique event\n      for (const [eventId, eventAttendanceDataArray] of eventAttendanceMap.entries()) {\n        const eventData = events.find(e => e.eventid === eventId);\n        if (!eventData) continue;\n        \n        // Process event attendance data (shared events are handled in eventDashboardHelpers)\n        const sectionAttendees = eventAttendanceDataArray.flatMap(data => data.items || []);\n        finalAttendanceData.push(...sectionAttendees);\n      }\n      \n      logger.info('Attendance data processing completed', {\n        totalAttendees: finalAttendanceData.length,\n        originalCount: allAttendance.length,\n      }, LOG_CATEGORIES.COMPONENT);\n      \n      setAttendanceData(finalAttendanceData);\n      \n    } catch (error) {\n      logger.error('Error in shared event merging, using original data', {\n        error: error.message,\n      }, LOG_CATEGORIES.COMPONENT);\n      \n      // Fallback to original attendance data\n      setAttendanceData(allAttendance);\n    }\n  };\n\n  // Load Viking Event Management flexirecord data (fresh preferred, cache fallback)\n  const loadVikingEventData = async () => {\n    try {\n      const token = getToken();\n      \n      // Enhanced logging for debugging deployed environment issues\n      if (import.meta.env.DEV) {\n        console.log('useAttendanceData: Loading Viking Event data', {\n          eventsCount: events?.length || 0,\n          hasToken: !!token,\n          tokenLength: token?.length || 0,\n          eventSections: events?.map(e => ({ sectionid: e.sectionid, termid: e.termid })) || [],\n        });\n      }\n      \n      if (!token) {\n        logger.info(\n          'useAttendanceData: No token available for FlexiRecord loading; attempting cache-only read',\n          {},\n          LOG_CATEGORIES.APP,\n        );\n        try {\n          // forceRefresh=false to use only local cache\n          const cachedMap = await getVikingEventDataForEvents(events, null, false);\n          if (cachedMap) {\n            setVikingEventData(cachedMap);\n          }\n        } catch (cacheErr) {\n          logger.warn(\n            'useAttendanceData: Cache-only Viking Event data load failed',\n            { error: cacheErr.message },\n            LOG_CATEGORIES.APP,\n          );\n        }\n        return;\n      }\n      \n      // Load Viking Event Management data for all sections\n      // getVikingEventDataForEvents handles section-term combinations correctly\n      const vikingEventMap = await getVikingEventDataForEvents(events, token, true);\n      \n      if (import.meta.env.DEV) {\n        console.log('useAttendanceData: Viking Event data loaded successfully', {\n          sectionsWithData: Array.from(vikingEventMap.entries())\n            .filter(([_, data]) => data !== null)\n            .map(([sectionId, _]) => sectionId),\n          totalSections: vikingEventMap.size,\n        });\n      }\n\n      \n      setVikingEventData(vikingEventMap);\n      \n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.error('useAttendanceData: Error loading Viking Event Management data', {\n          error: error.message,\n          stack: error.stack,\n          eventsCount: events?.length || 0,\n        });\n      }\n      // Don't set error state as this is supplementary data\n    }\n  };\n\n  // Create a memoized lookup map for Viking Event data to improve performance\n  // Builds once when vikingEventData changes, provides O(1) lookups instead of O(n×m) searches\n  const vikingEventLookup = useMemo(() => {\n    const lookup = new Map();\n    for (const [, sectionData] of vikingEventData.entries()) {\n      if (sectionData && sectionData.items) {\n        sectionData.items.forEach(item => {\n          lookup.set(item.scoutid, item);\n        });\n      }\n    }\n    return lookup;\n  }, [vikingEventData]);\n\n  // Enhanced attendance data with Viking Event data attached\n  const enhancedAttendanceData = useMemo(() => {\n    if (!attendanceData || attendanceData.length === 0 || vikingEventLookup.size === 0) {\n      return attendanceData;\n    }\n\n    return attendanceData.map(record => {\n      const vikingData = vikingEventLookup.get(record.scoutid);\n      return {\n        ...record,\n        vikingEventData: vikingData || null,\n      };\n    });\n  }, [attendanceData, vikingEventLookup]);\n\n  // Get Viking Event Management data for a specific member using optimized O(1) lookup\n  const getVikingEventDataForMember = (scoutid) => {\n    return vikingEventLookup.get(scoutid) || null;\n  };\n\n  return {\n    attendanceData: enhancedAttendanceData,\n    vikingEventData,\n    loading,\n    error,\n    loadVikingEventData,\n    getVikingEventDataForMember,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/hooks/useAttendanceFiltering.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"attendanceData\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useMemo } from 'react';\n\n/**\n *\n * @param attendanceData\n * @param events\n */\nfunction useAttendanceFiltering(attendanceData, events) {\n  // Attendance filter state - exclude \"Not Invited\" by default\n  const [attendanceFilters, setAttendanceFilters] = useState({\n    yes: true,\n    no: true,\n    invited: true,\n    notInvited: false,\n  });\n\n  // Section filter state - initialize with all sections enabled except Adults\n  const [sectionFilters, setSectionFilters] = useState(() => {\n    const filters = {};\n    const src = events ?? [];\n    const uniqueSections = [...new Set(src.map((e) => e.sectionid))];\n    uniqueSections.forEach((sectionId) => {\n      // Find the section name to check if it's an Adults section\n      const sectionEvent = src.find((e) => e.sectionid === sectionId);\n      const sectionName = sectionEvent?.sectionname?.toLowerCase() || '';\n\n      // Set Adults sections to false by default, all others to true\n      filters[sectionId] = !sectionName.includes('adults');\n    });\n    return filters;\n  });\n\n  // Data filter state - for controlling which columns to show\n  const [dataFilters, setDataFilters] = useState({\n    contacts: false, // Primary and Emergency contacts (hidden by default as requested)\n  });\n\n  // Sort configuration\n  const [sortConfig, setSortConfig] = useState({\n    key: 'attendance',\n    direction: 'desc',\n  });\n\n  // Filter and sort attendance data\n  const filteredAndSortedData = useMemo(() => {\n    if (!attendanceData || !Array.isArray(attendanceData)) {\n      return [];\n    }\n\n    // Apply filters\n    const filtered = attendanceData.filter((item) => {\n      // Filter by attendance status\n      if (!attendanceFilters.yes && item.attendance === 'Yes') return false;\n      if (!attendanceFilters.no && item.attendance === 'No') return false;\n      if (!attendanceFilters.invited && item.attendance === 'Invited') return false;\n      if (!attendanceFilters.notInvited && item.attendance === 'Not Invited') return false;\n\n      // Filter by section\n      if (!sectionFilters[item.sectionid]) return false;\n\n      return true;\n    });\n\n    // Apply sorting\n    const sorted = [...filtered].sort((a, b) => {\n      const { key, direction } = sortConfig;\n      let aValue, bValue;\n\n      switch (key) {\n      case 'member':\n        aValue = a.name?.toLowerCase() || '';\n        bValue = b.name?.toLowerCase() || '';\n        break;\n        \n      case 'attendance': {\n        // Priority order for attendance status\n        const statusPriority = { 'Yes': 4, 'No': 3, 'Invited': 2, 'Not Invited': 1 };\n        aValue = statusPriority[a.attendance] || 0;\n        bValue = statusPriority[b.attendance] || 0;\n        break;\n      }\n        \n      case 'section':\n      case 'sectionName':\n        aValue = (a.sectionname || a.sectionName || '')?.toLowerCase();\n        bValue = (b.sectionname || b.sectionName || '')?.toLowerCase();\n        break;\n        \n      case 'signintime':\n      case 'signouttime': {\n        const aTime = a[key] ? new Date(a[key]).getTime() : NaN;\n        const bTime = b[key] ? new Date(b[key]).getTime() : NaN;\n        aValue = Number.isFinite(aTime) ? aTime : 0;\n        bValue = Number.isFinite(bTime) ? bTime : 0;\n        break;\n      }\n        \n      default:\n        aValue = a[key] || '';\n        bValue = b[key] || '';\n        break;\n      }\n\n      if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n      if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n      return 0;\n    });\n\n    return sorted;\n  }, [attendanceData, attendanceFilters, sectionFilters, sortConfig]);\n\n  // Handle sort changes\n  const handleSort = (key) => {\n    setSortConfig((prev) => ({\n      key,\n      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc',\n    }));\n  };\n\n  return {\n    attendanceFilters,\n    setAttendanceFilters,\n    sectionFilters,\n    setSectionFilters,\n    dataFilters,\n    setDataFilters,\n    sortConfig,\n    handleSort,\n    filteredAndSortedData,\n  };\n}\n\nexport default useAttendanceFiltering;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/hooks/useAttendanceFormatters.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":5,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"members\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionsCache\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\nimport { findMemberSectionName } from '../../../shared/utils/sectionHelpers.js';\nimport { groupContactInfo } from '../../../shared/utils/contactGroups.js';\n\n/**\n *\n * @param members\n * @param sectionsCache\n */\nexport function useAttendanceFormatters(members, sectionsCache) {\n  const formatUKDateTime = (dateString) => {\n    if (!dateString) return '';\n    \n    try {\n      const date = new Date(dateString);\n      const day = date.getDate().toString().padStart(2, '0');\n      const month = (date.getMonth() + 1).toString().padStart(2, '0');\n      const year = date.getFullYear();\n      const hours = date.getHours().toString().padStart(2, '0');\n      const minutes = date.getMinutes().toString().padStart(2, '0');\n      \n      return `${day}/${month}/${year} ${hours}:${minutes}`;\n    } catch (error) {\n      return dateString;\n    }\n  };\n\n  const getComprehensiveMemberData = useMemo(() => {\n    return (attendanceRecord) => {\n      const scoutidAsNumber = parseInt(attendanceRecord.scoutid, 10);\n      const cachedMember = members?.find((m) => m.scoutid === scoutidAsNumber);\n      \n      if (!cachedMember) {\n        return {\n          ...attendanceRecord,\n          name: attendanceRecord.firstname + ' ' + attendanceRecord.lastname,\n          sectionName: findMemberSectionName(\n            attendanceRecord.sectionid,\n            sectionsCache,\n          ),\n        };\n      }\n      \n      const contactGroups = groupContactInfo(cachedMember);\n      \n      const getField = (groupNames, fieldNames) => {\n        for (const groupName of groupNames) {\n          const group = contactGroups[groupName];\n          if (group) {\n            for (const fieldName of fieldNames) {\n              if (group[fieldName] && group[fieldName] !== '') {\n                return group[fieldName];\n              }\n            }\n          }\n        }\n        return null;\n      };\n      \n      const combineFields = (groupNames, fieldNames, separator = ', ') => {\n        const values = [];\n        for (const groupName of groupNames) {\n          const group = contactGroups[groupName];\n          if (group) {\n            for (const fieldName of fieldNames) {\n              if (group[fieldName] && group[fieldName] !== '' && !values.includes(group[fieldName])) {\n                values.push(group[fieldName]);\n              }\n            }\n          }\n        }\n        return values.length > 0 ? values.join(separator) : null;\n      };\n\n      // Primary contacts\n      const primaryContacts = (() => {\n        const contacts = [];\n        \n        const pc1_name = combineFields(['primary_contact_1'], ['first_name', 'last_name'], ' ') || \n                         getField(['primary_contact_1'], ['name']);\n        const pc1_phone = combineFields(['primary_contact_1'], ['phone_1', 'phone_2']) || \n                          getField(['primary_contact_1'], ['phone']);\n        const pc1_email = combineFields(['primary_contact_1'], ['email_1', 'email_2']) || \n                          getField(['primary_contact_1'], ['email']);\n        \n        if (pc1_name || pc1_phone || pc1_email) {\n          contacts.push({ name: pc1_name, phone: pc1_phone, email: pc1_email });\n        }\n        \n        const pc2_name = combineFields(['primary_contact_2'], ['first_name', 'last_name'], ' ') || \n                         getField(['primary_contact_2'], ['name']);\n        const pc2_phone = combineFields(['primary_contact_2'], ['phone_1', 'phone_2']) || \n                          getField(['primary_contact_2'], ['phone']);\n        const pc2_email = combineFields(['primary_contact_2'], ['email_1', 'email_2']) || \n                          getField(['primary_contact_2'], ['email']);\n        \n        if (pc2_name || pc2_phone || pc2_email) {\n          contacts.push({ name: pc2_name, phone: pc2_phone, email: pc2_email });\n        }\n        \n        return contacts;\n      })();\n\n      // Emergency contacts\n      const emergencyContacts = (() => {\n        const contacts = [];\n        \n        const ec_name = combineFields(['emergency_contact'], ['first_name', 'last_name'], ' ') ||\n                        getField(['emergency_contact'], ['name']);\n        const ec_phone = combineFields(['emergency_contact'], ['phone_1', 'phone_2']) ||\n                         getField(['emergency_contact'], ['phone']);\n        const ec_email = combineFields(['emergency_contact'], ['email_1', 'email_2']) ||\n                         getField(['emergency_contact'], ['email']);\n        \n        if (ec_name || ec_phone || ec_email) {\n          contacts.push({ name: ec_name, phone: ec_phone, email: ec_email });\n        }\n        \n        return contacts;\n      })();\n\n      return {\n        ...attendanceRecord,\n        name: cachedMember.firstname + ' ' + cachedMember.lastname,\n        sectionName: findMemberSectionName(cachedMember.sectionid, sectionsCache),\n        dob: cachedMember.date_of_birth,\n        allergies: cachedMember.custom_data?.allergies,\n        dietaryRequirements: cachedMember.custom_data?.dietary_requirements,\n        medicalConditions: cachedMember.custom_data?.medical_conditions,\n        primaryContacts,\n        emergencyContacts,\n      };\n    };\n  }, [members, sectionsCache]);\n\n  return {\n    formatUKDateTime,\n    getComprehensiveMemberData,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/hooks/useSharedAttendance.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":6,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":6,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"viewMode\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":296,"column":5,"endLine":296,"endColumn":60,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\nimport { getSharedEventAttendance } from '../../../shared/services/api/api.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\nimport { isDemoMode } from '../../../config/demoMode.js';\n\n/**\n *\n * @param events\n * @param viewMode\n */\nexport function useSharedAttendance(events, viewMode) {\n  const [sharedAttendanceData, setSharedAttendanceData] = useState(null);\n  const [loadingSharedAttendance, setLoadingSharedAttendance] = useState(false);\n\n  // Check if there are shared events by looking for shared metadata in localStorage\n  const hasSharedEvents = events && events.some(event => {\n    const prefix = isDemoMode() ? 'demo_' : '';\n    const sharedMetadataKey = `${prefix}viking_shared_metadata_${event.eventid}`;\n    const sharedMetadata = localStorage.getItem(sharedMetadataKey);\n    \n    if (sharedMetadata) {\n      try {\n        const metadata = JSON.parse(sharedMetadata);\n        return metadata._isSharedEvent === true;\n      } catch (error) {\n        console.warn('Failed to parse shared metadata for event:', event.eventid, error);\n        return false;\n      }\n    }\n    \n    return false;\n  });\n\n  // Debug logging for shared events\n  console.log('🐛 SHARED EVENTS DEBUG:', {\n    eventsCount: events?.length || 0,\n    hasSharedEvents,\n    eventDetails: events?.map(e => {\n      const prefix = isDemoMode() ? 'demo_' : '';\n      const sharedMetadataKey = `${prefix}viking_shared_metadata_${e.eventid}`;\n      const sharedMetadata = localStorage.getItem(sharedMetadataKey);\n      let isShared = false;\n      \n      if (sharedMetadata) {\n        try {\n          const metadata = JSON.parse(sharedMetadata);\n          isShared = metadata._isSharedEvent === true;\n        } catch (error) {\n          // Ignore parse errors for debug logging\n        }\n      }\n      \n      return {\n        name: e.eventname,\n        eventid: e.eventid,\n        sharedMetadataKey,\n        hasMetadata: !!sharedMetadata,\n        isShared,\n      };\n    }) || [],\n  });\n\n  useEffect(() => {\n    console.log('🐛 useSharedAttendance useEffect triggered:', {\n      viewMode,\n      hasSharedEvents,\n      sharedAttendanceData: !!sharedAttendanceData,\n      isDemoMode: isDemoMode(),\n      shouldLoad: viewMode === 'sharedAttendance' && hasSharedEvents && (!sharedAttendanceData || (Array.isArray(sharedAttendanceData) && sharedAttendanceData.length === 0)),\n    });\n    \n    if (\n      viewMode === 'sharedAttendance' &&\n      hasSharedEvents &&\n      !loadingSharedAttendance &&\n      (!sharedAttendanceData || (Array.isArray(sharedAttendanceData) && sharedAttendanceData.length === 0))\n    ) {\n      console.log('🐛 Loading shared attendance data...');\n      const loadSharedAttendance = async () => {\n        setLoadingSharedAttendance(true);\n        try {\n          if (isDemoMode()) {\n            console.log('🐛 Demo mode: Loading shared attendance from localStorage');\n            // In demo mode, load shared attendance data from localStorage\n            const sharedEvents = events.filter(event => {\n              const prefix = 'demo_';\n              const sharedMetadataKey = `${prefix}viking_shared_metadata_${event.eventid}`;\n              const sharedMetadata = localStorage.getItem(sharedMetadataKey);\n              \n              if (sharedMetadata) {\n                try {\n                  const metadata = JSON.parse(sharedMetadata);\n                  return metadata._isSharedEvent === true;\n                } catch (error) {\n                  console.warn('Failed to parse shared metadata for event:', event.eventid, error);\n                  return false;\n                }\n              }\n              \n              return false;\n            });\n\n            // Load cached shared attendance data for demo mode\n            const combinedData = [];\n            sharedEvents.forEach(event => {\n              const sharedAttendanceKey = `demo_viking_shared_attendance_${event.eventid}_${event.sectionid}_offline`;\n              const sharedAttendanceData = localStorage.getItem(sharedAttendanceKey);\n              \n              if (sharedAttendanceData) {\n                try {\n                  const attendanceData = JSON.parse(sharedAttendanceData);\n                  // Handle both direct array format and object with items property\n                  if (Array.isArray(attendanceData)) {\n                    combinedData.push(...attendanceData);\n                  } else if (attendanceData && Array.isArray(attendanceData.items)) {\n                    combinedData.push(...attendanceData.items);\n                  }\n                } catch (error) {\n                  console.warn('Failed to parse shared attendance data for event:', event.eventid, error);\n                }\n              } else {\n                // If shared attendance data doesn't exist, try to generate it from individual section data\n                console.log('🐛 No shared attendance data found, attempting to generate from section data for event:', event.eventid);\n                const sharedMetadataKey = `demo_viking_shared_metadata_${event.eventid}`;\n                const sharedMetadata = localStorage.getItem(sharedMetadataKey);\n                \n                if (sharedMetadata) {\n                  try {\n                    const metadata = JSON.parse(sharedMetadata);\n                    if (metadata._allSections) {\n                      metadata._allSections.forEach(section => {\n                        if (section.sectionid && section.eventid) {\n                          const sectionAttendanceKey = `demo_viking_attendance_${section.eventid}_offline`;\n                          const sectionAttendanceData = localStorage.getItem(sectionAttendanceKey);\n                          \n                          if (sectionAttendanceData) {\n                            try {\n                              const sectionData = JSON.parse(sectionAttendanceData);\n                              if (Array.isArray(sectionData)) {\n                                combinedData.push(...sectionData);\n                              }\n                            } catch (error) {\n                              console.warn('Failed to parse section attendance data for section:', section.sectionid, error);\n                            }\n                          }\n                        }\n                      });\n                    }\n                  } catch (error) {\n                    console.warn('Failed to parse shared metadata for event:', event.eventid, error);\n                  }\n                }\n              }\n            });\n\n            setSharedAttendanceData(combinedData);\n          } else {\n            // Production mode - first try cache, then API, then generate from section data\n            \n            // Find the shared event (the one that has shared metadata)\n            const sharedEvent = events.find(event => {\n              const metadata = localStorage.getItem(`viking_shared_metadata_${event.eventid}`);\n              if (metadata) {\n                try {\n                  const parsed = JSON.parse(metadata);\n                  return parsed._isSharedEvent === true;\n                } catch (e) {\n                  return false;\n                }\n              }\n              return false;\n            });\n\n            if (!sharedEvent) {\n              console.warn('No shared event found');\n              setSharedAttendanceData([]);\n              return;\n            }\n\n            // First try to load from cache for offline support\n            const cacheKey = `viking_shared_attendance_${sharedEvent.eventid}_${sharedEvent.sectionid}_offline`;\n            let cachedData = null;\n\n            try {\n              const cached = localStorage.getItem(cacheKey);\n              if (cached) {\n                cachedData = JSON.parse(cached);\n                console.log('🐛 Found cached shared attendance data');\n              }\n            } catch (cacheError) {\n              console.warn('Failed to parse cached shared attendance data:', cacheError);\n            }\n\n            const token = getToken();\n            let sharedData = null;\n\n            // Try API call if we have a token\n            if (token) {\n              try {\n                console.log('🐛 Fetching shared attendance from API...', {\n                  eventId: sharedEvent.eventid,\n                  sectionId: sharedEvent.sectionid,\n                });\n                sharedData = await getSharedEventAttendance(sharedEvent.eventid, sharedEvent.sectionid, token);\n                \n                // Cache the API response for offline use\n                if (sharedData) {\n                  localStorage.setItem(cacheKey, JSON.stringify(sharedData));\n                  console.log('🐛 Cached shared attendance data for offline use');\n                }\n              } catch (apiError) {\n                console.warn('API call failed, will use cached data if available:', apiError);\n                // If API fails, fallback to cached data\n                if (cachedData) {\n                  sharedData = cachedData;\n                } else {\n                  console.warn('No cached data available, will attempt to generate from section data');\n                }\n              }\n            } else {\n              // No token - use cached data or try to generate\n              console.warn('No authentication token available for shared attendance');\n              if (cachedData) {\n                sharedData = cachedData;\n              } else {\n                console.warn('No cached data available, will attempt to generate from section data');\n              }\n            }\n\n            // If we still don't have data, try to generate it from section data\n            if (!sharedData) {\n              console.log('🐛 Attempting to generate shared attendance from section data');\n              const combinedData = [];\n              const sharedMetadataKey = `viking_shared_metadata_${sharedEvent.eventid}`;\n              const sharedMetadata = localStorage.getItem(sharedMetadataKey);\n              \n              if (sharedMetadata) {\n                try {\n                  const metadata = JSON.parse(sharedMetadata);\n                  if (metadata._allSections) {\n                    metadata._allSections.forEach(section => {\n                      if (section.receiving_eventid && section.receiving_eventid !== '0') {\n                        const sectionAttendanceKey = `viking_attendance_${section.receiving_eventid}_offline`;\n                        const sectionAttendanceData = localStorage.getItem(sectionAttendanceKey);\n                        \n                        if (sectionAttendanceData) {\n                          try {\n                            const sectionData = JSON.parse(sectionAttendanceData);\n                            if (Array.isArray(sectionData)) {\n                              combinedData.push(...sectionData);\n                            }\n                          } catch (error) {\n                            console.warn('Failed to parse section attendance data for section:', section.sectionid, error);\n                          }\n                        }\n                      }\n                    });\n                  }\n                } catch (error) {\n                  console.warn('Failed to parse shared metadata for event:', sharedEvent.eventid, error);\n                }\n              }\n              \n              if (combinedData.length > 0) {\n                console.log('🐛 Successfully generated shared attendance from section data:', combinedData.length, 'records');\n                // Cache the generated data for future use\n                const generatedSharedData = { items: combinedData };\n                localStorage.setItem(cacheKey, JSON.stringify(generatedSharedData));\n                setSharedAttendanceData(combinedData);\n                return;\n              }\n            }\n\n            // Normalize data shape - UI expects array but API may return object with items\n            if (sharedData) {\n              const normalised = sharedData?.items\n                ? sharedData.items\n                : sharedData?.combined_attendance || [];\n              \n              setSharedAttendanceData(normalised);\n            } else {\n              console.warn('No shared attendance data available from any source');\n              setSharedAttendanceData([]);\n            }\n          }\n        } catch (error) {\n          console.error('Error loading shared attendance:', error);\n          setSharedAttendanceData([]);\n        } finally {\n          setLoadingSharedAttendance(false);\n        }\n      };\n\n      loadSharedAttendance();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [viewMode, hasSharedEvents, events]);\n\n  return {\n    sharedAttendanceData,\n    loadingSharedAttendance,\n    hasSharedEvents,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/services/campGroupAllocationService.js","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":30,"column":1,"nodeType":"Block","endLine":35,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"moveData\" description.","line":33,"column":1,"nodeType":"Block","endLine":33,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"flexiRecordContext\" description.","line":34,"column":1,"nodeType":"Block","endLine":34,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":88,"column":1,"nodeType":"Block","endLine":93,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":88,"column":1,"nodeType":"Block","endLine":93,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"moveData\" description.","line":90,"column":1,"nodeType":"Block","endLine":90,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"flexiRecordContext\" description.","line":91,"column":1,"nodeType":"Block","endLine":91,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":92,"column":1,"nodeType":"Block","endLine":92,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":265,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":265,"endColumn":48}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { updateFlexiRecord } from '../../../shared/services/api/api.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport { sentryUtils } from '../../../shared/services/utils/sentry.js';\nimport { isDemoMode } from '../../../config/demoMode.js';\nimport { safeGetItem, safeSetItem } from '../../../shared/utils/storageUtils.js';\n\n/**\n * Service for managing camp group member allocations\n * Handles moving members between groups via OSM FlexiRecord API\n */\n\n/**\n * Move a member to a different camp group\n * \n * @param {object} moveData - The move operation data\n * @param {object} moveData.member - Member being moved\n * @param {string} moveData.fromGroupNumber - Original group number\n * @param {string} moveData.fromGroupName - Original group name  \n * @param {string} moveData.toGroupNumber - Target group number\n * @param {string} moveData.toGroupName - Target group name\n * @param {object} flexiRecordContext - FlexiRecord configuration\n * @param {string} flexiRecordContext.flexirecordid - FlexiRecord ID\n * @param {string} flexiRecordContext.columnid - Column ID for CampGroup field\n * @param {string} flexiRecordContext.sectionid - Section ID\n * @param {string} flexiRecordContext.termid - Term ID\n * @param {string} flexiRecordContext.section - Section name\n * @param {string} token - Authentication token\n * @returns {Promise<object>} Result with success status and details\n */\n/**\n * Demo mode version of camp group assignment\n * Updates localStorage cache instead of calling OSM API\n * @param moveData\n * @param flexiRecordContext\n */\nfunction assignMemberToCampGroupDemo(moveData, flexiRecordContext) {\n  try {\n    const memberName = moveData.member.name || `${moveData.member.firstname} ${moveData.member.lastname}` || 'Unknown';\n    \n    logger.info('Demo mode: Assigning member to camp group', {\n      memberId: moveData.member.scoutid,\n      memberName,\n      toGroup: moveData.toGroupNumber,\n    }, LOG_CATEGORIES.API);\n    \n    // In demo mode, use standardized values\n    const flexirecordid = flexiRecordContext?.flexirecordid || 'flexi_viking_event';\n    const sectionid = flexiRecordContext?.sectionid || moveData.member.sectionid;\n    const termid = flexiRecordContext?.termid || '12345';\n    \n    const cacheKey = `viking_flexi_data_${flexirecordid}_${sectionid}_${termid}_offline`;\n    const cached = safeGetItem(cacheKey, { items: [] });\n    \n    // Convert scoutid to match the type in cache (both to numbers for comparison)\n    const memberScoutId = Number(moveData.member.scoutid);\n    const memberIndex = cached.items.findIndex(m => Number(m.scoutid) === memberScoutId);\n    if (memberIndex >= 0) {\n      const newValue = (moveData.toGroupNumber === 'Unassigned' || !moveData.toGroupNumber) ? '' : moveData.toGroupNumber.toString();\n      \n      // Update both f_1 (the flexi field) and CampGroup (the transformed field)\n      cached.items[memberIndex].f_1 = newValue;\n      cached.items[memberIndex].CampGroup = newValue;\n      \n      safeSetItem(cacheKey, cached);\n      \n      return {\n        ok: true,\n        success: true,\n        message: `Demo mode: ${memberName} moved to group ${moveData.toGroupNumber}`,\n      };\n    } else {\n      throw new Error(`Member ${memberName} not found in demo cache`);\n    }\n  } catch (error) {\n    logger.error('Demo mode: Failed to assign member to camp group', {\n      error: error.message,\n      moveData,\n    }, LOG_CATEGORIES.API);\n    \n    return {\n      ok: false,\n      success: false,\n      error: error.message,\n    };\n  }\n}\n\n/**\n *\n * @param moveData\n * @param flexiRecordContext\n * @param token\n */\nexport async function assignMemberToCampGroup(moveData, flexiRecordContext, token) {\n  // Handle demo mode\n  if (isDemoMode()) {\n    return assignMemberToCampGroupDemo(moveData, flexiRecordContext);\n  }\n  \n  // Production mode continues below\n  const startTime = Date.now();\n  \n  try {\n    // Validate required data FIRST\n    if (!moveData.member || !moveData.member.scoutid) {\n      throw new Error('Invalid member data: missing scoutid');\n    }\n\n    // Now safe to log with member data\n    logger.info('Starting camp group assignment', {\n      memberId: moveData.member.scoutid,\n      memberName: moveData.member.name || `${moveData.member.firstname} ${moveData.member.lastname}` || 'Unknown',\n      fromGroup: moveData.fromGroupNumber,\n      toGroup: moveData.toGroupNumber,\n      operation: 'assignMemberToCampGroup',\n    }, LOG_CATEGORIES.API);\n\n    if (!flexiRecordContext || !flexiRecordContext.flexirecordid) {\n      throw new Error('Invalid FlexiRecord context: missing flexirecordid');\n    }\n\n    // Validate all required FlexiRecord context fields\n    if (!flexiRecordContext.sectionid) {\n      throw new Error('Invalid FlexiRecord context: missing sectionid');\n    }\n\n    if (!flexiRecordContext.termid) {\n      throw new Error('Invalid FlexiRecord context: missing termid');\n    }\n\n    if (!flexiRecordContext.section) {\n      throw new Error('Invalid FlexiRecord context: missing section name');\n    }\n\n    // Validate columnid follows the f_N pattern (e.g., f_1, f_2, f_3)\n    if (!flexiRecordContext.columnid || !/^f_\\d+$/.test(flexiRecordContext.columnid)) {\n      throw new Error(`Invalid FlexiRecord field ID: expected format 'f_N', got '${flexiRecordContext.columnid || 'undefined'}'`);\n    }\n\n    // Validate token is provided\n    if (!token || typeof token !== 'string') {\n      throw new Error('Invalid or missing authentication token');\n    }\n\n    // Determine the new group value for the API\n    // Empty string or null for \"Unassigned\", otherwise the group number\n    const newGroupValue = (moveData.toGroupNumber === 'Unassigned' || !moveData.toGroupNumber) \n      ? '' \n      : moveData.toGroupNumber.toString();\n\n    // Call the existing updateFlexiRecord API\n    const result = await updateFlexiRecord(\n      flexiRecordContext.sectionid,\n      moveData.member.scoutid,\n      flexiRecordContext.flexirecordid,\n      flexiRecordContext.columnid,\n      newGroupValue,\n      flexiRecordContext.termid,\n      flexiRecordContext.section,\n      token,\n    );\n\n    // Check for application-level failure (API can return HTTP 200 with ok: false)\n    if (!result || result.ok === false || result.status === 'error' || result.success === false) {\n      throw new Error(result?.message || result?.error || 'FlexiRecord update failed - API returned error status');\n    }\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Camp group assignment successful', {\n      memberId: moveData.member.scoutid,\n      fromGroup: moveData.fromGroupNumber,\n      toGroup: moveData.toGroupNumber,\n      newValue: newGroupValue,\n      duration: `${duration}ms`,\n      operation: 'assignMemberToCampGroup',\n    }, LOG_CATEGORIES.API);\n\n    return {\n      success: true,\n      moveData,\n      result,\n      duration,\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    \n    logger.error('Camp group assignment failed', {\n      memberId: moveData.member?.scoutid,\n      memberName: moveData.member ? (moveData.member.name || `${moveData.member.firstname} ${moveData.member.lastname}` || 'Unknown') : 'Unknown',\n      fromGroup: moveData.fromGroupNumber,\n      toGroup: moveData.toGroupNumber,\n      error: error.message,\n      duration: `${duration}ms`,\n      operation: 'assignMemberToCampGroup',\n    }, LOG_CATEGORIES.ERROR);\n\n    // Capture in Sentry with context\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'assignMemberToCampGroup',\n        memberType: moveData.member?.person_type || 'Unknown',\n      },\n      contexts: {\n        move: {\n          memberId: moveData.member?.scoutid,\n          fromGroup: moveData.fromGroupNumber,\n          toGroup: moveData.toGroupNumber,\n        },\n        flexiRecord: {\n          id: flexiRecordContext?.flexirecordid,\n          columnid: flexiRecordContext?.columnid,\n          sectionid: flexiRecordContext?.sectionid,\n        },\n      },\n    });\n\n    return {\n      success: false,\n      moveData,\n      error: error.message,\n      duration,\n    };\n  }\n}\n\n/**\n * Process multiple member moves in sequence\n * Useful for bulk operations or retry scenarios\n * \n * @param {Array<object>} moves - Array of move operations\n * @param {object} flexiRecordContext - FlexiRecord configuration \n * @param {string} token - Authentication token\n * @returns {Promise<Array<object>>} Array of results for each move\n */\nexport async function batchAssignMembers(moves, flexiRecordContext, token) {\n  logger.info('Starting batch camp group assignment', {\n    totalMoves: moves.length,\n    operation: 'batchAssignMembers',\n  }, LOG_CATEGORIES.API);\n\n  const results = [];\n  let successCount = 0;\n  let errorCount = 0;\n\n  for (const [index, move] of moves.entries()) {\n    try {\n      logger.debug(`Processing batch move ${index + 1}/${moves.length}`, {\n        memberId: move.member?.scoutid,\n        memberName: move.member ? (move.member.name || `${move.member.firstname} ${move.member.lastname}` || 'Unknown') : 'Unknown',\n      }, LOG_CATEGORIES.API);\n\n      const result = await assignMemberToCampGroup(move, flexiRecordContext, token);\n      results.push(result);\n      \n      if (result.success) {\n        successCount++;\n      } else {\n        errorCount++;\n      }\n\n      // Rate limiting: small delay between API calls\n      if (index < moves.length - 1) {\n        await new Promise(resolve => setTimeout(resolve, 200));\n      }\n\n    } catch (error) {\n      logger.error(`Batch move ${index + 1} failed`, {\n        memberId: move.member?.scoutid,\n        error: error.message,\n      }, LOG_CATEGORIES.ERROR);\n\n      results.push({\n        success: false,\n        moveData: move,\n        error: error.message,\n      });\n      errorCount++;\n    }\n  }\n\n  logger.info('Batch camp group assignment completed', {\n    totalMoves: moves.length,\n    successCount,\n    errorCount,\n    operation: 'batchAssignMembers',\n  }, LOG_CATEGORIES.API);\n\n  return {\n    results,\n    summary: {\n      total: moves.length,\n      successful: successCount,\n      failed: errorCount,\n    },\n  };\n}\n\n/**\n * Extract FlexiRecord context from Viking Event data\n * \n * @param {object} vikingEventData - Viking Event Management FlexiRecord data\n * @param {string} sectionId - Section ID\n * @param {string} termId - Term ID\n * @param {string} sectionName - Section name\n * @returns {object | null} FlexiRecord context or null if not available\n */\nexport function extractFlexiRecordContext(vikingEventData, sectionId, termId, sectionName) {\n  // Debug: Log the actual data being passed\n  logger.info('DEBUG: extractFlexiRecordContext called', {\n    vikingEventData: vikingEventData ? Object.keys(vikingEventData) : 'null',\n    vikingEventDataType: typeof vikingEventData,\n    sectionId,\n    termId,\n    sectionName,\n    fullDataSample: vikingEventData ? JSON.stringify(vikingEventData, null, 2).substring(0, 500) + '...' : 'null',\n  }, LOG_CATEGORIES.APP);\n  \n  // Try both _structure and structure properties for compatibility\n  const structure = vikingEventData?._structure || vikingEventData?.structure;\n  \n  if (!vikingEventData || !structure) {\n    logger.warn('No Viking Event data or structure available', {\n      hasData: !!vikingEventData,\n      hasStructure: !!structure,\n      hasUnderscoreStructure: !!(vikingEventData?._structure),\n      hasRegularStructure: !!(vikingEventData?.structure),\n      sectionId,\n    }, LOG_CATEGORIES.APP);\n    return null;\n  }\n\n  // Find the CampGroup field mapping from the structure\n  // Field mapping is now keyed by field IDs (f_1, f_2, etc.) not by field names\n  const campGroupField = Object.values(structure.fieldMapping || {})\n    .find(field => field.name === 'CampGroup');\n  \n  if (!campGroupField) {\n    logger.warn('No CampGroup field found in FlexiRecord structure', {\n      availableFields: Object.keys(structure.fieldMapping || {}),\n      availableFieldNames: Object.values(structure.fieldMapping || {}).map(f => f.name),\n      sectionId,\n    }, LOG_CATEGORIES.APP);\n    return null;\n  }\n\n  return {\n    flexirecordid: structure.flexirecordid,\n    columnid: campGroupField.columnId, // Should be f_1\n    sectionid: sectionId,\n    termid: termId,\n    section: sectionName,\n  };\n}\n\n/**\n * Validate that a member can be moved to a specific group\n * \n * @param {object} member - Member data\n * @param {string} targetGroupNumber - Target group number\n * @param {object} currentGroups - Current group organization\n * @returns {object} Validation result with success/error details\n */\nexport function validateMemberMove(member, targetGroupNumber, currentGroups) {\n  // Validate member object exists\n  if (!member) {\n    return {\n      valid: false,\n      error: 'Cannot find member: member object is undefined',\n    };\n  }\n\n  // Only Young People can be moved between camp groups\n  if (member.person_type !== 'Young People') {\n    return {\n      valid: false,\n      error: 'Only Young People can be assigned to camp groups',\n    };\n  }\n\n  // Check if target group exists (unless it's \"Unassigned\")\n  if (targetGroupNumber !== 'Unassigned' && targetGroupNumber !== '') {\n    const targetGroup = Object.values(currentGroups).find(\n      group => String(group.number) === String(targetGroupNumber),\n    );\n    \n    if (!targetGroup) {\n      return {\n        valid: false,\n        error: `Target group ${targetGroupNumber} does not exist`,\n      };\n    }\n  }\n\n  return {\n    valid: true,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/services/flexiRecordService.js","messages":[{"ruleId":"jsdoc/valid-types","severity":2,"message":"Syntax error in namepath: ../../../shared/utils/storageUtils","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1},{"ruleId":"jsdoc/valid-types","severity":2,"message":"Syntax error in namepath: ../../../shared/utils/networkUtils","line":18,"column":1,"nodeType":"Block","endLine":18,"endColumn":1},{"ruleId":"jsdoc/valid-types","severity":2,"message":"Syntax error in namepath: ../../../shared/services/utils/logger","line":19,"column":1,"nodeType":"Block","endLine":19,"endColumn":1},{"ruleId":"jsdoc/valid-types","severity":2,"message":"Syntax error in namepath: ../../../shared/services/utils/sentry","line":20,"column":1,"nodeType":"Block","endLine":20,"endColumn":1},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":94,"column":1,"nodeType":"Block","endLine":112,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":190,"column":1,"nodeType":"Block","endLine":221,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":296,"column":1,"nodeType":"Block","endLine":334,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":517,"column":1,"nodeType":"Block","endLine":570,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":651,"column":1,"nodeType":"Block","endLine":701,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":1346,"column":1,"nodeType":"Block","endLine":1348,"endColumn":4}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file FlexiRecord Service for Viking Event Management\n * \n * Comprehensive service for managing OSM FlexiRecord operations with offline-first\n * architecture and intelligent caching. Handles Scout attendance data, section\n * movement tracking, and custom data fields with automatic fallback mechanisms.\n * \n * Key features:\n * - Offline-first with localStorage caching and TTL management\n * - Specialized support for Viking Event Management and Section Movers FlexiRecords\n * - Network-aware operations with automatic fallback to cached data\n * - Demo mode data segregation and comprehensive error handling\n * - Field mapping and data transformation for meaningful FlexiRecord usage\n * - Multi-section FlexiRecord discovery and validation\n * \n * @module FlexiRecordService\n * @requires ../../../shared/utils/storageUtils\n * @requires ../../../shared/utils/networkUtils\n * @requires ../../../shared/services/utils/logger\n * @requires ../../../shared/services/utils/sentry\n */\n\n/**\n * Validates if authentication token is usable for API calls\n * \n * @private\n * @param {string} token - Authentication token to validate\n * @returns {boolean} True if token is usable for API requests\n * \n * @example\n * // Check token before API call\n * if (hasUsableToken(authToken)) {\n *   // Proceed with API request\n * } else {\n *   // Use cached data only\n * }\n */\nfunction hasUsableToken(token) {\n  if (typeof token !== 'string') {\n    return false;\n  }\n  return token.trim().length > 0;\n}\n\n/**\n * Normalizes ID values to strings with validation\n * \n * @private\n * @param {string|number} id - ID to normalize\n * @param {string} name - Name of the ID for error messages\n * @returns {string} Normalized string ID\n * @throws {Error} If ID is invalid or empty\n * \n * @example\n * // Normalize section ID\n * const sectionId = normalizeId(123, 'sectionId'); // Returns \"123\"\n * const termId = normalizeId('term_456', 'termId'); // Returns \"term_456\"\n */\nfunction normalizeId(id, name) {\n  if (typeof id === 'number') return String(id);\n  if (typeof id === 'string' && id.trim() !== '' && id !== 'undefined' && id !== 'null') return id;\n  throw new Error(`Valid ${name} (string or number) is required`);\n}\n\nimport { safeGetItem, safeSetItem } from '../../../shared/utils/storageUtils.js';\nimport { checkNetworkStatus } from '../../../shared/utils/networkUtils.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport { sentryUtils } from '../../../shared/services/utils/sentry.js';\nimport { isDemoMode } from '../../../config/demoMode.js';\nimport { \n  getFlexiRecords,\n  getFlexiStructure, \n  getSingleFlexiRecord,\n} from '../../../shared/services/api/api.js';\n\n/**\n * Cache TTL constants for different types of FlexiRecord data\n * \n * Optimized for different data change frequencies:\n * - Structures change rarely (field definitions are static)\n * - Data changes frequently (attendance is live during events)\n * - Lists change occasionally (new FlexiRecords added periodically)\n */\n\n/** @constant {number} Cache TTL for FlexiRecord structures (1 hour) */\nconst FLEXI_STRUCTURES_CACHE_TTL = 60 * 60 * 1000; // 1 hour - field definitions are static\n\n/** @constant {number} Cache TTL for FlexiRecord data (5 minutes) */\nconst FLEXI_DATA_CACHE_TTL = 5 * 60 * 1000; // 5 minutes - attendance changes frequently\n\n/** @constant {number} Cache TTL for FlexiRecord lists (30 minutes) */\nconst FLEXI_LISTS_CACHE_TTL = 30 * 60 * 1000; // 30 minutes - available flexirecords per section\n\n/**\n * Checks if localStorage cache is still valid based on TTL\n * \n * @private\n * @param {string} cacheKey - Cache key to check\n * @param {number} ttl - Time-to-live in milliseconds\n * @returns {object} Cache validity result with data and age information\n * @returns {boolean} returns.valid - Whether cache is still valid\n * @returns {*} returns.data - Cached data if available\n * @returns {number} returns.cacheAgeMinutes - Age of cache in minutes\n * \n * @example\n * // Check if events cache is valid\n * const cacheCheck = isCacheValid('viking_events_1_offline', FLEXI_LISTS_CACHE_TTL);\n * if (cacheCheck.valid) {\n *   console.log(`Using cache from ${cacheCheck.cacheAgeMinutes} minutes ago`);\n *   return cacheCheck.data;\n * }\n */\nfunction isCacheValid(cacheKey, ttl) {\n  const cached = safeGetItem(cacheKey, null);\n  if (!cached || !cached._cacheTimestamp) {\n    return { valid: false, data: null };\n  }\n  \n  const cacheAge = Date.now() - cached._cacheTimestamp;\n  const isValid = cacheAge < ttl;\n  \n  return { valid: isValid, data: cached, cacheAgeMinutes: Math.round(cacheAge / 60000) };\n}\n\n/**\n * Caches data with timestamp and comprehensive error handling\n * \n * @private\n * @param {string} cacheKey - Cache key for localStorage\n * @param {*} data - Data to cache (will be JSON serialized)\n * @returns {*} Original data without timestamp (for chaining)\n * \n * @example\n * // Cache FlexiRecord data with automatic timestamp\n * const cachedData = cacheData('viking_flexi_data_123_offline', flexiData);\n * return cachedData; // Returns original data for immediate use\n */\nfunction cacheData(cacheKey, data) {\n  const cachedData = {\n    ...data,\n    _cacheTimestamp: Date.now(),\n  };\n  \n  // Pre-compute once; guard against (de)serialisation errors in logs\n  const itemCount = Array.isArray(cachedData.items) ? cachedData.items.length : 0;\n  let dataSize;\n  try {\n    dataSize = new globalThis.TextEncoder().encode(JSON.stringify(cachedData)).length;\n  } catch {\n    dataSize = null; // not JSON-serialisable\n  }\n\n  try {\n    const success = safeSetItem(cacheKey, cachedData);\n    if (success) {\n      // FlexiRecord data cached successfully\n    } else {\n      logger.error('FlexiRecord caching failed - safeSetItem returned falsy', {\n        cacheKey,\n        dataSize,\n        itemCount,\n      }, LOG_CATEGORIES.ERROR);\n    }\n  } catch (cacheError) {\n    logger.error('FlexiRecord caching error', {\n      cacheKey,\n      error: cacheError.message,\n      dataSize,\n      itemCount,\n    }, LOG_CATEGORIES.ERROR);\n    \n    sentryUtils.captureException(cacheError, {\n      tags: {\n        operation: 'flexirecord_cache',\n        cacheKey,\n      },\n      contexts: {\n        data: {\n          size: dataSize,\n          hasItems: itemCount > 0,\n          itemCount,\n        },\n      },\n    });\n  }\n  \n  return data; // Return original data without timestamp\n}\n\n/**\n * Gets available FlexiRecords for a Scout section with intelligent caching\n * \n * Retrieves list of FlexiRecords available for a section with offline-first\n * approach and demo mode support. Uses localStorage caching with configurable\n * TTL and automatically falls back to cached data when offline or on API failure.\n * \n * @async\n * @param {string|number} sectionId - Section identifier\n * @param {string} token - OSM authentication token (null for offline mode)\n * @param {boolean} [forceRefresh=false] - Force API call ignoring cache validity\n * @returns {Promise<object>} FlexiRecords list with metadata\n * @returns {Array} returns.items - Array of available FlexiRecord objects\n * @returns {number} [returns._cacheTimestamp] - Cache timestamp for debugging\n * \n * @example\n * // Get FlexiRecords for Beavers section\n * const flexiRecords = await getFlexiRecordsList(1, authToken);\n * \n * console.log(`Found ${flexiRecords.items.length} FlexiRecords:`);\n * flexiRecords.items.forEach(record => {\n *   console.log(`- ${record.name} (ID: ${record.extraid})`);\n * });\n * \n * @example\n * // Force refresh for up-to-date data\n * const freshRecords = await getFlexiRecordsList(sectionId, token, true);\n * \n * @example\n * // Offline usage with cached data\n * const cachedRecords = await getFlexiRecordsList(sectionId, null);\n */\nexport async function getFlexiRecordsList(sectionId, token, forceRefresh = false) {\n  sectionId = normalizeId(sectionId, 'sectionId');\n  \n  if (typeof forceRefresh !== 'boolean') {\n    forceRefresh = false;\n  }\n  \n  try {\n    // Skip API calls in demo mode - use cached data only\n    if (isDemoMode()) {\n      const cacheKey = `demo_viking_flexi_lists_${sectionId}_offline`;\n      const cached = safeGetItem(cacheKey, { items: [] });\n      return cached;\n    }\n    \n    const cacheKey = `viking_flexi_lists_${sectionId}_offline`;\n    \n    // If no token available, skip API calls and use empty cache fallback\n    if (!hasUsableToken(token)) {\n      logger.info('No usable token for section, skipping API call', { sectionId }, LOG_CATEGORIES.APP);\n      const emptyCache = safeGetItem(cacheKey, { items: [] });\n      return emptyCache;\n    }\n    \n    // Check network status first\n    const isOnline = await checkNetworkStatus();\n    \n    // Check if we have valid cached data (unless force refresh)\n    if (!forceRefresh && isOnline) {\n      const cacheCheck = isCacheValid(cacheKey, FLEXI_LISTS_CACHE_TTL);\n      if (cacheCheck.valid) {\n        return cacheCheck.data;\n      }\n    }\n    \n    // If offline, get from localStorage regardless of age\n    if (!isOnline) {\n      const cached = safeGetItem(cacheKey, { items: [] });\n      return cached;\n    }\n\n    // token is guaranteed here due to early return above\n\n    // Get fresh data from API\n    const flexiRecords = await getFlexiRecords(sectionId, token);\n    \n    // Cache data with timestamp\n    const cachedData = cacheData(cacheKey, flexiRecords);\n    \n    return cachedData;\n    \n  } catch (error) {\n    logger.error('Error fetching flexirecords list', {\n      sectionId,\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    // Try cache as fallback\n    try {\n      const cacheKey = `viking_flexi_lists_${sectionId}_offline`;\n      const cached = safeGetItem(cacheKey, null);\n      if (cached) {\n        logger.warn('Using cached flexirecords list after API failure', { sectionId });\n        return cached;\n      }\n    } catch (cacheError) {\n      logger.error('Cache fallback failed', { error: cacheError.message });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Gets FlexiRecord structure with field definitions and metadata\n * \n * Retrieves the structure/schema for a specific FlexiRecord including field\n * definitions, types, and configuration. Cached longer than data as field\n * definitions rarely change. Essential for understanding FlexiRecord layout\n * and mapping field IDs to meaningful names.\n * \n * @async\n * @param {string|number} flexirecordId - FlexiRecord identifier\n * @param {string|number} sectionId - Section identifier\n * @param {string|number} termId - Term identifier\n * @param {string} token - OSM authentication token (null for offline mode)\n * @param {boolean} [forceRefresh=false] - Force API call ignoring cache validity\n * @returns {Promise<object | null>} FlexiRecord structure or null if not found\n * @returns {string} returns.name - FlexiRecord name\n * @returns {string} returns.extraid - FlexiRecord external ID\n * @returns {object} returns.structure - Field definitions and configuration\n * @returns {number} [returns._cacheTimestamp] - Cache timestamp for debugging\n * \n * @example\n * // Get structure for Viking Event Management FlexiRecord\n * const structure = await getFlexiRecordStructure('flexi_123', 1, 'term_456', token);\n * \n * if (structure) {\n *   console.log(`FlexiRecord: ${structure.name}`);\n *   console.log('Available fields:', Object.keys(structure.structure.columns));\n * }\n * \n * @example\n * // Use structure to understand field mappings\n * const structure = await getFlexiRecordStructure(flexiId, sectionId, termId, token);\n * const fieldMapping = parseFlexiStructure(structure);\n * \n * // Map field IDs to human-readable names\n * fieldMapping.forEach((fieldInfo, fieldId) => {\n *   console.log(`Field ${fieldId}: ${fieldInfo.name} (${fieldInfo.type})`);\n * });\n */\nexport async function getFlexiRecordStructure(flexirecordId, sectionId, termId, token, forceRefresh = false) {\n  flexirecordId = normalizeId(flexirecordId, 'flexirecordId');\n  sectionId = normalizeId(sectionId, 'sectionId');\n  termId = normalizeId(termId, 'termId');\n  \n  if (typeof forceRefresh !== 'boolean') {\n    forceRefresh = false;\n  }\n  \n  try {\n    // Skip API calls in demo mode - use cached data only\n    if (isDemoMode()) {\n      const cacheKey = `demo_viking_flexi_structure_${flexirecordId}_offline`;\n      const cached = safeGetItem(cacheKey, null);\n      return cached;\n    }\n    \n    const cacheKey = `viking_flexi_structure_${flexirecordId}_offline`;\n    \n    // If no token available, skip API calls and use cached data only\n    if (!hasUsableToken(token)) {\n      const cached = safeGetItem(cacheKey, null);\n      return cached;\n    }\n    \n    // Check network status first\n    const isOnline = await checkNetworkStatus();\n    \n    // Check if we have valid cached data (unless force refresh)\n    if (!forceRefresh && isOnline) {\n      const cacheCheck = isCacheValid(cacheKey, FLEXI_STRUCTURES_CACHE_TTL);\n      if (cacheCheck.valid) {\n        // Using cached flexirecord structure\n        return cacheCheck.data;\n      }\n    }\n    \n    // If offline, get from localStorage regardless of age\n    if (!isOnline) {\n      const cached = safeGetItem(cacheKey, null);\n      if (cached) {\n        // Retrieved structure from localStorage while offline\n        return cached;\n      }\n      return null;\n    }\n\n    // token is guaranteed here due to early return above\n\n    // Get fresh data from API\n    // Fetching flexirecord structure from API\n    const structure = await getFlexiStructure(flexirecordId, sectionId, termId, token);\n    \n    if (!structure) {\n      throw new Error('Failed to retrieve flexirecord structure');\n    }\n    \n    // Cache data with timestamp\n    const cachedData = cacheData(cacheKey, structure);\n    \n    return cachedData;\n    \n  } catch (error) {\n    logger.error('Error fetching flexirecord structure', {\n      flexirecordId,\n      sectionId,\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    // Try cache as fallback\n    try {\n      const cacheKey = `viking_flexi_structure_${flexirecordId}_offline`;\n      const cached = safeGetItem(cacheKey, null);\n      if (cached) {\n        logger.warn('Using cached flexirecord structure after API failure', { flexirecordId });\n        return cached;\n      }\n    } catch (cacheError) {\n      logger.error('Cache fallback failed', { error: cacheError.message });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get flexirecord attendance data - refreshed frequently as it changes often\n * @param {string|number} flexirecordId - FlexiRecord ID\n * @param {string|number} sectionId - Section ID\n * @param {string|number} termId - Term ID\n * @param {string} token - Authentication token\n * @param {boolean} forceRefresh - Force API call ignoring cache (default: true)\n * @returns {Promise<object>} FlexiRecord attendance data\n */\nexport async function getFlexiRecordData(flexirecordId, sectionId, termId, token, forceRefresh = true) {\n  flexirecordId = normalizeId(flexirecordId, 'flexirecordId');\n  sectionId = normalizeId(sectionId, 'sectionId');\n  termId = normalizeId(termId, 'termId');\n  \n  if (typeof forceRefresh !== 'boolean') {\n    forceRefresh = true;\n  }\n  \n  try {\n    // Skip API calls in demo mode - use cached data only\n    if (isDemoMode()) {\n      const storageKey = `demo_viking_flexi_data_${flexirecordId}_${sectionId}_${termId}_offline`;\n      const cached = safeGetItem(storageKey, null);\n      return cached;\n    }\n    \n    const storageKey = `viking_flexi_data_${flexirecordId}_${sectionId}_${termId}_offline`;\n    \n    // If no token available, skip API calls and use cached data only\n    if (!hasUsableToken(token)) {\n      const cached = safeGetItem(storageKey, null);\n      return cached;\n    }\n    \n    // Check network status first\n    const isOnline = await checkNetworkStatus();\n    \n    // Check if we have valid cached data (unless force refresh)\n    if (!forceRefresh && isOnline) {\n      const cacheCheck = isCacheValid(storageKey, FLEXI_DATA_CACHE_TTL);\n      if (cacheCheck.valid) {\n        // Using cached flexirecord data\n        return cacheCheck.data;\n      }\n    }\n    \n    // If offline, get from localStorage regardless of age\n    if (!isOnline) {\n      const cached = safeGetItem(storageKey, null);\n      if (cached) {\n        // Retrieved flexirecord data from localStorage while offline\n        return cached;\n      }\n      return null;\n    }\n\n    // token is guaranteed here due to early return above\n\n    // Get fresh data from API\n    // Fetching flexirecord data from API\n    const data = await getSingleFlexiRecord(flexirecordId, sectionId, termId, token);\n    \n    if (!data) {\n      throw new Error('Failed to retrieve flexirecord data');\n    }\n    \n    // Cache data with timestamp\n    const cachedData = cacheData(storageKey, data);\n    \n    return cachedData;\n    \n  } catch (error) {\n    logger.error('Error fetching flexirecord data', {\n      flexirecordId,\n      sectionId,\n      termId,\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    // Try cache as fallback\n    try {\n      const storageKey = `viking_flexi_data_${flexirecordId}_${sectionId}_${termId}_offline`;\n      const cached = safeGetItem(storageKey, null);\n      if (cached) {\n        logger.warn('Using cached flexirecord data after API failure', { flexirecordId });\n        return cached;\n      }\n    } catch (cacheError) {\n      logger.error('Cache fallback failed', { error: cacheError.message });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Gets consolidated FlexiRecord data with meaningful field names and structure\n * \n * Main function that combines FlexiRecord structure and data retrieval with\n * intelligent caching and field mapping. Transforms raw FlexiRecord data into\n * a usable format with human-readable field names and proper data types.\n * This is the primary function for working with FlexiRecord data.\n * \n * @async\n * @param {string|number} sectionId - Section identifier\n * @param {string|number} flexirecordId - FlexiRecord identifier (extraid)\n * @param {string|number} termId - Term identifier\n * @param {string} token - OSM authentication token (null for offline mode)\n * @param {boolean} [forceRefresh=false] - Force refresh of data cache\n * @returns {Promise<object>} Consolidated FlexiRecord with structure and data\n * @returns {object} returns.items - Array of data records with meaningful field names\n * @returns {object} returns._structure - FlexiRecord metadata and field mapping\n * @returns {string} returns._structure.name - FlexiRecord name\n * @returns {string} returns._structure.extraid - FlexiRecord external ID\n * @returns {boolean} returns._structure.archived - Whether FlexiRecord is archived\n * @returns {object} returns._structure.fieldMapping - Field ID to name/type mapping\n * @throws {Error} If required parameters missing or API calls fail\n * \n * @example\n * // Get consolidated Viking Event Management data\n * const eventData = await getConsolidatedFlexiRecord(\n *   sectionId, \n *   'viking_event_flexi_123', \n *   termId, \n *   authToken\n * );\n * \n * // Access data with meaningful field names\n * eventData.items.forEach(record => {\n *   console.log(`Scout: ${record.scoutName}`);\n *   console.log(`Attendance: ${record.eventAttendance}`);\n *   console.log(`Notes: ${record.attendanceNotes}`);\n * });\n * \n * // Use field mapping for dynamic field access\n * const fieldMapping = eventData._structure.fieldMapping;\n * Object.values(fieldMapping).forEach(field => {\n *   console.log(`Field: ${field.name} - Type: ${field.type}`);\n * });\n * \n * @example\n * // Handle offline mode gracefully\n * try {\n *   const data = await getConsolidatedFlexiRecord(sectionId, flexiId, termId, null);\n *   // Use cached data\n * } catch (error) {\n *   console.log('No cached data available - need internet connection');\n * }\n */\nexport async function getConsolidatedFlexiRecord(sectionId, flexirecordId, termId, token, forceRefresh = false) {\n  try {\n    if (!sectionId || !flexirecordId || !termId) {\n      throw new Error('Missing required parameters: sectionId, flexirecordId, and termId are required');\n    }\n\n    // Getting consolidated flexirecord data\n\n    // Get structure and data using service layer caching\n    const [structureData, flexiData] = await Promise.all([\n      getFlexiRecordStructure(flexirecordId, sectionId, termId, token, false), // Structure cached longer\n      getFlexiRecordData(flexirecordId, sectionId, termId, token, forceRefresh), // Data refreshed more often\n    ]);\n\n    if (!structureData) {\n      throw new Error('Failed to retrieve flexirecord structure');\n    }\n\n    if (!flexiData) {\n      throw new Error('Failed to retrieve flexirecord data');\n    }\n\n    // Parse structure to get field mapping (moved to transforms)\n    const { parseFlexiStructure, transformFlexiRecordData } = await import('../../../shared/utils/flexiRecordTransforms.js');\n    const fieldMapping = parseFlexiStructure(structureData);\n\n    // Transform data using field mapping\n    const consolidatedData = transformFlexiRecordData(flexiData, fieldMapping);\n\n    // Convert fieldMapping Map to object for easier access\n    // Use fieldId as key to ensure uniqueness and prevent overwrites\n    const fieldMappingObj = {};\n    fieldMapping.forEach((fieldInfo, fieldId) => {\n      fieldMappingObj[fieldId] = {\n        columnId: fieldId,\n        ...fieldInfo,\n      };\n    });\n\n    // Add structure metadata to result\n    consolidatedData._structure = {\n      name: structureData.name,\n      extraid: structureData.extraid,\n      flexirecordid: structureData.extraid, // Alias for backward compatibility\n      sectionid: structureData.sectionid,\n      archived: structureData.archived === '1',\n      softDeleted: structureData.soft_deleted === '1',\n      fieldMapping: fieldMappingObj, // Add the field mapping for drag-and-drop context\n    };\n\n    // Successfully consolidated flexirecord data\n\n    return consolidatedData;\n  } catch (error) {\n    logger.error('Error getting consolidated flexirecord data', {\n      sectionId,\n      flexirecordId,\n      termId,\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'get_consolidated_flexi_record',\n      },\n      contexts: {\n        request: {\n          sectionId,\n          flexirecordId,\n          termId,\n          hasToken: !!token,\n        },\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Gets Viking Event Management FlexiRecord data for a Scout section\n * \n * Specialized function that looks for the \"Viking Event Mgmt\" FlexiRecord\n * within a section and returns consolidated data with meaningful field names.\n * This is the primary function for accessing Scout event attendance data\n * in the Vikings Event Management system.\n * \n * @async\n * @param {string|number} sectionId - Section identifier\n * @param {string|number} termId - Term identifier\n * @param {string} token - OSM authentication token (null for offline mode)\n * @param {boolean} [forceRefresh=false] - Force refresh of data cache\n * @returns {Promise<object | null>} Viking Event Mgmt FlexiRecord data or null if not found\n * @returns {Array} returns.items - Event attendance records with scout details\n * @returns {object} returns._structure - FlexiRecord structure and field mapping\n * @returns {string} returns._structure.name - Always \"Viking Event Mgmt\"\n * @returns {object} returns._structure.fieldMapping - Field mappings for attendance data\n * \n * @example\n * // Get Viking Event data for Beavers section\n * const eventData = await getVikingEventData(1, 'term_2024_spring', authToken);\n * \n * if (eventData) {\n *   console.log(`Found ${eventData.items.length} attendance records`);\n *   \n *   // Process attendance data\n *   eventData.items.forEach(record => {\n *     console.log(`${record.scoutName}: ${record.eventAttendance}`);\n *     if (record.attendanceNotes) {\n *       console.log(`  Notes: ${record.attendanceNotes}`);\n *     }\n *   });\n * } else {\n *   console.log('No Viking Event Management FlexiRecord found for this section');\n * }\n * \n * @example\n * // Use for event dashboard display\n * const sections = await getSections();\n * \n * for (const section of sections) {\n *   const eventData = await getVikingEventData(section.sectionid, termId, token);\n *   if (eventData) {\n *     const attendingCount = eventData.items.filter(\n *       record => record.eventAttendance === 'Yes'\n *     ).length;\n *     console.log(`${section.sectionname}: ${attendingCount} attending`);\n *   }\n * }\n */\nexport async function getVikingEventData(sectionId, termId, token, forceRefresh = false) {\n  sectionId = normalizeId(sectionId, 'sectionId');\n  termId = normalizeId(termId, 'termId');\n  \n  if (typeof forceRefresh !== 'boolean') {\n    forceRefresh = false;\n  }\n  \n  try {\n\n    // Getting Viking Event data for section\n    \n    // Get flexirecords list\n    const flexiRecordsList = await getFlexiRecordsList(sectionId, token, forceRefresh);\n\n    // Find the Viking Event Mgmt flexirecord ID from the list\n    const vikingEventFlexiRecord = flexiRecordsList.items?.find(record => \n      record.name === 'Viking Event Mgmt',\n    );\n\n    if (!vikingEventFlexiRecord) {\n      logger.warn('No \"Viking Event Mgmt\" flexirecord found for section', {\n        sectionId,\n        availableRecords: flexiRecordsList.items?.map(r => r.name || 'Unknown') || [],\n      }, LOG_CATEGORIES.APP);\n      \n      return null;\n    }\n\n    // Found \"Viking Event Mgmt\" flexirecord in list\n\n    // Get the consolidated data (structure + data) for the \"Viking Event Mgmt\" flexirecord\n    const vikingEventRecord = await getConsolidatedFlexiRecord(\n      sectionId, \n      vikingEventFlexiRecord.extraid, \n      termId, \n      token,\n      forceRefresh, // Pass through forceRefresh parameter\n    );\n\n    // Found \"Viking Event Mgmt\" flexirecord\n\n    return vikingEventRecord;\n  } catch (error) {\n    logger.error('Error getting Viking Event data for section', {\n      sectionId,\n      termId,\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'get_viking_event_data',\n      },\n      contexts: {\n        request: {\n          sectionId,\n          termId,\n          hasToken: !!token,\n        },\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Get Viking Section Movers flexirecord for a section\n * Looks for flexirecord with name=\"Viking Section Movers\"\n * \n * @param {string|number} sectionId - Section ID\n * @param {string|number} termId - Term ID\n * @param {string} token - Authentication token (null for offline)\n * @param {boolean} forceRefresh - Force refresh of data cache (default: false)\n * @returns {Promise<object | null>} Viking Section Movers flexirecord data or null if not found\n */\nexport async function getVikingSectionMoversData(sectionId, termId, token, forceRefresh = false) {\n  sectionId = normalizeId(sectionId, 'sectionId');\n  termId = normalizeId(termId, 'termId');\n  \n  if (typeof forceRefresh !== 'boolean') {\n    forceRefresh = false;\n  }\n  \n  try {\n\n    // Getting Viking Section Movers data for section\n\n    // Get flexirecords list\n    const flexiRecordsList = await getFlexiRecordsList(sectionId, token, forceRefresh);\n\n    // Find the Viking Section Movers flexirecord ID from the list\n    const vikingSectionMoversFlexiRecord = flexiRecordsList.items?.find(record => \n      record.name === 'Viking Section Movers',\n    );\n\n    if (!vikingSectionMoversFlexiRecord) {\n      logger.warn('No \"Viking Section Movers\" flexirecord found for section', {\n        sectionId,\n        availableRecords: flexiRecordsList.items?.map(r => r.name || 'Unknown') || [],\n      }, LOG_CATEGORIES.APP);\n      \n      return null;\n    }\n\n    // Found \"Viking Section Movers\" flexirecord in list\n\n    // Get the consolidated data (structure + data) for the \"Viking Section Movers\" flexirecord\n    const vikingSectionMoversRecord = await getConsolidatedFlexiRecord(\n      sectionId, \n      vikingSectionMoversFlexiRecord.extraid, \n      termId, \n      token,\n      forceRefresh, // Pass through forceRefresh parameter\n    );\n\n    // Found \"Viking Section Movers\" flexirecord\n\n    return vikingSectionMoversRecord;\n  } catch (error) {\n    logger.error('Error getting Viking Section Movers data for section', {\n      sectionId,\n      termId,\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'get_viking_section_movers_data',\n      },\n      contexts: {\n        request: {\n          sectionId,\n          termId,\n          hasToken: !!token,\n        },\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Extract field mapping for Viking Section Movers FlexiRecord\n * Maps required fields (Member ID, Date of Birth, Current Section, Target Section, Assignment Term)\n * following the extractFlexiRecordContext pattern\n * \n * @param {object} vikingSectionMoversData - Viking Section Movers FlexiRecord data  \n * @param {string} sectionId - Section ID\n * @param {string} termId - Term ID\n * @param {string} sectionName - Section name\n * @returns {object | null} Field mapping context or null if not available\n */\nexport function extractVikingSectionMoversContext(vikingSectionMoversData, sectionId, termId, sectionName) {\n  // Try both _structure and structure properties for compatibility\n  const structure = vikingSectionMoversData?._structure || vikingSectionMoversData?.structure;\n  \n  if (!vikingSectionMoversData || !structure) {\n    logger.warn('No Viking Section Movers data or structure available', {\n      hasData: !!vikingSectionMoversData,\n      hasStructure: !!structure,\n      hasUnderscoreStructure: !!(vikingSectionMoversData?._structure),\n      hasRegularStructure: !!(vikingSectionMoversData?.structure),\n      sectionId,\n    }, LOG_CATEGORIES.APP);\n    return null;\n  }\n\n  const fieldMapping = structure.fieldMapping || {};\n  \n  // Find required fields from the structure\n  const memberIdField = Object.values(fieldMapping).find(field => field.name === 'Member ID');\n  const dateOfBirthField = Object.values(fieldMapping).find(field => field.name === 'Date of Birth');\n  const currentSectionField = Object.values(fieldMapping).find(field => field.name === 'Current Section');\n  const targetSectionField = Object.values(fieldMapping).find(field => field.name === 'Target Section');\n  const assignmentTermField = Object.values(fieldMapping).find(field => field.name === 'Assignment Term');\n  \n  // New assignment tracking fields\n  const assignedSectionField = Object.values(fieldMapping).find(field => field.name === 'AssignedSection');\n  const assignedTermField = Object.values(fieldMapping).find(field => field.name === 'AssignedTerm');\n  const assignmentOverrideField = Object.values(fieldMapping).find(field => field.name === 'AssignmentOverride');\n  const assignmentDateField = Object.values(fieldMapping).find(field => field.name === 'AssignmentDate');\n  const assignedByField = Object.values(fieldMapping).find(field => field.name === 'AssignedBy');\n\n  // Check for missing critical fields - using actual field names\n  // Note: Viking Section Movers FlexiRecord doesn't have Member ID - it only tracks assignments\n  const missingFields = [];\n  if (!assignedSectionField) missingFields.push('AssignedSection');\n  \n  if (missingFields.length > 0) {\n    logger.warn('Missing critical fields in Viking Section Movers FlexiRecord structure', {\n      missingFields,\n      availableFields: Object.values(fieldMapping).map(f => f.name),\n      sectionId,\n      sectionName,\n    }, LOG_CATEGORIES.APP);\n    return null;\n  }\n\n\n  return {\n    flexirecordid: structure.extraid || structure.flexirecordid,\n    sectionid: sectionId,\n    termid: termId,\n    section: sectionName,\n    // Return the actual field IDs for use in API calls\n    assignedSection: assignedSectionField?.fieldId || assignedSectionField?.columnId,\n    assignedTerm: assignedTermField?.fieldId || assignedTermField?.columnId,\n    fields: {\n      memberId: memberIdField,\n      dateOfBirth: dateOfBirthField,\n      currentSection: currentSectionField,\n      targetSection: targetSectionField,\n      assignmentTerm: assignmentTermField,\n      // New assignment tracking fields\n      assignedSection: assignedSectionField,\n      assignedTerm: assignedTermField,\n      assignmentOverride: assignmentOverrideField,\n      assignmentDate: assignmentDateField,\n      assignedBy: assignedByField,\n    },\n    fieldMapping: fieldMapping,\n  };\n}\n\n/**\n * Validate Viking Section Movers FlexiRecord structure\n * Checks if required fields exist for section movement assignments\n * \n * @param {object} consolidatedData - Consolidated flexirecord data from getVikingSectionMoversData\n * @returns {object} Validation result with status and missing fields\n */\nexport function validateVikingSectionMoversFields(consolidatedData) {\n  const requiredFields = [\n    'Member ID',\n    'Target Section',\n  ];\n  \n  const optionalFields = [\n    'Date of Birth',\n    'Current Section', \n    'Assignment Term',\n    // New assignment tracking fields (optional for backward compatibility)\n    'AssignedSection',\n    'AssignedTerm',\n    'AssignmentOverride',\n    'AssignmentDate',\n    'AssignedBy',\n  ];\n  \n  if (!consolidatedData || !consolidatedData._structure) {\n    return {\n      isValid: false,\n      missingFields: requiredFields,\n      missingOptionalFields: optionalFields,\n      error: 'FlexiRecord structure not found',\n    };\n  }\n  \n  const fieldMapping = consolidatedData._structure.fieldMapping || {};\n  const availableFields = Object.values(fieldMapping).map(field => field.name);\n  \n  const missingRequired = requiredFields.filter(field => !availableFields.includes(field));\n  const missingOptional = optionalFields.filter(field => !availableFields.includes(field));\n  \n  return {\n    isValid: missingRequired.length === 0,\n    missingFields: missingRequired,\n    missingOptionalFields: missingOptional,\n    availableFields,\n    fieldMapping: fieldMapping,\n    hasOptionalFields: missingOptional.length === 0,\n  };\n}\n\n/**\n * Create assignment tracking data for Viking Section Movers FlexiRecord\n * This function creates the data structure needed to track member assignments\n * \n * @param {string} memberId - Member ID\n * @param {string} assignedSectionId - Section ID where member will be assigned\n * @param {string} assignedSectionName - Section name where member will be assigned\n * @param {string} assignedTerm - Term when the assignment is effective\n * @param {string} assignedBy - User who made the assignment\n * @param {boolean} isOverride - Whether this assignment overrides age-based logic\n * @param {object} fieldContext - Field context from extractVikingSectionMoversContext\n * @returns {object} FlexiRecord data structure for assignment tracking\n */\nexport function createAssignmentTrackingData(\n  memberId,\n  assignedSectionId,\n  assignedSectionName,\n  assignedTerm,\n  assignedBy,\n  isOverride = false,\n  fieldContext,\n) {\n  if (!fieldContext || !fieldContext.fields) {\n    throw new Error('Field context is required for assignment tracking');\n  }\n\n  const assignmentDate = new Date().toISOString();\n  const assignmentData = {};\n\n  // Map the assignment data to the appropriate field IDs\n  const { fields } = fieldContext;\n\n  if (fields.memberId) {\n    assignmentData[fields.memberId.id] = memberId;\n  }\n\n  if (fields.assignedSection) {\n    assignmentData[fields.assignedSection.id] = assignedSectionName;\n  }\n\n  if (fields.assignedTerm) {\n    assignmentData[fields.assignedTerm.id] = assignedTerm;\n  }\n\n  if (fields.assignmentOverride) {\n    assignmentData[fields.assignmentOverride.id] = isOverride ? 'Yes' : 'No';\n  }\n\n  if (fields.assignmentDate) {\n    assignmentData[fields.assignmentDate.id] = assignmentDate;\n  }\n\n  if (fields.assignedBy) {\n    assignmentData[fields.assignedBy.id] = assignedBy;\n  }\n\n  return {\n    flexirecordid: fieldContext.flexirecordid,\n    sectionid: fieldContext.sectionid,\n    termid: fieldContext.termid,\n    data: assignmentData,\n    metadata: {\n      memberId,\n      assignedSectionId,\n      assignedSectionName,\n      assignedTerm,\n      assignedBy,\n      isOverride,\n      assignmentDate,\n    },\n  };\n}\n\n/**\n * Validate assignment tracking data structure\n * Ensures all required fields for assignment tracking are present\n * \n * @param {object} assignmentData - Assignment data to validate\n * @param {object} fieldContext - Field context for validation\n * @returns {object} Validation result\n */\nexport function validateAssignmentTrackingData(assignmentData, fieldContext) {\n  const validationResult = {\n    isValid: true,\n    missingFields: [],\n    warnings: [],\n  };\n\n  if (!assignmentData || !fieldContext) {\n    validationResult.isValid = false;\n    validationResult.missingFields.push('assignmentData or fieldContext');\n    return validationResult;\n  }\n\n  const { fields } = fieldContext;\n  const { metadata } = assignmentData;\n\n  // Check required metadata\n  const requiredMetadata = ['memberId', 'assignedSectionName', 'assignedTerm', 'assignedBy'];\n  requiredMetadata.forEach(field => {\n    if (!metadata || !metadata[field]) {\n      validationResult.missingFields.push(`metadata.${field}`);\n    }\n  });\n\n  // Check for assignment tracking field availability\n  if (!fields.assignedSection) {\n    validationResult.warnings.push('AssignedSection field not found in FlexiRecord structure');\n  }\n\n  if (!fields.assignedTerm) {\n    validationResult.warnings.push('AssignedTerm field not found in FlexiRecord structure');\n  }\n\n  if (!fields.assignmentDate) {\n    validationResult.warnings.push('AssignmentDate field not found in FlexiRecord structure');\n  }\n\n  if (!fields.assignedBy) {\n    validationResult.warnings.push('AssignedBy field not found in FlexiRecord structure');\n  }\n\n  validationResult.isValid = validationResult.missingFields.length === 0;\n\n  return validationResult;\n}\n\n/**\n * Validate a collection of Viking Section Movers FlexiRecords\n * Filters out invalid records and returns validation summary\n * \n * @param {Array} discoveredFlexiRecords - Array of discovered FlexiRecord metadata\n * @param {Map} fieldMappings - Map of sectionId to field mapping context\n * @returns {object} Validation summary with valid/invalid records\n */\nexport function validateVikingSectionMoversCollection(discoveredFlexiRecords, fieldMappings) {\n  const validRecords = [];\n  const invalidRecords = [];\n  const validationResults = new Map();\n\n  discoveredFlexiRecords.forEach(record => {\n    const fieldMapping = fieldMappings.get(record.sectionId);\n    \n    if (!fieldMapping) {\n      invalidRecords.push({\n        ...record,\n        validationError: 'No field mapping available',\n      });\n      validationResults.set(record.sectionId, {\n        isValid: false,\n        error: 'No field mapping available',\n      });\n      return;\n    }\n\n    // Check if required fields exist\n    const hasRequiredFields = fieldMapping.fields.memberId && fieldMapping.fields.targetSection;\n    \n    if (hasRequiredFields) {\n      validRecords.push(record);\n      validationResults.set(record.sectionId, {\n        isValid: true,\n        hasOptionalFields: !!(fieldMapping.fields.dateOfBirth && \n                            fieldMapping.fields.currentSection && \n                            fieldMapping.fields.assignmentTerm),\n        availableFields: Object.keys(fieldMapping.fields).filter(key => \n          fieldMapping.fields[key] !== null && fieldMapping.fields[key] !== undefined,\n        ),\n      });\n    } else {\n      const missingFields = [];\n      if (!fieldMapping.fields.memberId) missingFields.push('Member ID');\n      if (!fieldMapping.fields.targetSection) missingFields.push('Target Section');\n      \n      invalidRecords.push({\n        ...record,\n        validationError: `Missing required fields: ${missingFields.join(', ')}`,\n      });\n      validationResults.set(record.sectionId, {\n        isValid: false,\n        error: `Missing required fields: ${missingFields.join(', ')}`,\n        missingFields,\n      });\n    }\n  });\n\n  return {\n    isValid: validRecords.length > 0,\n    validRecords,\n    invalidRecords,\n    validationResults,\n    summary: {\n      total: discoveredFlexiRecords.length,\n      valid: validRecords.length,\n      invalid: invalidRecords.length,\n    },\n  };\n}\n\n/**\n * Discover all accessible FlexiRecords matching \"Viking Section Movers\" pattern\n * Scans through all accessible sections to find Viking Section Movers FlexiRecords\n * \n * @param {string} token - Authentication token (null for offline)\n * @param {boolean} forceRefresh - Force refresh of cache (default: false)\n * @returns {Promise<Array>} Array of discovered FlexiRecords with section metadata\n */\nexport async function discoverVikingSectionMoversFlexiRecords(token, forceRefresh = false) {\n  try {\n    const { default: databaseService } = await import('../../../shared/services/storage/database.js');\n    \n    // Get all accessible sections\n    const sectionsData = await databaseService.getSections();\n    \n    if (!sectionsData || sectionsData.length === 0) {\n      logger.warn('No sections available for Viking Section Movers discovery', {}, LOG_CATEGORIES.APP);\n      return [];\n    }\n\n    // Discover Viking Section Movers FlexiRecords across all sections\n    const discoveryPromises = sectionsData.map(async (section) => {\n      try {\n        const sectionId = section.sectionid.toString();\n        const sectionName = section.sectionname || section.name || 'Unknown Section';\n        \n        // Get FlexiRecords list for this section\n        const flexiRecordsList = await getFlexiRecordsList(sectionId, token, forceRefresh);\n        \n        // Find Viking Section Movers FlexiRecord\n        const vikingSectionMoversFlexiRecord = flexiRecordsList.items?.find(record => \n          record.name === 'Viking Section Movers',\n        );\n        \n        if (vikingSectionMoversFlexiRecord) {\n          return {\n            sectionId,\n            sectionName,\n            flexiRecordId: vikingSectionMoversFlexiRecord.extraid,\n            flexiRecordName: vikingSectionMoversFlexiRecord.name,\n            section: section, // Full section object for additional metadata\n          };\n        }\n        \n        return null; // No Viking Section Movers FlexiRecord found for this section\n        \n      } catch (error) {\n        logger.warn('Failed to check Viking Section Movers FlexiRecord for section', {\n          sectionId: section.sectionid,\n          sectionName: section.sectionname,\n          error: error.message,\n          stack: error.stack,\n          hasToken: !!token,\n        }, LOG_CATEGORIES.APP);\n        \n        return null;\n      }\n    });\n    \n    const discoveryResults = await Promise.all(discoveryPromises);\n    const discoveredFlexiRecords = discoveryResults.filter(result => result !== null);\n    \n    logger.info('Viking Section Movers FlexiRecord discovery completed', {\n      totalSections: sectionsData.length,\n      discoveredCount: discoveredFlexiRecords.length,\n      discoveredSections: discoveredFlexiRecords.map(d => d.sectionName),\n    }, LOG_CATEGORIES.APP);\n    \n    return discoveredFlexiRecords;\n    \n  } catch (error) {\n    logger.error('Error discovering Viking Section Movers FlexiRecords', {\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'discover_viking_section_movers_flexi_records',\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Get Viking Event Management data for all sections involved in events\n * Each event contains its own termId, so we use section-term combinations from the events\n * \n * @param {Array} events - Array of events (each must have sectionid and termid)\n * @param {string} token - Authentication token (null for offline)\n * @param {boolean} forceRefresh - Force refresh of data cache (default: true for dynamic data)\n * @returns {Promise<Map>} Map of sectionId to Viking Event data\n */\nexport async function getVikingEventDataForEvents(events, token, forceRefresh = true) {\n  try {\n    \n    if (!events || !Array.isArray(events)) {\n      throw new Error('Invalid events: must be an array');\n    }\n\n    // Get unique section-term combinations from events\n    const sectionTermCombos = [...new Set(\n      events.map(e => JSON.stringify([String(e.sectionid), String(e.termid)])),\n    )].map(key => {\n      const [sectionId, termId] = JSON.parse(key);\n      return { sectionId, termId };\n    });\n\n\n    // Getting Viking Event data for section-term combinations\n\n    const vikingEventPromises = sectionTermCombos.map(async ({ sectionId, termId }) => {\n      try {\n        if (!termId || termId === 'undefined' || termId === 'null' || termId === '') {\n          throw new Error(`Event missing termId for section ${sectionId} - this should not happen`);\n        }\n\n        const vikingEventData = await getVikingEventData(sectionId, termId, token, forceRefresh);\n        return { sectionId, vikingEventData };\n      } catch (error) {\n        logger.warn('Failed to load Viking Event data for section', {\n          sectionId,\n          termId,\n          error: error.message,\n        }, LOG_CATEGORIES.APP);\n        \n        return { sectionId, vikingEventData: null };\n      }\n    });\n\n    const results = await Promise.all(vikingEventPromises);\n    const vikingEventDataBySections = new Map(\n      results.map(({ sectionId, vikingEventData }) => [String(sectionId), vikingEventData]),\n    );\n\n    // const successCount = results.filter(r => r.vikingEventData !== null).length;\n\n    // Completed loading Viking Event data for sections\n\n    return vikingEventDataBySections;\n  } catch (error) {\n    logger.error('Error getting Viking Event data for events', {\n      error: error.message,\n      hasEvents: !!events,\n      eventsCount: events?.length || 0,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'get_viking_event_data_for_events',\n      },\n      contexts: {\n        request: {\n          eventsCount: events?.length || 0,\n          hasToken: !!token,\n        },\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Clear all flexirecord caches (useful for debugging or when data needs refresh)\n */\nexport function clearFlexiRecordCaches() {\n  // Clearing all flexirecord caches\n  \n  // Clear localStorage caches\n  const keys = Object.keys(localStorage);\n  const flexiKeys = keys.filter(key => \n    key.includes('viking_flexi_') && key.includes('_offline'),\n  );\n  \n  flexiKeys.forEach(key => {\n    localStorage.removeItem(key);\n  });\n  \n  // Cleared flexirecord caches\n  \n  return {\n    clearedLocalStorageKeys: flexiKeys.length,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/events/services/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/AssignmentInterface.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":7,"column":1,"nodeType":"Block","endLine":16,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":7,"column":1,"nodeType":"Block","endLine":16,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.term\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.movers\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.availableSections\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onAssignmentChange\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSaveAssignments\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onResetAssignments\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":143,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":149,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":31}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport DraggableMover from './DraggableMover.jsx';\nimport SectionDropZone from './SectionDropZone.jsx';\nimport { safeGetItem, safeSetItem } from '../../../shared/utils/storageUtils.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n *\n * @param root0\n * @param root0.term\n * @param root0.movers\n * @param root0.availableSections\n * @param root0.onAssignmentChange\n * @param root0.onSaveAssignments\n * @param root0.onResetAssignments\n */\nfunction AssignmentInterface({\n  term,\n  movers,\n  availableSections,\n  onAssignmentChange,\n  onSaveAssignments,\n  onResetAssignments,\n}) {\n  const [assignments, setAssignments] = useState(new Map());\n  const [isDragInProgress, setIsDragInProgress] = useState(false);\n  const [draggingMoverId, setDraggingMoverId] = useState(null);\n  const [draftSaved, setDraftSaved] = useState(false);\n  const [lastSaveTime, setLastSaveTime] = useState(null);\n\n  const draftKey = useMemo(() => {\n    return `viking_assignment_draft_${term.type}_${term.year}`;\n  }, [term.type, term.year]);\n\n  const unassignedMovers = useMemo(() => {\n    return movers.filter(mover => !assignments.has(mover.memberId));\n  }, [movers, assignments]);\n\n  const getIncomingCountForSection = useCallback((sectionId) => {\n    return Array.from(assignments.values()).filter(\n      assignment => assignment.sectionId === sectionId,\n    ).length;\n  }, [assignments]);\n\n  const saveDraftToStorage = useCallback(async () => {\n    try {\n      const draftData = {\n        assignments: Array.from(assignments.entries()),\n        lastSaved: new Date().toISOString(),\n        term: {\n          type: term.type,\n          year: term.year,\n        },\n      };\n\n      const success = safeSetItem(draftKey, draftData);\n      \n      if (success) {\n        setDraftSaved(true);\n        setLastSaveTime(draftData.lastSaved);\n        \n        logger.info('Assignment draft saved to localStorage', {\n          draftKey,\n          assignmentCount: assignments.size,\n          termType: term.type,\n          termYear: term.year,\n        }, LOG_CATEGORIES.APP);\n      } else {\n        logger.warn('Failed to save assignment draft to localStorage', {\n          draftKey,\n          assignmentCount: assignments.size,\n        }, LOG_CATEGORIES.ERROR);\n      }\n      \n      return success;\n    } catch (error) {\n      logger.error('Error saving assignment draft', {\n        error: error.message,\n        draftKey,\n        assignmentCount: assignments.size,\n      }, LOG_CATEGORIES.ERROR);\n      return false;\n    }\n  }, [assignments, draftKey, term]);\n\n  const loadDraftFromStorage = useCallback(() => {\n    try {\n      const draftData = safeGetItem(draftKey, null);\n      \n      if (draftData && draftData.assignments) {\n        if (draftData.term?.type === term.type && draftData.term?.year === term.year) {\n          const loadedAssignments = new Map(draftData.assignments);\n          setAssignments(loadedAssignments);\n          setDraftSaved(true);\n          setLastSaveTime(draftData.lastSaved);\n          \n          logger.info('Assignment draft loaded from localStorage', {\n            draftKey,\n            assignmentCount: loadedAssignments.size,\n            lastSaved: draftData.lastSaved,\n          }, LOG_CATEGORIES.APP);\n          \n          return loadedAssignments.size;\n        } else {\n          logger.info('Draft term mismatch, not loading', {\n            draftTerm: draftData.term,\n            currentTerm: { type: term.type, year: term.year },\n          }, LOG_CATEGORIES.APP);\n        }\n      }\n      return 0;\n    } catch (error) {\n      logger.error('Error loading assignment draft', {\n        error: error.message,\n        draftKey,\n      }, LOG_CATEGORIES.ERROR);\n      return 0;\n    }\n  }, [draftKey, term]);\n\n  const clearDraftFromStorage = useCallback(() => {\n    try {\n      localStorage.removeItem(draftKey);\n      setDraftSaved(false);\n      setLastSaveTime(null);\n      \n      logger.info('Assignment draft cleared from localStorage', {\n        draftKey,\n      }, LOG_CATEGORIES.APP);\n    } catch (error) {\n      logger.error('Error clearing assignment draft', {\n        error: error.message,\n        draftKey,\n      }, LOG_CATEGORIES.ERROR);\n    }\n  }, [draftKey]);\n\n  useEffect(() => {\n    loadDraftFromStorage();\n  }, [loadDraftFromStorage]);\n\n  useEffect(() => {\n    const autoSaveInterval = setInterval(() => {\n      if (assignments.size > 0) {\n        saveDraftToStorage();\n      }\n    }, 30000);\n\n    return () => clearInterval(autoSaveInterval);\n  }, [assignments.size, saveDraftToStorage]);\n\n  useEffect(() => {\n    if (assignments.size > 0) {\n      setDraftSaved(false);\n    }\n  }, [assignments.size]);\n\n  const handleDragStart = useCallback((dragData) => {\n    setIsDragInProgress(true);\n    setDraggingMoverId(dragData.moverId);\n  }, []);\n\n  const handleDragEnd = useCallback(() => {\n    setIsDragInProgress(false);\n    setDraggingMoverId(null);\n  }, []);\n\n  const handleMoverDrop = useCallback(async (dragData, targetSection) => {\n    try {\n      const newAssignment = {\n        moverId: dragData.moverId,\n        moverName: dragData.moverName,\n        currentSectionId: dragData.currentSectionId,\n        sectionId: targetSection.sectionId,\n        sectionName: targetSection.sectionName,\n        term: term.type,\n        termYear: term.year,\n        assignedAt: new Date().toISOString(),\n      };\n\n      setAssignments(prev => {\n        const updated = new Map(prev);\n        updated.set(dragData.moverId, newAssignment);\n        return updated;\n      });\n\n      if (onAssignmentChange) {\n        onAssignmentChange(newAssignment, 'add');\n      }\n    } catch (error) {\n      console.error('Error handling mover drop:', error);\n    }\n  }, [term, onAssignmentChange]);\n\n  const handleRemoveAssignment = useCallback((moverId) => {\n    const assignment = assignments.get(moverId);\n    if (assignment) {\n      setAssignments(prev => {\n        const updated = new Map(prev);\n        updated.delete(moverId);\n        return updated;\n      });\n\n      if (onAssignmentChange) {\n        onAssignmentChange(assignment, 'remove');\n      }\n    }\n  }, [assignments, onAssignmentChange]);\n\n  const handleSave = async () => {\n    if (onSaveAssignments) {\n      onSaveAssignments(Array.from(assignments.values()));\n      clearDraftFromStorage();\n    }\n  };\n\n  const handleReset = () => {\n    setAssignments(new Map());\n    clearDraftFromStorage();\n    if (onResetAssignments) {\n      onResetAssignments();\n    }\n  };\n\n  const handleSaveDraft = async () => {\n    await saveDraftToStorage();\n  };\n\n  const assignedMovers = useMemo(() => {\n    return movers.filter(mover => assignments.has(mover.memberId))\n      .map(mover => ({\n        ...mover,\n        assignment: assignments.get(mover.memberId),\n      }));\n  }, [movers, assignments]);\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h3 className=\"text-lg font-semibold text-gray-900\">\n          Assign Movers for {term.type} {term.year}\n        </h3>\n        <div className=\"flex flex-col sm:flex-row gap-2\">\n          <div className=\"flex space-x-2\">\n            <button\n              className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm bg-white border-2 border-gray-300 text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 active:bg-gray-100 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={handleReset}\n              disabled={assignments.size === 0}\n            >\n              Reset\n            </button>\n            <button\n              className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm bg-white border-2 border-gray-300 text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 active:bg-gray-100 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={handleSaveDraft}\n              disabled={assignments.size === 0}\n            >\n              Save Draft\n            </button>\n            <button\n              className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm bg-scout-blue text-white hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light active:bg-scout-blue-dark transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={handleSave}\n              disabled={assignments.size === 0}\n            >\n              Save ({assignments.size})\n            </button>\n          </div>\n          {(draftSaved || lastSaveTime) && (\n            <div className=\"flex items-center text-xs text-green-600\">\n              <div className=\"w-2 h-2 bg-green-500 rounded-full mr-2\"></div>\n              {draftSaved ? 'Draft saved' : `Last saved: ${new Date(lastSaveTime).toLocaleTimeString()}`}\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n        <div className=\"space-y-4\">\n          <div className=\"bg-amber-50 p-4 rounded-lg border border-amber-200\">\n            <h4 className=\"font-medium text-amber-900 mb-3\">\n              Unassigned Movers ({unassignedMovers.length})\n            </h4>\n            <div className=\"space-y-2 max-h-96 overflow-y-auto\">\n              {unassignedMovers.map(mover => (\n                <DraggableMover\n                  key={mover.memberId}\n                  mover={mover}\n                  onDragStart={handleDragStart}\n                  onDragEnd={handleDragEnd}\n                  isDragging={draggingMoverId === mover.memberId}\n                />\n              ))}\n              {unassignedMovers.length === 0 && (\n                <div className=\"text-center py-4 text-amber-700\">\n                  All movers have been assigned\n                </div>\n              )}\n            </div>\n          </div>\n\n          {assignedMovers.length > 0 && (\n            <div className=\"bg-green-50 p-4 rounded-lg border border-green-200\">\n              <h4 className=\"font-medium text-green-900 mb-3\">\n                Assigned Movers ({assignedMovers.length})\n              </h4>\n              <div className=\"space-y-2 max-h-64 overflow-y-auto\">\n                {assignedMovers.map(mover => (\n                  <div \n                    key={mover.memberId}\n                    className=\"flex items-center justify-between p-2 bg-white rounded border border-green-300\"\n                  >\n                    <div className=\"min-w-0 flex-1\">\n                      <div className=\"font-medium text-sm text-gray-900 truncate\">\n                        {mover.name}\n                      </div>\n                      <div className=\"text-xs text-gray-500\">\n                        {mover.currentSection} → {mover.assignment.sectionName}\n                      </div>\n                    </div>\n                    <button\n                      onClick={() => handleRemoveAssignment(mover.memberId)}\n                      className=\"text-red-600 hover:text-red-800 text-xs ml-2\"\n                      title=\"Remove assignment\"\n                    >\n                      ✕\n                    </button>\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n\n        <div className=\"space-y-4\">\n          <h4 className=\"font-medium text-gray-900\">\n            Available Sections\n          </h4>\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\">\n            {availableSections.map(section => (\n              <SectionDropZone\n                key={section.sectionId}\n                sectionData={section}\n                currentCount={section.currentCount || 0}\n                incomingCount={getIncomingCountForSection(section.sectionId)}\n                maxCapacity={section.maxCapacity}\n                onMoverDrop={handleMoverDrop}\n                isDragInProgress={isDragInProgress}\n                canAcceptDrop={true}\n              />\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default AssignmentInterface;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/DraggableMover.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.mover\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDragStart\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDragEnd\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isDragging\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.disabled\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":40,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":49,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":42}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\n\n/**\n *\n * @param root0\n * @param root0.mover\n * @param root0.onDragStart\n * @param root0.onDragEnd\n * @param root0.isDragging\n * @param root0.disabled\n * @param root0.className\n */\nfunction DraggableMover({\n  mover,\n  onDragStart,\n  onDragEnd,\n  isDragging = false,\n  disabled = false,\n  className = '',\n}) {\n  const [dragPreview, setDragPreview] = useState(false);\n  const [mouseDown, setMouseDown] = useState(false);\n  const [touchDragActive, setTouchDragActive] = useState(false);\n  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });\n  const elementRef = useRef(null);\n  const touchStartPos = useRef({ x: 0, y: 0 });\n  const dragThreshold = 10;\n  const pressHoldTimer = useRef(null);\n  const [isPressHolding, setIsPressHolding] = useState(false);\n  const PRESS_HOLD_DELAY = 200;\n\n  const isDraggable = !disabled && !mover.assignedSection;\n\n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element || !isDraggable) return;\n\n    const clearPressHoldTimer = () => {\n      if (pressHoldTimer.current) {\n        clearTimeout(pressHoldTimer.current);\n        pressHoldTimer.current = null;\n      }\n    };\n\n    const handleTouchStart = (e) => {\n      const touch = e.touches[0];\n      touchStartPos.current = { x: touch.clientX, y: touch.clientY };\n\n      pressHoldTimer.current = setTimeout(() => {\n        setIsPressHolding(true);\n        setMouseDown(true);\n        setTouchDragActive(true);\n        setDragPreview(true);\n\n        if (navigator.vibrate) {\n          navigator.vibrate(50);\n        }\n\n        if (onDragStart) {\n          const dragData = {\n            moverId: mover.memberId,\n            moverName: mover.name,\n            currentSection: mover.currentSection,\n            currentSectionId: mover.currentSectionId,\n            targetSection: mover.targetSection,\n            age: mover.age,\n            termType: 'assignment',\n          };\n          onDragStart(dragData);\n        }\n      }, PRESS_HOLD_DELAY);\n    };\n\n    const handleTouchMove = (e) => {\n      const touch = e.touches[0];\n      const deltaX = touch.clientX - touchStartPos.current.x;\n      const deltaY = touch.clientY - touchStartPos.current.y;\n      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n      if (pressHoldTimer.current && distance > dragThreshold) {\n        clearPressHoldTimer();\n        setIsPressHolding(false);\n        return;\n      }\n\n      if (touchDragActive && isPressHolding) {\n        e.preventDefault();\n        setDragPosition({\n          x: touch.clientX,\n          y: touch.clientY,\n        });\n      }\n    };\n\n    const handleTouchEnd = (e) => {\n      clearPressHoldTimer();\n\n      if (touchDragActive && isPressHolding) {\n        const touch = e.changedTouches[0];\n        const elementBelow = document.elementFromPoint(\n          touch.clientX,\n          touch.clientY,\n        );\n\n        if (elementBelow) {\n          let dropZone = elementBelow;\n          while (dropZone && !dropZone.dataset.sectionDropZone) {\n            dropZone = dropZone.parentElement;\n          }\n\n          if (dropZone) {\n            const dropEventData = {\n              moverId: mover.memberId,\n              moverName: mover.name,\n              currentSection: mover.currentSection,\n              currentSectionId: mover.currentSectionId,\n              targetSection: mover.targetSection,\n              age: mover.age,\n              targetSectionId: dropZone.dataset.sectionId,\n              targetSectionName: dropZone.dataset.sectionName,\n            };\n\n            const dropEvent = new window.CustomEvent('section-assignment-drop', {\n              detail: dropEventData,\n              bubbles: true,\n              cancelable: true,\n              composed: true,\n            });\n            dropZone.dispatchEvent(dropEvent);\n          }\n        }\n      }\n\n      setMouseDown(false);\n      setTouchDragActive(false);\n      setDragPreview(false);\n      setIsPressHolding(false);\n      setDragPosition({ x: 0, y: 0 });\n\n      if (touchDragActive && onDragEnd) {\n        onDragEnd();\n      }\n    };\n\n    const handleTouchCancel = () => {\n      clearPressHoldTimer();\n      setMouseDown(false);\n      setTouchDragActive(false);\n      setDragPreview(false);\n      setIsPressHolding(false);\n      setDragPosition({ x: 0, y: 0 });\n\n      if (touchDragActive && onDragEnd) {\n        onDragEnd();\n      }\n    };\n\n    element.addEventListener('touchstart', handleTouchStart, { passive: true });\n    element.addEventListener('touchmove', handleTouchMove, { passive: false });\n    element.addEventListener('touchend', handleTouchEnd, { passive: true });\n    element.addEventListener('touchcancel', handleTouchCancel, { passive: true });\n\n    return () => {\n      clearPressHoldTimer();\n      element.removeEventListener('touchstart', handleTouchStart);\n      element.removeEventListener('touchmove', handleTouchMove);\n      element.removeEventListener('touchend', handleTouchEnd);\n      element.removeEventListener('touchcancel', handleTouchCancel);\n    };\n  }, [isDraggable, mover, onDragStart, onDragEnd, touchDragActive, isPressHolding]);\n\n  const handleMouseDown = () => {\n    if (!isDraggable) return;\n    setMouseDown(true);\n  };\n\n  const handleMouseUp = () => {\n    setMouseDown(false);\n  };\n\n  const handleDragStart = (e) => {\n    if (!isDraggable) {\n      e.preventDefault();\n      return;\n    }\n\n    const dragData = {\n      moverId: mover.memberId,\n      moverName: mover.name,\n      currentSection: mover.currentSection,\n      currentSectionId: mover.currentSectionId,\n      targetSection: mover.targetSection,\n      age: mover.age,\n      termType: 'assignment',\n    };\n\n    try {\n      e.dataTransfer.setData('application/json', JSON.stringify(dragData));\n      e.dataTransfer.effectAllowed = 'move';\n      setDragPreview(true);\n\n      if (onDragStart) {\n        onDragStart(dragData);\n      }\n    } catch (error) {\n      e.preventDefault();\n    }\n  };\n\n  const handleDragEnd = () => {\n    setDragPreview(false);\n    setMouseDown(false);\n\n    if (onDragEnd) {\n      onDragEnd();\n    }\n  };\n\n  const isAssigned = !!mover.assignedSection;\n\n  return (\n    <div\n      ref={elementRef}\n      className={`\n        relative p-3 rounded-lg transition-all duration-200 select-none w-full\n        ${isDraggable\n      ? 'cursor-grab active:cursor-grabbing hover:bg-blue-50 hover:border-blue-300 border-2 border-blue-100 bg-blue-25 hover:shadow-md transform hover:scale-[1.02]'\n      : isAssigned\n        ? 'cursor-default bg-green-50 border-2 border-green-200'\n        : 'cursor-default bg-gray-50 border-2 border-gray-200'\n    }\n        ${mouseDown ? 'cursor-grabbing scale-[1.01] shadow-lg' : ''}\n        ${dragPreview ? 'opacity-60 transform rotate-1 scale-95 shadow-xl' : ''}\n        ${touchDragActive ? 'opacity-30' : ''}\n        ${isDragging ? 'opacity-40' : ''}\n        ${className}\n      `}\n      draggable={isDraggable}\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      style={{\n        touchAction: isPressHolding && touchDragActive ? 'none' : 'auto',\n        userSelect: 'none',\n      }}\n      title={isDraggable ? `Drag ${mover.name} to assign to a section` : mover.name}\n      data-draggable={isDraggable}\n      data-mover-id={mover.memberId}\n    >\n      {isDraggable && (\n        <div className=\"absolute top-1 right-1 text-blue-500 hover:text-blue-700 transition-colors cursor-grab z-10\">\n          <svg className=\"w-3 h-3\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n            <circle cx=\"4\" cy=\"4\" r=\"1.2\" />\n            <circle cx=\"12\" cy=\"4\" r=\"1.2\" />\n            <circle cx=\"4\" cy=\"8\" r=\"1.2\" />\n            <circle cx=\"12\" cy=\"8\" r=\"1.2\" />\n            <circle cx=\"4\" cy=\"12\" r=\"1.2\" />\n            <circle cx=\"12\" cy=\"12\" r=\"1.2\" />\n          </svg>\n        </div>\n      )}\n\n      <div className=\"w-full min-w-0\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"min-w-0 flex-1\">\n            <div className=\"font-medium text-sm text-gray-900 truncate\">\n              {mover.name}\n            </div>\n            <div className=\"text-xs text-gray-500\">\n              Age {mover.age?.toFixed(1)} • {mover.currentSection}\n            </div>\n          </div>\n          <div className=\"text-right ml-2\">\n            <div className=\"text-xs text-blue-600 font-medium\">\n              → {mover.targetSection}\n            </div>\n            {isAssigned && (\n              <div className=\"text-xs text-green-600 mt-1\">\n                ✓ Assigned\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {touchDragActive && (\n        <div\n          className=\"fixed pointer-events-none z-50 transform -translate-x-1/2 -translate-y-1/2 opacity-80 scale-95 rotate-2 shadow-xl\"\n          style={{\n            left: dragPosition.x,\n            top: dragPosition.y,\n            maxWidth: '250px',\n          }}\n        >\n          <div className=\"p-3 rounded-lg bg-blue-100 border-2 border-blue-300 shadow-lg\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"text-blue-500\">\n                <svg className=\"w-3 h-3\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n                  <circle cx=\"4\" cy=\"4\" r=\"1.2\" />\n                  <circle cx=\"12\" cy=\"4\" r=\"1.2\" />\n                  <circle cx=\"4\" cy=\"8\" r=\"1.2\" />\n                  <circle cx=\"12\" cy=\"8\" r=\"1.2\" />\n                  <circle cx=\"4\" cy=\"12\" r=\"1.2\" />\n                  <circle cx=\"12\" cy=\"12\" r=\"1.2\" />\n                </svg>\n              </div>\n              <div className=\"min-w-0\">\n                <div className=\"text-sm font-medium text-blue-700 truncate\">\n                  {mover.name}\n                </div>\n                <div className=\"text-xs text-blue-600\">\n                  → {mover.targetSection}\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default DraggableMover;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/MovementSummaryTable.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":5,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionName\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":23,"column":1,"nodeType":"Block","endLine":30,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":23,"column":1,"nodeType":"Block","endLine":30,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionType\" description.","line":25,"column":1,"nodeType":"Block","endLine":25,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"termCalculations\" description.","line":26,"column":1,"nodeType":"Block","endLine":26,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionsData\" description.","line":27,"column":1,"nodeType":"Block","endLine":27,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"assignments\" description.","line":28,"column":1,"nodeType":"Block","endLine":28,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"unassignedData\" description.","line":29,"column":1,"nodeType":"Block","endLine":29,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":110,"column":1,"nodeType":"Block","endLine":116,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":110,"column":1,"nodeType":"Block","endLine":116,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":112,"column":1,"nodeType":"Block","endLine":112,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.termCalculations\" description.","line":113,"column":1,"nodeType":"Block","endLine":113,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.assignments\" description.","line":114,"column":1,"nodeType":"Block","endLine":114,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionsData\" description.","line":115,"column":1,"nodeType":"Block","endLine":115,"endColumn":1}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { groupSectionsByType, mapSectionType } from '../../../shared/utils/sectionMovements/sectionGrouping.js';\n\n/**\n *\n * @param sectionName\n */\nfunction getSectionTypeFromName(sectionName) {\n  if (!sectionName) return null;\n  \n  const normalized = sectionName.toLowerCase();\n  \n  if (normalized.includes('squirrel')) return 'Squirrels';\n  if (normalized.includes('beaver')) return 'Beavers';\n  if (normalized.includes('cub')) return 'Cubs';\n  if (normalized.includes('scout') && !normalized.includes('cub')) return 'Scouts';\n  if (normalized.includes('explorer')) return 'Explorers';\n  \n  return null;\n}\n\n/**\n *\n * @param sectionType\n * @param termCalculations\n * @param sectionsData\n * @param assignments\n * @param unassignedData\n */\nfunction renderSectionTypeRows(sectionType, termCalculations, sectionsData, assignments, unassignedData) {\n  const firstTermGrouped = groupSectionsByType(termCalculations[0]?.sectionSummaries, sectionsData || []);\n  const firstTermGroup = firstTermGrouped.get(sectionType);\n  if (!firstTermGroup) return null;\n  \n  const rows = [];\n  \n  firstTermGroup.sections.forEach(section => {\n    rows.push(\n      <tr key={`${section.sectionId}`} className=\"border-b\">\n        <td className=\"py-2 px-4 pl-8 text-gray-700\">\n          {section.sectionName}\n        </td>\n        {termCalculations.map((termData, termIndex) => {\n          const sectionSummary = termData.sectionSummaries.get(section.sectionId);\n            \n          if (!sectionSummary) {\n            return (\n              <td key={termIndex} className=\"py-2 px-4 text-center text-gray-500\">\n                  -\n              </td>\n            );\n          }\n            \n          const currentCount = sectionSummary.cumulativeCurrentCount || sectionSummary.currentMembers.length;\n          const outgoingCount = sectionSummary.outgoingMovers.length;\n            \n          const sectionAssignments = assignments ? termData.movers.filter(mover => {\n            const assignment = assignments.get(mover.memberId);\n            const currentTermKey = `${termData.term.type}-${termData.term.year}`;\n            return assignment \n              && String(assignment.sectionId) === String(section.sectionId)\n              && assignment.term === currentTermKey;\n          }).length : 0;\n            \n          const plannedCount = sectionSummary.projectedCount ?? (currentCount + sectionAssignments - outgoingCount);\n            \n          return (\n            <td key={termIndex} className=\"py-2 px-4 text-center\">\n              <div className=\"text-xs flex items-center justify-center space-x-1\">\n                <span className=\"text-gray-600\">Current: {currentCount}</span>\n                <span className={sectionAssignments > 0 ? 'text-green-500' : 'text-gray-400'}>↑{sectionAssignments}</span>\n                <span className={outgoingCount > 0 ? 'text-orange-500' : 'text-gray-400'}>↓{outgoingCount}</span>\n                <span className=\"font-medium text-gray-800\">Planned: {plannedCount}</span>\n              </div>\n            </td>\n          );\n        })}\n      </tr>,\n    );\n  });\n    \n  rows.push(\n    <tr key={`unassigned-${sectionType}`} className=\"border-b bg-amber-50\">\n      <td className=\"py-2 px-4 pl-8 text-amber-800 italic\">\n          Unassigned\n      </td>\n      {termCalculations.map((termData, termIndex) => {\n        const termKey = `${sectionType}-${termIndex}`;\n        const unassignedInfo = unassignedData.get(termKey) || { currentCount: 0, incomingCount: 0, outgoingCount: 0, plannedCount: 0 };\n        const { currentCount, incomingCount, outgoingCount, plannedCount } = unassignedInfo;\n          \n        return (\n          <td key={termIndex} className=\"py-2 px-4 text-center\">\n            <div className=\"text-xs flex items-center justify-center space-x-1\">\n              <span className=\"text-gray-600\">Current: {currentCount}</span>\n              <span className={incomingCount > 0 ? 'text-green-500' : 'text-gray-400'}>↑{incomingCount}</span>\n              <span className={outgoingCount > 0 ? 'text-orange-500' : 'text-gray-400'}>↓{outgoingCount}</span>\n              <span className=\"font-medium text-amber-700\">Planned: {plannedCount}</span>\n            </div>\n          </td>\n        );\n      })}\n    </tr>,\n  );\n    \n  return rows;\n}\n\n/**\n *\n * @param root0\n * @param root0.termCalculations\n * @param root0.assignments\n * @param root0.sectionsData\n */\nfunction MovementSummaryTable({ termCalculations, assignments, sectionsData }) {\n  const allSectionTypes = useMemo(() => ['Squirrels', 'Beavers', 'Cubs', 'Scouts', 'Explorers'], []);\n  \n  // Pre-calculate unassigned counts and cascading totals for performance\n  const unassignedData = useMemo(() => {\n    if (!termCalculations || termCalculations.length === 0 || !assignments) return new Map();\n    \n    const data = new Map();\n    const cumulativeUnassigned = new Map();\n    \n    termCalculations.forEach((termData, termIndex) => {\n      allSectionTypes.forEach(sectionType => {\n        const typeKey = mapSectionType(sectionType);\n        \n        // Calculate incoming movers for this section type\n        const incomingMovers = termData.movers.filter(mover => \n          mapSectionType(mover.targetSection) === typeKey,\n        );\n        \n        // Count how many are assigned to specific sections of this type\n        const assignedCount = incomingMovers.filter(mover => {\n          const assignment = assignments.get(mover.memberId);\n          if (!assignment) return false;\n          \n          // Check if assignment is for the current term\n          const currentTermKey = `${termData.term.type}-${termData.term.year}`;\n          if (assignment.term !== currentTermKey) return false;\n          \n          // Check if the assignment is for a section of this type\n          const assignedSection = sectionsData?.find(s => \n            String(s.sectionId || s.sectionid) === String(assignment.sectionId),\n          );\n          if (!assignedSection) return false;\n          \n          // Get the section type from the assigned section\n          const assignedSectionName = assignedSection.sectionname || assignedSection.name || '';\n          const assignedTypeKey = mapSectionType(getSectionTypeFromName(assignedSectionName));\n          return assignedTypeKey === typeKey;\n        }).length;\n        \n        const newUnassignedCount = Math.max(0, incomingMovers.length - assignedCount);\n        \n        // Calculate cascading current count\n        let currentCount;\n        if (termIndex === 0) {\n          currentCount = 0; // First term starts with 0 unassigned\n        } else {\n          // Subsequent terms start with previous term's planned count\n          const prevTermKey = `${sectionType}-${termIndex - 1}`;\n          currentCount = cumulativeUnassigned.get(prevTermKey) || 0;\n        }\n        \n        // Calculate planned count (current + new incoming)\n        const plannedCount = currentCount + newUnassignedCount;\n        \n        // Store for next term\n        const termKey = `${sectionType}-${termIndex}`;\n        cumulativeUnassigned.set(termKey, plannedCount);\n        \n        data.set(termKey, {\n          currentCount,\n          incomingCount: newUnassignedCount,\n          outgoingCount: 0, // Unassigned movers don't move out\n          plannedCount,\n        });\n      });\n    });\n    \n    return data;\n  }, [termCalculations, assignments, sectionsData, allSectionTypes]);\n\n  if (!termCalculations || termCalculations.length === 0) {\n    return null;\n  }\n  \n  // Calculate section type totals across all terms to handle cascading\n  const sectionTypeTotals = new Map();\n  \n  // Initialize starting counts for first term\n  termCalculations.forEach((termData, termIndex) => {\n    const groupedSections = groupSectionsByType(termData.sectionSummaries, sectionsData || []);\n    \n    allSectionTypes.forEach(sectionType => {\n      const group = groupedSections.get(sectionType);\n      if (!group) return;\n      \n      let startingCount;\n      if (termIndex === 0) {\n        // First term: use actual current members count\n        startingCount = group.sections.reduce((total, section) => {\n          return total + (section.cumulativeCurrentCount || section.currentMembers.length);\n        }, 0);\n      } else {\n        // Subsequent terms: use planned count from previous term\n        const prevTermKey = `${sectionType}-${termIndex - 1}`;\n        startingCount = sectionTypeTotals.get(prevTermKey)?.plannedCount || 0;\n      }\n      \n      const incomingCount = termData.movers.filter(mover => {\n        const targetSectionType = mover.targetSection?.toLowerCase();\n        return targetSectionType === sectionType.toLowerCase();\n      }).length;\n      \n      const outgoingCount = group.totalOutgoing;\n      const plannedCount = startingCount + incomingCount - outgoingCount;\n      \n      // Store the calculated totals for this term\n      const termKey = `${sectionType}-${termIndex}`;\n      sectionTypeTotals.set(termKey, {\n        startingCount,\n        incomingCount,\n        outgoingCount,\n        plannedCount,\n      });\n    });\n  });\n\n  return (\n    <div className=\"mb-6\">\n      <div className=\"bg-gray-100 p-3 rounded-t-lg border-b\">\n        <h2 className=\"text-lg font-semibold text-gray-800\">\n          Movement Summary by Term\n        </h2>\n      </div>\n      \n      <div className=\"bg-white rounded-b-lg border border-t-0 overflow-x-auto\">\n        <table className=\"w-full text-sm\">\n          <thead className=\"bg-gray-50 border-b\">\n            <tr>\n              <th className=\"text-left py-3 px-4 font-medium text-gray-900\">\n                Section\n              </th>\n              {termCalculations.map(termData => (\n                <th key={`${termData.term.type}-${termData.term.year}`} className=\"text-center py-3 px-4 font-medium text-gray-900 min-w-[10rem]\">\n                  {termData.term.displayName || `${termData.term.type} ${termData.term.year}`}\n                </th>\n              ))}\n            </tr>\n          </thead>\n          <tbody>\n            {allSectionTypes.map(sectionType => {\n              // Check if this section type has any data across terms\n              const hasData = termCalculations.some((termData) => {\n                const groupedSections = groupSectionsByType(termData.sectionSummaries, sectionsData || []);\n                return groupedSections.has(sectionType);\n              });\n              \n              if (!hasData) return null;\n              \n              return (\n                <React.Fragment key={sectionType}>\n                  {/* Section Type Header Row */}\n                  <tr className=\"border-b bg-blue-50\">\n                    <td className=\"py-3 px-4 font-semibold text-gray-900\">\n                      {sectionType}\n                    </td>\n                    {termCalculations.map((termData, termIndex) => {\n                      const termKey = `${sectionType}-${termIndex}`;\n                      const totals = sectionTypeTotals.get(termKey);\n                      \n                      if (!totals) {\n                        return (\n                          <td key={termIndex} className=\"py-3 px-4 text-center text-gray-500\">\n                            -\n                          </td>\n                        );\n                      }\n                      \n                      const { startingCount, incomingCount, outgoingCount, plannedCount } = totals;\n                      \n                      return (\n                        <td key={termIndex} className=\"py-2 px-4 text-center\">\n                          <div className=\"text-xs flex items-center justify-center space-x-1\">\n                            <span className=\"text-gray-700\">Current: {startingCount}</span>\n                            <span className={incomingCount > 0 ? 'text-green-600' : 'text-gray-400'}>↑{incomingCount}</span>\n                            <span className={outgoingCount > 0 ? 'text-orange-600' : 'text-gray-400'}>↓{outgoingCount}</span>\n                            <span className=\"font-medium text-blue-700\">Planned: {plannedCount}</span>\n                          </div>\n                        </td>\n                      );\n                    })}\n                  </tr>\n                  \n                  {/* Individual Section Rows */}\n                  {renderSectionTypeRows(sectionType, termCalculations, sectionsData, assignments, unassignedData)}\n                </React.Fragment>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n}\n\nMovementSummaryTable.propTypes = {\n  termCalculations: PropTypes.arrayOf(PropTypes.shape({\n    term: PropTypes.shape({\n      type: PropTypes.string.isRequired,\n      year: PropTypes.number.isRequired,\n      displayName: PropTypes.string,\n    }).isRequired,\n    sectionSummaries: PropTypes.instanceOf(Map).isRequired,\n    movers: PropTypes.arrayOf(PropTypes.object).isRequired,\n  })).isRequired,\n  assignments: PropTypes.instanceOf(Map),\n  sectionsData: PropTypes.arrayOf(PropTypes.shape({\n    sectionId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    sectionid: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    sectionName: PropTypes.string,\n    sectionname: PropTypes.string,\n    name: PropTypes.string,\n  })),\n};\n\nexport default MovementSummaryTable;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/MoverAssignmentRow.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":11,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":11,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.mover\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.availableSections\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.availableTerms\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onAssignmentChange\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onTermOverrideChange\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.mover\n * @param root0.availableSections\n * @param root0.availableTerms\n * @param root0.onAssignmentChange\n * @param root0.onTermOverrideChange\n */\nfunction MoverAssignmentRow({\n  mover,\n  availableSections,\n  availableTerms,\n  onAssignmentChange,\n  onTermOverrideChange,\n}) {\n  const currentAssignment = mover.assignedSectionId || '';\n  const currentTermOverride = mover.assignedTerm || '';\n\n  const handleSectionChange = (e) => {\n    const sectionId = e.target.value;\n    const targetSection = availableSections.find(s => s.sectionId === sectionId);\n    \n    if (onAssignmentChange) {\n      onAssignmentChange(mover.memberId, {\n        memberId: mover.memberId,\n        currentSectionId: mover.currentSectionId,\n        sectionId: sectionId || null,\n        sectionName: targetSection?.sectionName || null,\n      });\n    }\n  };\n\n  const handleTermChange = (e) => {\n    const termValue = e.target.value;\n    \n    if (onTermOverrideChange) {\n      onTermOverrideChange(mover.memberId, termValue || null);\n    }\n  };\n\n  return (\n    <div className=\"p-2 bg-white rounded border border-gray-200 hover:border-gray-300\">\n      {/* Mobile Layout */}\n      <div className=\"md:hidden space-y-2\">\n        <div className=\"flex justify-between items-start\">\n          <div>\n            <div className=\"font-medium text-sm text-gray-900\">\n              {mover.name} <span className=\"text-xs text-gray-500 font-normal\">\n                ({mover.birthdate ? new Date(mover.birthdate).toLocaleDateString() : 'Unknown'})\n              </span>\n            </div>\n          </div>\n        </div>\n        \n        <div className=\"space-y-2\">\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-xs text-gray-500 min-w-[60px]\">Section:</span>\n            <select\n              value={currentAssignment}\n              onChange={handleSectionChange}\n              className=\"text-xs border border-gray-300 rounded px-2 py-1 flex-1\"\n            >\n              <option value=\"\">Select section...</option>\n              {availableSections.map(section => (\n                <option key={section.sectionId} value={section.sectionId}>\n                  {section.sectionName}\n                </option>\n              ))}\n            </select>\n          </div>\n          \n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-xs text-gray-500 min-w-[60px]\">Term:</span>\n            <select\n              value={currentTermOverride}\n              onChange={handleTermChange}\n              className=\"text-xs border border-gray-300 rounded px-2 py-1 flex-1\"\n              title=\"Override term assignment\"\n            >\n              {availableTerms.map(term => (\n                <option key={`${term.type}-${term.year}`} value={`${term.type}-${term.year}`}>\n                  {term.type} {term.year}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n      </div>\n      \n      {/* Desktop Layout */}\n      <div className=\"hidden md:grid grid-cols-[130px_8px_140px_100px] gap-2 items-center\">\n        <div className=\"min-w-0\">\n          <div className=\"font-medium text-xs text-gray-900 leading-tight\" title={mover.name}>\n            {mover.name} <span className=\"text-xs text-gray-500 font-normal\">\n              ({mover.birthdate ? new Date(mover.birthdate).toLocaleDateString() : 'Unknown'})\n            </span>\n          </div>\n        </div>\n        \n        <div className=\"text-xs text-gray-600 text-center flex-shrink-0\">→</div>\n        \n        <select\n          value={currentAssignment}\n          onChange={handleSectionChange}\n          className=\"text-xs border border-gray-300 rounded px-1 py-1 w-full min-w-[120px]\"\n        >\n          <option value=\"\">Select section...</option>\n          {availableSections.map(section => (\n            <option key={section.sectionId} value={section.sectionId}>\n              {section.sectionName}\n            </option>\n          ))}\n        </select>\n        \n        <select\n          value={currentTermOverride}\n          onChange={handleTermChange}\n          className=\"text-xs border border-gray-300 rounded px-1 py-1 w-full min-w-[90px]\"\n          title=\"Override term assignment\"\n        >\n          {availableTerms.map(term => (\n            <option key={`${term.type}-${term.year}`} value={`${term.type}-${term.year}`}>\n              {term.type} {term.year}\n            </option>\n          ))}\n        </select>\n      </div>\n    </div>\n  );\n}\n\nexport default MoverAssignmentRow;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/MoversByTargetSection.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":5,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.movers\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.allSections\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.availableTerms\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.assignments\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onAssignmentChange\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onTermOverrideChange\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback, memo } from 'react';\nimport MoverAssignmentRow from './MoverAssignmentRow.jsx';\nimport { mapSectionType } from '../../../shared/utils/sectionMovements/sectionGrouping.js';\n\n/**\n *\n * @param root0\n * @param root0.movers\n * @param root0.allSections\n * @param root0.availableTerms\n * @param root0.assignments\n * @param root0.onAssignmentChange\n * @param root0.onTermOverrideChange\n */\nfunction MoversByTargetSection({\n  movers,\n  allSections,\n  availableTerms,\n  assignments,\n  onAssignmentChange,\n  onTermOverrideChange,\n}) {\n  const moversByTarget = useMemo(() => {\n    if (!Array.isArray(movers)) {\n      return new Map();\n    }\n    \n    const grouped = new Map();\n    \n    movers.forEach(mover => {\n      if (!mover) return;\n      \n      const targetSectionType = mapSectionType(mover.targetSection?.toLowerCase() || '');\n      \n      if (!grouped.has(targetSectionType)) {\n        grouped.set(targetSectionType, {\n          sectionType: targetSectionType,\n          movers: [],\n          totalMovers: 0,\n          assignedCount: 0,\n        });\n      }\n      \n      const group = grouped.get(targetSectionType);\n      group.movers.push({\n        ...mover,\n        assignedSectionId: assignments.get(mover.memberId)?.sectionId || null,\n        assignedTerm: assignments.get(mover.memberId)?.term || null,\n      });\n      group.totalMovers++;\n      \n      if (assignments.has(mover.memberId)) {\n        group.assignedCount++;\n      }\n    });\n    \n    return grouped;\n  }, [movers, assignments]);\n\n  const getAvailableSectionsForType = useCallback((sectionType) => {\n    if (!Array.isArray(allSections)) {\n      return [];\n    }\n    return allSections.filter(section => {\n      if (!section) return false;\n      const sectionSectionType = mapSectionType(section.sectionType?.toLowerCase() || '');\n      return sectionSectionType === sectionType;\n    });\n  }, [allSections]);\n\n  const getIncomingCountForSection = useCallback((sectionId) => {\n    if (!sectionId) return 0;\n    return Array.from(assignments.values()).filter(\n      assignment => assignment?.sectionId === sectionId,\n    ).length;\n  }, [assignments]);\n\n  const sortedSectionTypes = ['Squirrels', 'Beavers', 'Cubs', 'Scouts', 'Explorers'];\n  const orderedGroups = Array.from(moversByTarget.entries())\n    .sort(([a], [b]) => sortedSectionTypes.indexOf(a) - sortedSectionTypes.indexOf(b));\n\n  return (\n    <div className=\"space-y-6\">\n      {orderedGroups.map(([sectionType, group]) => {\n        const availableSectionsForType = getAvailableSectionsForType(sectionType);\n        \n        return (\n          <div key={sectionType} className=\"bg-amber-50 rounded-lg border border-amber-200\">\n            <div className=\"bg-amber-100 p-3 rounded-t-lg border-b border-amber-200\">\n              <div className=\"flex items-center justify-between\">\n                <h3 className=\"text-lg font-semibold text-amber-900\">\n                  Moving to {sectionType}\n                </h3>\n                <div className=\"text-sm text-amber-700\">\n                  {group.assignedCount}/{group.totalMovers} assigned\n                </div>\n              </div>\n              \n              {availableSectionsForType.length > 0 && (\n                <div className=\"mt-2 text-sm text-amber-700\">\n                  Available: {availableSectionsForType.map(section => (\n                    <span key={section.sectionId} className=\"mr-3\">\n                      {section.sectionName} \n                      ({section.currentCount + getIncomingCountForSection(section.sectionId)})\n                    </span>\n                  ))}\n                </div>\n              )}\n            </div>\n            \n            <div className=\"p-4 space-y-2\">\n              {group.movers.map(mover => (\n                <MoverAssignmentRow\n                  key={mover.memberId}\n                  mover={mover}\n                  availableSections={availableSectionsForType}\n                  availableTerms={availableTerms}\n                  onAssignmentChange={onAssignmentChange}\n                  onTermOverrideChange={onTermOverrideChange}\n                />\n              ))}\n              \n              {group.movers.length === 0 && (\n                <div className=\"text-center py-4 text-amber-600\">\n                  No movers to {sectionType} this term\n                </div>\n              )}\n            </div>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(MoversByTargetSection);","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/MoversPage.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":6,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":6,"column":1,"nodeType":"Block","endLine":8,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { SectionMovementTracker } from './';\nimport { MainNavigation } from '../../../shared/components/layout';\n\n/**\n *\n */\nfunction MoversPage() {\n  const navigate = useNavigate();\n\n  const handleBackToDashboard = () => {\n    navigate('/events');\n  };\n\n  const handleNavigateToSectionMovements = () => {\n    navigate('/movers');\n  };\n\n  return (\n    <>\n      <MainNavigation onNavigateToSectionMovements={handleNavigateToSectionMovements} />\n      <SectionMovementTracker onBack={handleBackToDashboard} />\n    </>\n  );\n}\n\nexport default MoversPage;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/SectionDropZone.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionData\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.currentCount\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.incomingCount\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.maxCapacity\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onMoverDrop\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isDragInProgress\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.canAcceptDrop\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useCallback } from 'react';\n\n/**\n *\n * @param root0\n * @param root0.sectionData\n * @param root0.currentCount\n * @param root0.incomingCount\n * @param root0.maxCapacity\n * @param root0.onMoverDrop\n * @param root0.isDragInProgress\n * @param root0.canAcceptDrop\n * @param root0.className\n */\nfunction SectionDropZone({\n  sectionData,\n  currentCount,\n  incomingCount = 0,\n  maxCapacity,\n  onMoverDrop,\n  isDragInProgress = false,\n  canAcceptDrop = true,\n  className = '',\n}) {\n  const [isDragOver, setIsDragOver] = useState(false);\n  const [canDrop, setCanDrop] = useState(false);\n  const dropZoneRef = useRef(null);\n\n  const isAtCapacity = maxCapacity && (currentCount + incomingCount) >= maxCapacity;\n\n  const handleDragOver = (e) => {\n    e.preventDefault();\n    if (!isDragOver) {\n      setIsDragOver(true);\n    }\n\n    let acceptable = false;\n    if (canAcceptDrop && !isAtCapacity) {\n      try {\n        const dragData = JSON.parse(\n          e.dataTransfer.getData('application/json') || '{}',\n        );\n        acceptable = dragData.currentSectionId !== sectionData.sectionId;\n      } catch (_) {\n        acceptable = true;\n      }\n    }\n    setCanDrop(acceptable);\n    e.dataTransfer.dropEffect = acceptable ? 'move' : 'none';\n  };\n\n  const handleDragLeave = (e) => {\n    const rect = e.currentTarget.getBoundingClientRect();\n    const x = e.clientX;\n    const y = e.clientY;\n    if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {\n      setIsDragOver(false);\n      setCanDrop(false);\n    }\n  };\n\n  const handleDrop = useCallback(async (e) => {\n    e.preventDefault();\n    setIsDragOver(false);\n    setCanDrop(false);\n\n    if (!onMoverDrop || !canAcceptDrop) {\n      return;\n    }\n\n    let dragData;\n    try {\n      if (e.type === 'section-assignment-drop') {\n        dragData = e.detail;\n      } else {\n        dragData = JSON.parse(e.dataTransfer.getData('application/json'));\n      }\n\n      if (!dragData.moverId) {\n        throw new Error('Invalid drag data: missing moverId');\n      }\n\n      if (dragData.currentSectionId === sectionData.sectionId) {\n        return;\n      }\n\n      if (isAtCapacity) {\n        return;\n      }\n\n      await onMoverDrop(dragData, sectionData);\n    } catch (error) {\n      console.error('Error handling mover drop:', error);\n    }\n  }, [onMoverDrop, canAcceptDrop, sectionData, isAtCapacity]);\n\n  const handleMobileDrop = useCallback((e) => {\n    handleDrop({\n      ...e,\n      preventDefault: () => {},\n      type: 'section-assignment-drop',\n    });\n  }, [handleDrop]);\n\n  React.useEffect(() => {\n    const element = dropZoneRef.current;\n    if (!element) return;\n\n    element.addEventListener('section-assignment-drop', handleMobileDrop);\n    return () => {\n      element.removeEventListener('section-assignment-drop', handleMobileDrop);\n    };\n  }, [handleMobileDrop]);\n\n  const getDropZoneStyle = () => {\n    if (!isDragInProgress) return '';\n    \n    if (!canAcceptDrop) {\n      return 'border-gray-300 bg-gray-100';\n    }\n    \n    if (isAtCapacity) {\n      return 'border-red-300 bg-red-50';\n    }\n    \n    if (isDragOver && canDrop) {\n      return 'border-green-400 bg-green-50 shadow-lg';\n    }\n    \n    if (isDragOver) {\n      return 'border-red-400 bg-red-50';\n    }\n    \n    return 'border-blue-300 bg-blue-50';\n  };\n\n  return (\n    <div\n      ref={dropZoneRef}\n      className={`\n        relative p-4 rounded-lg border-2 transition-all duration-200\n        ${getDropZoneStyle()}\n        ${className}\n      `}\n      onDragOver={handleDragOver}\n      onDragLeave={handleDragLeave}\n      onDrop={handleDrop}\n      data-section-drop-zone=\"true\"\n      data-section-id={sectionData.sectionId}\n      data-section-name={sectionData.sectionName}\n    >\n      <div className=\"text-center\">\n        <div className=\"font-medium text-sm text-gray-900 mb-1\">\n          {sectionData.sectionName}\n        </div>\n        <div className=\"text-xs text-gray-600 mb-2\">\n          {currentCount} current • +{incomingCount} incoming\n          {maxCapacity && ` • ${maxCapacity} max`}\n        </div>\n        \n        {isDragInProgress && (\n          <div className=\"mt-2\">\n            {!canAcceptDrop ? (\n              <div className=\"text-xs text-gray-500\">\n                Drop not available\n              </div>\n            ) : isAtCapacity ? (\n              <div className=\"text-xs text-red-600 font-medium\">\n                ⚠ At capacity\n              </div>\n            ) : isDragOver && canDrop ? (\n              <div className=\"text-xs text-green-600 font-medium\">\n                ✓ Drop here to assign\n              </div>\n            ) : (\n              <div className=\"text-xs text-blue-600\">\n                Drop to assign member\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default SectionDropZone;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/SectionMovementCard.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionName\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.currentCount\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.outgoingMovers\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.remainingCount\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.incomingCount\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { memo } from 'react';\nimport { cn } from '../../../shared/utils/cn';\n\n/**\n *\n * @param root0\n * @param root0.sectionName\n * @param root0.currentCount\n * @param root0.outgoingMovers\n * @param root0.remainingCount\n * @param root0.incomingCount\n */\nfunction SectionMovementCard({ \n  sectionName, \n  currentCount, \n  outgoingMovers, \n  remainingCount,\n  incomingCount = 0,\n}) {\n  return (\n    <div className={cn('bg-white rounded-lg border border-gray-200 shadow-sm p-4 mb-4 min-w-fit max-w-sm')}>\n      <div className=\"flex justify-between items-center gap-4 mb-3\">\n        <h3 className=\"text-lg font-semibold text-scout-blue\">\n          {sectionName}\n        </h3>\n        <div className=\"text-right\">\n          <div className=\"flex items-center space-x-2 text-sm whitespace-nowrap\">\n            <span className=\"text-gray-800 font-medium\">{currentCount}</span>\n            <span className=\"text-red-600\">↓{outgoingMovers.length}</span>\n            <span className=\"text-green-600 border border-dashed border-green-400 px-2 py-1 rounded\">\n              ↑{incomingCount}\n            </span>\n            <span className=\"text-gray-400\">=</span>\n            <span className=\"text-blue-600 font-medium\">{remainingCount + incomingCount}</span>\n          </div>\n        </div>\n      </div>\n      \n      {outgoingMovers.length > 0 && (\n        <div>\n          <h4 className=\"text-sm font-medium text-gray-700 mb-2\">\n            Moving Up:\n          </h4>\n          <div className=\"space-y-1\">\n            {outgoingMovers.map(mover => (\n              <div \n                key={mover.memberId}\n                className=\"flex justify-between items-center text-sm\"\n              >\n                <span>{mover.name}</span>\n                <span className=\"text-gray-500\">\n                  {mover.age?.toFixed(1)} years\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n      \n      {outgoingMovers.length === 0 && (\n        <div className=\"text-sm text-gray-500 italic\">\n          No members moving up this term\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default memo(SectionMovementCard);","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/SectionMovementTracker.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":38,"column":1,"nodeType":"Block","endLine":42,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":38,"column":1,"nodeType":"Block","endLine":42,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":40,"column":1,"nodeType":"Block","endLine":40,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onBack\" description.","line":41,"column":1,"nodeType":"Block","endLine":41,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, useEffect, useCallback, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Alert } from '../../../shared/components/ui';\nimport LoadingScreen from '../../../shared/components/LoadingScreen.jsx';\nimport useSectionMovements from '../hooks/useSectionMovements.js';\nimport { calculateSectionMovements } from '../services/movementCalculator.js';\nimport TermMovementCard from './TermMovementCard.jsx';\nimport MovementSummaryTable from './MovementSummaryTable.jsx';\nimport { getFutureTerms } from '../../../shared/utils/sectionMovements/termCalculations.js';\nimport { groupSectionsByType } from '../../../shared/utils/sectionMovements/sectionGrouping.js';\nimport { notifyError } from '../../../shared/utils/notifications.js';\nimport { safeGetItem } from '../../../shared/utils/storageUtils.js';\n\n// User preferences utilities\nconst USER_PREFERENCES_KEY = 'viking_user_preferences';\n\nconst getUserPreferences = () => {\n  try {\n    const stored = localStorage.getItem(USER_PREFERENCES_KEY);\n    return stored ? JSON.parse(stored) : {};\n  } catch (error) {\n    console.warn('Failed to load user preferences:', error);\n    return {};\n  }\n};\n\nconst saveUserPreference = (key, value) => {\n  try {\n    const preferences = getUserPreferences();\n    preferences[key] = value;\n    localStorage.setItem(USER_PREFERENCES_KEY, JSON.stringify(preferences));\n  } catch (error) {\n    console.warn('Failed to save user preference:', error);\n  }\n};\n\n\n/**\n *\n * @param root0\n * @param root0.onBack\n */\nfunction SectionMovementTracker({ onBack }) {\n  // Load numberOfTerms from user preferences, default to 2\n  const [numberOfTerms, setNumberOfTerms] = useState(() => {\n    const preferences = getUserPreferences();\n    return preferences.numberOfTerms || 2;\n  });\n  const [_allAssignments, _setAllAssignments] = useState(new Map());\n  const { members, sections, loading, error, refetch, flexiRecordState } = useSectionMovements();\n  const hasCheckedFlexiRecords = useRef(false);\n  \n  const futureTerms = getFutureTerms(numberOfTerms);\n\n  // Save numberOfTerms preference whenever it changes\n  useEffect(() => {\n    saveUserPreference('numberOfTerms', numberOfTerms);\n  }, [numberOfTerms]);\n\n  // Check for missing Viking Section Movers FlexiRecords\n  const checkForMissingFlexiRecords = useCallback((sectionsData) => {\n    if (!sectionsData || sectionsData.length === 0) return;\n\n    const missingSections = [];\n\n    sectionsData.forEach(section => {\n      const sectionId = section.sectionid;\n      const sectionName = section.sectionname || section.name || 'Unknown Section';\n      \n      // Filter out adults and waitinglist sections\n      const normalizedName = sectionName.toLowerCase();\n      if (normalizedName.includes('adults') || \n          normalizedName.includes('waiting') || \n          normalizedName.includes('waitinglist')) {\n        return; // Skip these sections\n      }\n\n      // Check if this section is already loaded (has FlexiRecord data)\n      if (flexiRecordState.loadedSections && flexiRecordState.loadedSections.has(sectionId)) {\n        return; // Section has FlexiRecord loaded, treat as present\n      }\n\n      // Fallback: Check if FlexiRecord list exists in cache for this section\n      const cacheKey = `viking_flexi_lists_${sectionId}_offline`;\n      const flexiRecordsList = safeGetItem(cacheKey, null);\n      \n      if (!flexiRecordsList || !flexiRecordsList.items) {\n        missingSections.push(sectionName);\n        return;\n      }\n\n      // Check if Viking Section Movers FlexiRecord exists in the list\n      const hasVikingSectionMovers = flexiRecordsList.items.some(record => \n        record.name === 'Viking Section Movers',\n      );\n\n      if (!hasVikingSectionMovers) {\n        missingSections.push(sectionName);\n      }\n    });\n\n    // Show notification if there are missing FlexiRecords\n    if (missingSections.length > 0) {\n      const sectionList = missingSections.join(', ');\n      const requiredFields = ['AssignedSection', 'AssignedTerm'];\n      const optionalFields = ['AssignmentDate', 'AssignedBy'];\n      \n      const message = `Missing \"Viking Section Movers\" FlexiRecord for: ${sectionList}. ` +\n        `Contact your administrator to create this FlexiRecord with required fields: ${requiredFields.join(', ')} ` +\n        `and optional fields: ${optionalFields.join(', ')}.`;\n      notifyError(message);\n    }\n  }, [flexiRecordState.loadedSections]);\n\n  // Check for missing FlexiRecords when sections load and FlexiRecord discovery completes (only once per session)\n  useEffect(() => {\n    if (sections && sections.length > 0 && !hasCheckedFlexiRecords.current && flexiRecordState.loading === false) {\n      checkForMissingFlexiRecords(sections);\n      hasCheckedFlexiRecords.current = true;\n    }\n  }, [sections, checkForMissingFlexiRecords, flexiRecordState.loading]);\n\n  // Reset the check flag when component unmounts\n  useEffect(() => {\n    return () => {\n      hasCheckedFlexiRecords.current = false;\n    };\n  }, []);\n  \n  const termCalculations = useMemo(() => {\n    if (!members || !sections) return [];\n    \n    let availableMembers = [...members];\n    const alreadyMoved = new Set();\n    const cumulativeSectionCounts = new Map(); // Track cumulative counts across terms\n    const cumulativeSectionTypeCounts = new Map(); // Track section type totals across terms\n    \n    return futureTerms.map((term, termIndex) => {\n      const calculations = calculateSectionMovements(availableMembers, term.startDate, sections, term);\n      \n      \n      // Update cumulative counts for each section\n      const updatedSectionSummaries = new Map();\n      \n      calculations.sectionSummaries.forEach((summary, sectionId) => {\n        // For first term, use actual current members count\n        // For subsequent terms, use previous term's projected count\n        let cumulativeCurrentCount;\n        if (termIndex === 0) {\n          // For first term, count actual members from FlexiRecord for this section\n          const sectionMembers = members.filter(member => {\n            const memberSectionId = member.section_id || member.sectionid;\n            return memberSectionId === sectionId;\n          });\n          cumulativeCurrentCount = sectionMembers.length;\n          cumulativeSectionCounts.set(sectionId, cumulativeCurrentCount);\n        } else {\n          cumulativeCurrentCount = cumulativeSectionCounts.get(sectionId) || 0;\n        }\n        \n        // Get manual assignments for this section from FlexiRecord data\n        const manualAssignments = calculations.movers.filter(mover => {\n          if (!mover.flexiRecordSection || mover.flexiRecordSection === 'Not Known') return false;\n          const assignedSection = sections?.find(section => \n            section.sectionname === mover.flexiRecordSection ||\n            section.name === mover.flexiRecordSection,\n          );\n          return assignedSection && String(assignedSection.sectionid || assignedSection.sectionId) === String(sectionId);\n        }).length;\n        \n        // Calculate projected count: current - outgoing + incoming + manual assignments\n        const projectedCount = Math.max(0, cumulativeCurrentCount - summary.outgoingMovers.length + summary.incomingMovers.length + manualAssignments);\n        \n        // Store projected count for next term\n        cumulativeSectionCounts.set(sectionId, projectedCount);\n        \n        // Create updated summary with cumulative counts\n        updatedSectionSummaries.set(sectionId, {\n          ...summary,\n          cumulativeCurrentCount,\n          projectedCount,\n          remainingCount: Math.max(0, cumulativeCurrentCount - summary.outgoingMovers.length),\n        });\n      });\n      \n      calculations.movers.forEach(mover => {\n        alreadyMoved.add(mover.memberId);\n      });\n      \n      availableMembers = availableMembers.filter(member => {\n        const memberId = member.member_id || member.scoutid;\n        return !alreadyMoved.has(memberId);\n      });\n      \n      // Calculate section type totals for this term\n      const groupedSections = groupSectionsByType(updatedSectionSummaries, sections);\n      const sectionTypeTotals = new Map();\n      \n      const allSectionTypes = ['Squirrels', 'Beavers', 'Cubs', 'Scouts', 'Explorers'];\n      allSectionTypes.forEach(sectionType => {\n        const group = groupedSections.get(sectionType);\n        if (!group) return;\n        \n        let startingCount;\n        if (termIndex === 0) {\n          // First term: sum of actual current members for this section type\n          startingCount = group.sections.reduce((total, section) => {\n            return total + (section.cumulativeCurrentCount || section.currentMembers.length);\n          }, 0);\n        } else {\n          // Subsequent terms: use planned count from previous term\n          const prevTermKey = `${sectionType}-${termIndex - 1}`;\n          startingCount = cumulativeSectionTypeCounts.get(prevTermKey) || 0;\n        }\n        \n        const incomingCount = calculations.movers.filter(mover => {\n          const targetSectionType = mover.targetSection?.toLowerCase();\n          return targetSectionType === sectionType.toLowerCase();\n        }).length;\n        \n        const outgoingCount = group.totalOutgoing;\n        const plannedCount = startingCount + incomingCount - outgoingCount;\n        \n        // Store for next term\n        const termKey = `${sectionType}-${termIndex}`;\n        cumulativeSectionTypeCounts.set(termKey, plannedCount);\n        \n        sectionTypeTotals.set(sectionType, {\n          startingCount,\n          incomingCount,\n          outgoingCount,\n          plannedCount,\n        });\n      });\n      \n      return {\n        term,\n        sectionSummaries: updatedSectionSummaries,\n        unassignedMovers: calculations.movers,\n        movers: calculations.movers,\n        sectionTypeTotals,\n      };\n    });\n  }, [members, sections, futureTerms]);\n\n  // Collect all FlexiRecord assignments from all terms for the summary table\n  const allFlexiRecordAssignments = useMemo(() => {\n    const assignments = new Map();\n    \n    termCalculations.forEach(termData => {\n      termData.movers.forEach(mover => {\n        if (mover.flexiRecordSection && mover.flexiRecordSection !== 'Not Known') {\n          // Find the section that matches the assigned section name\n          const assignedSection = sections?.find(section => \n            section.sectionname === mover.flexiRecordSection ||\n            section.name === mover.flexiRecordSection,\n          );\n          \n          if (assignedSection) {\n            console.log('DEBUG: Found assignment:', mover.name, 'to', mover.flexiRecordSection, 'section ID:', assignedSection.sectionid);\n            const assignment = {\n              memberId: mover.memberId,\n              currentSectionId: mover.currentSectionId,\n              sectionId: assignedSection.sectionid || assignedSection.sectionId,\n              sectionName: assignedSection.sectionname || assignedSection.name,\n              term: mover.flexiRecordTerm || `${termData.term.type}-${termData.term.year}`,\n            };\n            \n            assignments.set(mover.memberId, assignment);\n          }\n        }\n      });\n    });\n    \n    console.log('DEBUG: FlexiRecord assignments collected:', assignments.size, assignments);\n    return assignments;\n  }, [termCalculations, sections]);\n\n  if (loading) {\n    return (\n      <LoadingScreen message=\"Loading members and sections...\" />\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"p-4\">\n        <Alert variant=\"error\" className=\"mb-4\">\n          {error}\n        </Alert>\n        <button \n          onClick={refetch}\n          className=\"inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base bg-white border-2 border-scout-blue text-scout-blue hover:bg-scout-blue hover:text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n        >\n          Retry\n        </button>\n      </div>\n    );\n  }\n\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <div className=\"bg-white shadow-sm border-b\">\n        <div className=\"flex items-center justify-between p-4\">\n          <div className=\"flex items-center\">\n            <button \n              onClick={onBack}\n              className=\"mr-3 inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base bg-transparent text-gray-600 hover:text-gray-900 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 active:bg-gray-200 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n              aria-label=\"Go back\"\n            >\n              ← Back\n            </button>\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              Section Movers\n            </h1>\n          </div>\n          <div className=\"flex items-center space-x-3\">\n            <div className=\"flex flex-col\">\n              <label htmlFor=\"number-of-terms\" className=\"text-xs text-gray-600 mb-1\">\n                Future Terms to Show\n              </label>\n              <input\n                id=\"number-of-terms\"\n                type=\"number\"\n                min=\"1\"\n                max=\"6\"\n                value={numberOfTerms}\n                onChange={(e) => setNumberOfTerms(parseInt(e.target.value) || 2)}\n                className=\"text-sm border rounded px-2 py-1 w-20\"\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"p-4\">\n        {termCalculations.length === 0 ? (\n          <div className=\"text-center py-12\">\n            <p className=\"text-gray-500 text-lg mb-4\">\n              No future terms to display\n            </p>\n            <button \n              onClick={refetch}\n              className=\"inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base bg-white border-2 border-scout-blue text-scout-blue hover:bg-scout-blue hover:text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue-light transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n            >\n              Refresh Data\n            </button>\n          </div>\n        ) : (\n          <div className=\"space-y-6\">\n            {/* Movement Summary Table */}\n            <MovementSummaryTable \n              termCalculations={termCalculations}\n              assignments={allFlexiRecordAssignments}\n              sectionsData={sections}\n            />\n            \n            {termCalculations.map(termData => (\n              <TermMovementCard\n                key={`${termData.term.type}-${termData.term.year}`}\n                term={termData.term}\n                sectionSummaries={termData.sectionSummaries}\n                sectionsData={sections}\n                unassignedMovers={termData.unassignedMovers}\n                movers={termData.movers}\n                sectionTypeTotals={termData.sectionTypeTotals}\n                onDataRefresh={refetch}\n                allTerms={futureTerms}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nSectionMovementTracker.propTypes = {\n  onBack: PropTypes.func.isRequired,\n};\n\nexport default SectionMovementTracker;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/SectionTypeGroup.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":6,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":6,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionName\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":24,"column":1,"nodeType":"Block","endLine":41,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":24,"column":1,"nodeType":"Block","endLine":41,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":26,"column":1,"nodeType":"Block","endLine":26,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionType\" description.","line":27,"column":1,"nodeType":"Block","endLine":27,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.group\" description.","line":28,"column":1,"nodeType":"Block","endLine":28,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.movers\" description.","line":29,"column":1,"nodeType":"Block","endLine":29,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.showAssignmentInterface\" description.","line":30,"column":1,"nodeType":"Block","endLine":30,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.allSections\" description.","line":31,"column":1,"nodeType":"Block","endLine":31,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.availableTerms\" description.","line":32,"column":1,"nodeType":"Block","endLine":32,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.assignments\" description.","line":33,"column":1,"nodeType":"Block","endLine":33,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.currentTerm\" description.","line":34,"column":1,"nodeType":"Block","endLine":34,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionTypeTotals\" description.","line":35,"column":1,"nodeType":"Block","endLine":35,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onAssignmentChange\" description.","line":36,"column":1,"nodeType":"Block","endLine":36,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onTermOverrideChange\" description.","line":37,"column":1,"nodeType":"Block","endLine":37,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSaveAssignments\" description.","line":38,"column":1,"nodeType":"Block","endLine":38,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onResetAssignments\" description.","line":39,"column":1,"nodeType":"Block","endLine":39,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isSaving\" description.","line":40,"column":1,"nodeType":"Block","endLine":40,"endColumn":1}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport SectionMovementCard from './SectionMovementCard.jsx';\nimport MoverAssignmentRow from './MoverAssignmentRow.jsx';\nimport { mapSectionType } from '../../../shared/utils/sectionMovements/sectionGrouping.js';\n\n/**\n *\n * @param sectionName\n */\nfunction getSectionTypeFromName(sectionName) {\n  if (!sectionName) return null;\n  \n  const normalized = sectionName.toLowerCase();\n  \n  if (normalized.includes('squirrel') || normalized.includes('early')) return 'squirrels';\n  if (normalized.includes('beaver')) return 'beavers';\n  if (normalized.includes('cub')) return 'cubs';\n  if (normalized.includes('scout')) return 'scouts';\n  if (normalized.includes('explorer')) return 'explorers';\n  \n  return null;\n}\n\n/**\n *\n * @param root0\n * @param root0.sectionType\n * @param root0.group\n * @param root0.movers\n * @param root0.showAssignmentInterface\n * @param root0.allSections\n * @param root0.availableTerms\n * @param root0.assignments\n * @param root0.currentTerm\n * @param root0.sectionTypeTotals\n * @param root0.onAssignmentChange\n * @param root0.onTermOverrideChange\n * @param root0.onSaveAssignments\n * @param root0.onResetAssignments\n * @param root0.isSaving\n */\nfunction SectionTypeGroup({ \n  sectionType, \n  group, \n  movers, \n  showAssignmentInterface = false,\n  allSections = [],\n  availableTerms = [],\n  assignments = new Map(),\n  currentTerm,\n  sectionTypeTotals,\n  onAssignmentChange,\n  onTermOverrideChange,\n  onSaveAssignments,\n  onResetAssignments,\n  isSaving = false,\n}) {\n  const typeKey = mapSectionType(sectionType);\n  const incomingMovers = movers.filter(mover => \n    mapSectionType(mover.targetSection) === typeKey,\n  );\n\n  const availableSectionsForType = allSections.filter(section => {\n    const sectionTypeKey = mapSectionType(section.sectionType);\n    const nameBasedTypeKey = mapSectionType(getSectionTypeFromName(section.sectionName));\n    return sectionTypeKey === typeKey || nameBasedTypeKey === typeKey;\n  });\n\n\n\n  const assignmentsForThisType = incomingMovers.filter(mover => \n    assignments.has(mover.memberId),\n  );\n\n  // Use passed section type totals or fallback to calculation\n  const sectionTotals = sectionTypeTotals?.get(sectionType) ?? sectionTypeTotals?.get(typeKey);\n  const startingCount = sectionTotals?.startingCount ?? group.sections.reduce((total, section) => {\n    return total + (section.cumulativeCurrentCount ?? (Array.isArray(section.currentMembers) ? section.currentMembers.length : 0));\n  }, 0);\n  const incomingCount = sectionTotals?.incomingCount ?? incomingMovers.length;\n  const outgoingCount = sectionTotals?.outgoingCount ?? group.totalOutgoing;\n  const plannedCount = sectionTotals?.plannedCount ?? (startingCount + incomingCount - outgoingCount);\n\n  return (\n    <div className=\"mb-6\">\n      <div className=\"bg-white p-3 rounded-t-lg border-b\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h3 className=\"text-lg font-semibold text-gray-800\">\n              {sectionType}\n            </h3>\n            <div className=\"text-sm text-gray-600 mt-1\">\n              <div className=\"flex flex-wrap gap-4\">\n                <span>\n                  Starting: {startingCount}\n                </span>\n                {incomingCount > 0 && (\n                  <span>\n                    ↑ {incomingCount} incoming\n                  </span>\n                )}\n                {outgoingCount > 0 && (\n                  <span>\n                    ↓ {outgoingCount} moving up\n                  </span>\n                )}\n                <span className=\"font-medium\">\n                  Planned: {plannedCount}\n                </span>\n              </div>\n            </div>\n          </div>\n          \n          {incomingMovers.length > 0 && (\n            <div className=\"flex space-x-2\">\n              <button \n                onClick={onResetAssignments}\n                disabled={assignmentsForThisType.length === 0}\n                className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed border border-gray-300 text-gray-700 bg-white hover:bg-gray-50 focus:ring-blue-300 active:bg-gray-100\"\n              >\n                Reset\n              </button>\n              <button \n                onClick={onSaveAssignments}\n                disabled={assignmentsForThisType.length === 0 || isSaving}\n                className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed bg-scout-blue text-white hover:bg-scout-blue-dark focus:ring-scout-blue-light active:bg-scout-blue-dark\"\n              >\n                {isSaving ? 'Saving...' : `Save (${assignmentsForThisType.length})`}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n      \n      <div className=\"bg-white rounded-b-lg border border-t-0 p-4\">\n        {/* Section cards with flexible layout */}\n        <div className=\"flex flex-wrap gap-3 mb-4\">\n          {group.sections.map(summary => {\n            const sectionData = allSections.find(s => s.sectionId === summary.sectionId);\n            const incomingCount = sectionData?.incomingCount || 0;\n            return (\n              <SectionMovementCard\n                key={summary.sectionId}\n                sectionName={summary.sectionName}\n                currentCount={summary.cumulativeCurrentCount || summary.currentMembers.length}\n                outgoingMovers={summary.outgoingMovers}\n                remainingCount={summary.remainingCount}\n                incomingCount={incomingCount}\n              />\n            );\n          })}\n          \n          {/* Assignment interface card */}\n          {showAssignmentInterface && incomingMovers.length > 0 && (\n            <div className=\"bg-amber-50 rounded-lg border border-amber-200 p-4 min-w-[475px]\">\n              <div className=\"flex items-center justify-between mb-3\">\n                <h4 className=\"font-medium text-amber-900\">\n                  Moving to {sectionType}\n                </h4>\n                <div className=\"text-sm text-amber-700\">\n                  {incomingMovers.filter(m => assignments.has(m.memberId)).length}/{incomingMovers.length} assigned\n                </div>\n              </div>\n              \n              <div className=\"space-y-2 max-h-48 overflow-y-auto\">\n                {incomingMovers.map(mover => (\n                  <MoverAssignmentRow\n                    key={mover.memberId}\n                    mover={{\n                      ...mover,\n                      assignedSectionId: assignments.get(mover.memberId)?.sectionId || null,\n                      assignedTerm: assignments.get(mover.memberId)?.term || mover.flexiRecordTerm || `${currentTerm?.type}-${currentTerm?.year}`,\n                    }}\n                    availableSections={availableSectionsForType}\n                    availableTerms={availableTerms}\n                    onAssignmentChange={onAssignmentChange}\n                    onTermOverrideChange={onTermOverrideChange}\n                  />\n                ))}\n                \n                {incomingMovers.length === 0 && (\n                  <div className=\"text-center py-4 text-amber-600\">\n                    No movers to {sectionType} this term\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default SectionTypeGroup;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/TermMovementCard.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":11,"column":1,"nodeType":"Block","endLine":21,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":11,"column":1,"nodeType":"Block","endLine":21,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.term\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionSummaries\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionsData\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.movers\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sectionTypeTotals\" description.","line":18,"column":1,"nodeType":"Block","endLine":18,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDataRefresh\" description.","line":19,"column":1,"nodeType":"Block","endLine":19,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.allTerms\" description.","line":20,"column":1,"nodeType":"Block","endLine":20,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":400,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":400,"endColumn":19}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo, useCallback, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport SectionTypeGroup from './SectionTypeGroup.jsx';\nimport { groupSectionsByType, mapSectionType } from '../../../shared/utils/sectionMovements/sectionGrouping.js';\nimport { multiUpdateFlexiRecord } from '../../../shared/services/api/api.js';\nimport { discoverVikingSectionMoversFlexiRecords, extractVikingSectionMoversContext } from '../../events/services/flexiRecordService.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\nimport { notifyError, notifySuccess } from '../../../shared/utils/notifications.js';\n\n/**\n *\n * @param root0\n * @param root0.term\n * @param root0.sectionSummaries\n * @param root0.sectionsData\n * @param root0.movers\n * @param root0.sectionTypeTotals\n * @param root0.onDataRefresh\n * @param root0.allTerms\n */\nfunction TermMovementCard({ term, sectionSummaries, sectionsData, movers, sectionTypeTotals, onDataRefresh, allTerms }) {\n  \n  const [sectionState, setSectionState] = useState({\n    assignments: new Map(),\n    optimisticCounts: new Map(),\n  });\n  const [isSaving, setIsSaving] = useState(false);\n  const [saveError, setSaveError] = useState(null);\n  \n  // Notification system\n  \n  const showToast = useCallback((type, message) => {\n    if (type === 'error') {\n      logger.error('Toast Error Message', {\n        message,\n        type,\n        timestamp: new Date().toISOString(),\n      }, LOG_CATEGORIES.COMPONENT);\n    }\n    \n    if (type === 'success') {\n      notifySuccess(message);\n    } else if (type === 'error') {\n      notifyError(message);\n    }\n  }, []);\n\n  // Helper function to extract FlexiRecord assignments\n  const getFlexiRecordAssignments = useCallback(() => {\n    const flexiRecordAssignments = new Map();\n    const flexiRecordCounts = new Map();\n    \n    movers.forEach(mover => {\n      if (mover.flexiRecordSection && mover.flexiRecordSection !== 'Not Known') {\n        const assignedSection = sectionsData.find(section => \n          section.sectionname === mover.flexiRecordSection ||\n          section.name === mover.flexiRecordSection,\n        );\n        \n        if (assignedSection) {\n          const assignment = {\n            memberId: mover.memberId,\n            currentSectionId: mover.currentSectionId,\n            sectionId: assignedSection.sectionid || assignedSection.sectionId,\n            sectionName: assignedSection.sectionname || assignedSection.name,\n            term: mover.flexiRecordTerm || `${term.type}-${term.year}`,\n          };\n          \n          flexiRecordAssignments.set(mover.memberId, assignment);\n          \n          const sectionIdStr = String(assignment.sectionId);\n          const currentCount = flexiRecordCounts.get(sectionIdStr) || 0;\n          flexiRecordCounts.set(sectionIdStr, currentCount + 1);\n        }\n      }\n    });\n\n    return { flexiRecordAssignments, flexiRecordCounts };\n  }, [movers, sectionsData, term.type, term.year]);\n\n  // Load saved assignments from FlexiRecord data when movers change\n  useEffect(() => {\n    if (!movers || movers.length === 0) return;\n\n    const { flexiRecordAssignments, flexiRecordCounts } = getFlexiRecordAssignments();\n\n    // Only update state if there are saved assignments to avoid unnecessary re-renders\n    if (flexiRecordAssignments.size > 0) {\n      setSectionState(_prev => ({\n        assignments: flexiRecordAssignments,\n        optimisticCounts: flexiRecordCounts,\n      }));\n    }\n  }, [movers, getFlexiRecordAssignments]);\n\n  const groupedSections = groupSectionsByType(sectionSummaries, sectionsData);\n  \n  \n  // Ensure all section types with incoming movers are included\n  const allSectionTypes = ['Squirrels', 'Beavers', 'Cubs', 'Scouts', 'Explorers'];\n  allSectionTypes.forEach(sectionType => {\n    const hasIncomingMovers = movers.some(mover => {\n      const targetSectionType = mapSectionType(mover.targetSection?.toLowerCase());\n      return targetSectionType === sectionType;\n    });\n    \n    if (hasIncomingMovers && !groupedSections.has(sectionType)) {\n      groupedSections.set(sectionType, {\n        type: sectionType,\n        sections: [],\n        totalIncoming: 0,\n        totalOutgoing: 0,\n        totalCurrent: 0,\n        totalRemaining: 0,\n      });\n    }\n  });\n  \n  const sectionTypeGroups = Array.from(groupedSections.entries()).sort(([a], [b]) => {\n    const order = ['Squirrels', 'Beavers', 'Cubs', 'Scouts', 'Explorers'];\n    return order.indexOf(a) - order.indexOf(b);\n  });\n\n  const availableSections = useMemo(() => {\n    const sections = Array.from(sectionSummaries.values()).map(summary => {\n      const sectionData = sectionsData.find(s => s.sectionId === summary.sectionId);\n      // Ensure consistent string comparison for optimistic counts\n      const sectionIdStr = String(summary.sectionId);\n      const optimisticIncoming = sectionState.optimisticCounts.get(sectionIdStr) || 0;\n      return {\n        sectionId: summary.sectionId,\n        sectionName: summary.sectionName,\n        sectionType: sectionData?.sectionType || '',\n        currentCount: summary.cumulativeCurrentCount || summary.currentMembers.length,\n        incomingCount: optimisticIncoming,\n        totalProjectedCount: (summary.cumulativeCurrentCount || summary.currentMembers.length) + optimisticIncoming,\n        maxCapacity: null,\n      };\n    });\n    \n    return sections;\n  }, [sectionSummaries, sectionsData, sectionState.optimisticCounts]);\n\n  const availableTerms = useMemo(() => {\n    // Use all terms displayed on the page instead of hardcoded list\n    return allTerms || [\n      { type: 'Spring', year: term.year },\n      { type: 'Summer', year: term.year },\n      { type: 'Autumn', year: term.year },\n      { type: 'Spring', year: term.year + 1 },\n    ];\n  }, [allTerms, term.year]);\n\n  const handleAssignmentChange = useCallback((memberId, assignment) => {\n    setSectionState(prev => {\n      const previousAssignment = prev.assignments.get(memberId);\n      \n      // Check if this is actually a change to prevent duplicate updates\n      const isSameAssignment = previousAssignment?.sectionId === assignment.sectionId;\n      if (isSameAssignment) {\n        return prev;\n      }\n      \n      // Create new state with both assignments and optimistic counts updated atomically\n      const updatedAssignments = new Map(prev.assignments);\n      const updatedCounts = new Map(prev.optimisticCounts);\n      \n      // Remove previous assignment count\n      if (previousAssignment?.sectionId) {\n        const prevSectionIdStr = String(previousAssignment.sectionId);\n        const prevCount = updatedCounts.get(prevSectionIdStr) || 0;\n        updatedCounts.set(prevSectionIdStr, Math.max(0, prevCount - 1));\n      }\n      \n      // Add new assignment count and update assignments\n      if (assignment.sectionId) {\n        const sectionIdStr = String(assignment.sectionId);\n        const newCount = updatedCounts.get(sectionIdStr) || 0;\n        updatedCounts.set(sectionIdStr, newCount + 1);\n        updatedAssignments.set(memberId, assignment);\n      } else {\n        updatedAssignments.delete(memberId);\n      }\n      \n      return {\n        assignments: updatedAssignments,\n        optimisticCounts: updatedCounts,\n      };\n    });\n  }, []);\n\n  const handleTermOverrideChange = (memberId, termOverride) => {\n    setSectionState(prev => {\n      const updatedAssignments = new Map(prev.assignments);\n      const existing = updatedAssignments.get(memberId);\n      \n      if (existing) {\n        // Update existing assignment with term override\n        updatedAssignments.set(memberId, { ...existing, term: termOverride });\n      } else if (termOverride) {\n        // Find the member's current section\n        const member = movers.find(m => m.memberId === memberId);\n        const currentSectionId = member?.currentSectionId;\n        \n        // Create new assignment with just term override (no section yet)\n        updatedAssignments.set(memberId, { \n          memberId,\n          currentSectionId,\n          sectionId: null,\n          sectionName: null,\n          term: termOverride,\n        });\n      }\n      \n      return {\n        assignments: updatedAssignments,\n        optimisticCounts: prev.optimisticCounts,\n      };\n    });\n  };\n\n  const handleSaveAssignments = async () => {\n    const assignmentsList = Array.from(sectionState.assignments.values());\n    \n    if (assignmentsList.length === 0) {\n      logger.info('No assignments to save', {}, LOG_CATEGORIES.USER_ACTION);\n      showToast('error', 'No assignments to save. Please assign members to sections first.');\n      return;\n    }\n\n    setIsSaving(true);\n    setSaveError(null);\n\n    try {\n      const token = getToken();\n      if (!token) {\n        showToast('error', 'Authentication required. Please sign in to save assignments.');\n        throw new Error('Authentication required to save assignments');\n      }\n\n      // Discover Viking Section Movers FlexiRecords to get the correct FlexiRecord ID\n      const discoveredRecords = await discoverVikingSectionMoversFlexiRecords(token);\n      if (!discoveredRecords || discoveredRecords.length === 0) {\n        showToast('error', 'No Viking Section Movers configuration found. Please contact an administrator.');\n        throw new Error('No Viking Section Movers FlexiRecords found');\n      }\n\n      // Use the first discovered FlexiRecord\n      const firstRecord = discoveredRecords[0];\n      \n      // Get preloaded structure from cache and process fieldMapping\n      const { safeGetItem } = await import('../../../shared/utils/storageUtils.js');\n      const cacheKey = `viking_flexi_structure_${firstRecord.flexiRecordId}_offline`;\n      const structureData = safeGetItem(cacheKey, null);\n      \n      if (!structureData) {\n        const errorMsg = 'FlexiRecord structure not found in cache. Please refresh the app.';\n        showToast('error', errorMsg);\n        throw new Error('FlexiRecord structure not found in cache');\n      }\n\n      // Process the raw structure to create fieldMapping like in getConsolidatedFlexiRecord\n      const { parseFlexiStructure } = await import('../../../shared/utils/flexiRecordTransforms.js');\n      const fieldMapping = parseFlexiStructure(structureData);\n      \n      // Convert fieldMapping Map to object for easier access\n      const fieldMappingObj = {};\n      fieldMapping.forEach((fieldInfo, fieldId) => {\n        fieldMappingObj[fieldId] = {\n          columnId: fieldId,\n          ...fieldInfo,\n        };\n      });\n\n      // Create structure with fieldMapping for extraction\n      const processedStructure = {\n        ...structureData,\n        fieldMapping: fieldMappingObj,\n      };\n\n      // Extract context using the processed structure\n      const context = extractVikingSectionMoversContext(\n        { _structure: processedStructure },\n        firstRecord.sectionId,\n        null, // termId not needed for field mapping\n        null,  // sectionName not needed for field mapping\n      );\n\n      if (!context) {\n        const errorMsg = 'Unable to extract FlexiRecord field mappings. Check that AssignedSection and AssignedTerm fields exist.';\n        showToast('error', errorMsg);\n        throw new Error('Could not extract FlexiRecord context for assignments');\n      }\n\n\n      // Group assignments by current section AND value (each section has different flexirecordid)\n      \n      // Group by term values per section\n      if (context.assignedTerm) {\n        const termGroups = new Map(); // Key: \"sectionId|termValue\"\n        \n        for (const assignment of assignmentsList) {\n          const termValue = assignment.term || '';\n          const memberId = assignment.memberId || assignment.scoutId;\n          const currentSectionId = assignment.currentSectionId;\n          const groupKey = `${currentSectionId}|${termValue}`;\n          \n          if (!termGroups.has(groupKey)) {\n            termGroups.set(groupKey, {\n              sectionId: currentSectionId,\n              termValue,\n              memberIds: [],\n            });\n          }\n          termGroups.get(groupKey).memberIds.push(memberId);\n        }\n\n\n        // Make one API call per unique (section, term value) combination\n        for (const group of termGroups.values()) {\n          if (group.memberIds.length > 0) {\n            // Get the correct FlexiRecord ID for this specific section\n            const sectionRecord = discoveredRecords.find(r => r.sectionId === group.sectionId);\n            const sectionFlexiRecordId = sectionRecord?.flexiRecordId;\n            \n            if (sectionFlexiRecordId) {\n              await multiUpdateFlexiRecord(\n                group.sectionId,\n                group.memberIds,\n                [group.termValue], // Single value for all members in this section\n                context.assignedTerm,\n                sectionFlexiRecordId,\n                token,\n              );\n            }\n          }\n        }\n      }\n      \n      // Group by section values per current section\n      if (context.assignedSection) {\n        const sectionGroups = new Map(); // Key: \"currentSectionId|targetSectionValue\"\n        \n        for (const assignment of assignmentsList) {\n          const sectionValue = assignment.sectionId === 'Not Known' || !assignment.sectionId \n            ? 'Not Known' \n            : assignment.sectionName || 'Not Known';\n          const memberId = assignment.memberId || assignment.scoutId;\n          const currentSectionId = assignment.currentSectionId;\n          const groupKey = `${currentSectionId}|${sectionValue}`;\n          \n          if (!sectionGroups.has(groupKey)) {\n            sectionGroups.set(groupKey, {\n              sectionId: currentSectionId,\n              sectionValue,\n              memberIds: [],\n            });\n          }\n          sectionGroups.get(groupKey).memberIds.push(memberId);\n        }\n\n        // Make one API call per unique (current section, target section value) combination\n        for (const group of sectionGroups.values()) {\n          if (group.memberIds.length > 0) {\n            // Get the correct FlexiRecord ID for this specific section\n            const sectionRecord = discoveredRecords.find(r => r.sectionId === group.sectionId);\n            const sectionFlexiRecordId = sectionRecord?.flexiRecordId;\n            \n            if (sectionFlexiRecordId) {\n              await multiUpdateFlexiRecord(\n                group.sectionId,\n                group.memberIds,\n                [group.sectionValue], // Single value for all members in this section\n                context.assignedSection,\n                sectionFlexiRecordId,\n                token,\n              );\n            }\n          }\n        }\n      }\n\n      logger.info('Section mover assignments saved successfully', {\n        assignmentCount: assignmentsList.length,\n      }, LOG_CATEGORIES.USER_ACTION);\n\n      // Show success toast\n      showToast('success', `Successfully saved ${assignmentsList.length} assignment${assignmentsList.length > 1 ? 's' : ''}`);\n\n      // Reset only manually made assignments, keep FlexiRecord assignments\n      const { flexiRecordAssignments, flexiRecordCounts } = getFlexiRecordAssignments();\n      setSectionState({\n        assignments: flexiRecordAssignments,\n        optimisticCounts: flexiRecordCounts,\n      });\n\n      // Force refresh of FlexiRecord data in the background to re-render with new assignments\n      if (onDataRefresh) {\n        setTimeout(() => {\n          onDataRefresh().catch(err => {\n            logger.warn('Background FlexiRecord refresh failed after save', {\n              error: err.message,\n            }, LOG_CATEGORIES.APP);\n          });\n        }, 500); // Small delay to allow API to process\n      }\n\n    } catch (error) {\n      logger.error('Failed to save section mover assignments', {\n        error: error.message,\n        assignmentCount: assignmentsList.length,\n      }, LOG_CATEGORIES.API);\n      \n      setSaveError(error.message);\n      showToast('error', `Failed to save assignments: ${error.message}`);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handleResetAssignments = () => {\n    // Reset only manually made assignments, keep FlexiRecord assignments\n    const { flexiRecordAssignments, flexiRecordCounts } = getFlexiRecordAssignments();\n    setSectionState({\n      assignments: flexiRecordAssignments,\n      optimisticCounts: flexiRecordCounts,\n    });\n  };\n  \n  return (\n    <div className=\"bg-white rounded-lg shadow-sm border border-gray-200\">\n      <div className=\"bg-gray-100 p-3 rounded-t-lg border-b flex items-center justify-between\">\n        <h2 className=\"text-lg font-semibold text-gray-800\">\n          {term.displayName}\n        </h2>\n        <div className=\"text-sm text-gray-500\">\n          Term starts: {new Date(term.startDate).toLocaleDateString()}\n        </div>\n      </div>\n      \n      <div className=\"p-4\">\n        {saveError && (\n          <div className=\"mb-4 p-3 bg-red-50 border border-red-200 rounded-md\">\n            <div className=\"text-sm text-red-800\">\n            Error saving assignments: {saveError}\n            </div>\n          </div>\n        )}\n      \n        {sectionTypeGroups.length === 0 ? (\n          <div className=\"text-center py-8 text-gray-500\">\n          No sections with members found for this term\n          </div>\n        ) : (\n          <div className=\"space-y-6\">\n            {sectionTypeGroups.map(([sectionType, group]) => (\n              <SectionTypeGroup\n                key={sectionType}\n                sectionType={sectionType}\n                group={group}\n                movers={movers}\n                showAssignmentInterface={true}\n                allSections={availableSections}\n                availableTerms={availableTerms}\n                assignments={sectionState.assignments}\n                currentTerm={term}\n                sectionTypeTotals={sectionTypeTotals}\n                onAssignmentChange={handleAssignmentChange}\n                onTermOverrideChange={handleTermOverrideChange}\n                onSaveAssignments={handleSaveAssignments}\n                onResetAssignments={handleResetAssignments}\n                isSaving={isSaving}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nTermMovementCard.propTypes = {\n  term: PropTypes.shape({\n    type: PropTypes.string.isRequired,\n    year: PropTypes.number.isRequired,\n    displayName: PropTypes.string,\n  }).isRequired,\n  sectionSummaries: PropTypes.arrayOf(PropTypes.object).isRequired,\n  sectionsData: PropTypes.arrayOf(PropTypes.object).isRequired,\n  movers: PropTypes.arrayOf(PropTypes.object).isRequired,\n  sectionTypeTotals: PropTypes.instanceOf(Map),\n  onDataRefresh: PropTypes.func.isRequired,\n  allTerms: PropTypes.arrayOf(PropTypes.shape({\n    type: PropTypes.string.isRequired,\n    year: PropTypes.number.isRequired,\n  })),\n};\n\nexport default TermMovementCard;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/components/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/hooks/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/hooks/useAssignmentState.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":5,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":5,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react';\n\n/**\n *\n */\nexport default function useAssignmentState() {\n  const [assignments, setAssignments] = useState(new Map());\n  const [isDraft, setIsDraft] = useState(false);\n\n  const assignMember = useCallback((memberId, sectionId, sectionName) => {\n    setAssignments(prev => {\n      const newAssignments = new Map(prev);\n      newAssignments.set(memberId, {\n        sectionId,\n        sectionName,\n        assignedAt: new Date().toISOString(),\n      });\n      return newAssignments;\n    });\n    setIsDraft(true);\n  }, []);\n\n  const unassignMember = useCallback((memberId) => {\n    setAssignments(prev => {\n      const newAssignments = new Map(prev);\n      newAssignments.delete(memberId);\n      return newAssignments;\n    });\n    setIsDraft(true);\n  }, []);\n\n  const resetAssignments = useCallback(() => {\n    setAssignments(new Map());\n    setIsDraft(false);\n  }, []);\n\n  const getAssignment = useCallback((memberId) => {\n    return assignments.get(memberId) || null;\n  }, [assignments]);\n\n  const getAllAssignments = useCallback(() => {\n    return Array.from(assignments.entries()).map(([memberId, assignment]) => ({\n      memberId,\n      ...assignment,\n    }));\n  }, [assignments]);\n\n  const getAssignmentsBySection = useCallback((sectionId) => {\n    return Array.from(assignments.entries())\n      .filter(([, assignment]) => assignment.sectionId === sectionId)\n      .map(([memberId, assignment]) => ({\n        memberId,\n        ...assignment,\n      }));\n  }, [assignments]);\n\n  const markAsSaved = useCallback(() => {\n    setIsDraft(false);\n  }, []);\n\n  return {\n    assignments,\n    isDraft,\n    assignMember,\n    unassignMember,\n    resetAssignments,\n    getAssignment,\n    getAllAssignments,\n    getAssignmentsBySection,\n    markAsSaved,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/hooks/useMovementCalculations.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"members\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"termStartDate\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sections\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useMemo, useCallback } from 'react';\nimport { calculateSectionMovements, groupMoversByTargetSection } from '../../services/sectionMovements/movementCalculator.js';\n\n/**\n *\n * @param members\n * @param termStartDate\n * @param sections\n */\nexport default function useMovementCalculations(members, termStartDate, sections = []) {\n  const [assignments, setAssignments] = useState(new Map());\n\n  const movementData = useMemo(() => {\n    if (!members || !termStartDate) {\n      return {\n        movers: [],\n        sectionSummaries: new Map(),\n        moversByTarget: new Map(),\n      };\n    }\n\n    const calculations = calculateSectionMovements(members, termStartDate, sections);\n    const moversByTarget = groupMoversByTargetSection(calculations.movers);\n\n    return {\n      movers: calculations.movers,\n      sectionSummaries: calculations.sectionSummaries,\n      moversByTarget,\n    };\n  }, [members, termStartDate, sections]);\n\n  const assignMemberToSection = useCallback((memberId, targetSectionId, targetSectionName) => {\n    if (!memberId) return;\n    \n    setAssignments(prev => {\n      const newAssignments = new Map(prev);\n      newAssignments.set(memberId, {\n        sectionId: targetSectionId,\n        sectionName: targetSectionName,\n      });\n      return newAssignments;\n    });\n  }, []);\n\n  const unassignMember = useCallback((memberId) => {\n    if (!memberId) return;\n    \n    setAssignments(prev => {\n      const newAssignments = new Map(prev);\n      newAssignments.delete(memberId);\n      return newAssignments;\n    });\n  }, []);\n\n  const resetAssignments = useCallback(() => {\n    setAssignments(new Map());\n  }, []);\n\n  const getAssignedMovers = useCallback(() => {\n    return movementData.movers.map(mover => ({\n      ...mover,\n      assignedSection: assignments.get(mover.memberId)?.sectionName || null,\n      assignedSectionId: assignments.get(mover.memberId)?.sectionId || null,\n    }));\n  }, [movementData.movers, assignments]);\n\n  const getUnassignedMovers = useCallback(() => {\n    return movementData.movers.filter(mover => !assignments.has(mover.memberId));\n  }, [movementData.movers, assignments]);\n\n  return {\n    movers: movementData.movers,\n    sectionSummaries: movementData.sectionSummaries,\n    moversByTarget: movementData.moversByTarget,\n    assignments,\n    assignMemberToSection,\n    unassignMember,\n    resetAssignments,\n    getAssignedMovers,\n    getUnassignedMovers,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/hooks/useSectionMovements.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":11,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":11,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":57,"column":11,"endLine":57,"endColumn":61,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport databaseService from '../../../shared/services/storage/database.js';\nimport { \n  discoverVikingSectionMoversFlexiRecords,\n  getVikingSectionMoversData,\n} from '../../events/services/flexiRecordService.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\nimport { fetchMostRecentTermId } from '../../../shared/services/api/api.js';\nimport logger, { LOG_CATEGORIES } from '../../../shared/services/utils/logger.js';\n\n/**\n *\n */\nexport default function useSectionMovements() {\n  const [sections, setSections] = useState([]);\n  const [members, setMembers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [flexiRecordLoadingState, setFlexiRecordLoadingState] = useState({\n    loading: false,\n    error: null,\n    loadedSections: new Set(),\n  });\n\n  useEffect(() => {\n    let isMounted = true;\n\n    const loadInitialData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Get sections data first\n        const sectionsData = await databaseService.getSections();\n        if (!isMounted) return;\n\n        setSections(sectionsData || []);\n\n        // Load Viking Section Movers FlexiRecords for all sections\n        if (sectionsData && sectionsData.length > 0) {\n          await loadFlexiRecordsForAllSections(sectionsData);\n        } else {\n          setLoading(false);\n        }\n      } catch (err) {\n        if (!isMounted) return;\n        setError(err.message);\n        setLoading(false);\n      }\n    };\n\n    loadInitialData();\n\n    return () => {\n      isMounted = false;\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Direct cache access function - bypasses API discovery when it fails\n  const loadFlexiRecordsFromDirectCache = async (sectionsData) => {\n    const allMembersData = [];\n    \n    for (const section of sectionsData) {\n      try {\n        const sectionId = section.sectionid;\n        const sectionName = section.sectionname || section.name || 'Unknown Section';\n        \n        // Check if there's cached FlexiRecord list for this section\n        const cacheKey = `viking_flexi_lists_${sectionId}_offline`;\n        const cachedList = localStorage.getItem(cacheKey);\n        \n        if (cachedList) {\n          const parsedList = JSON.parse(cachedList);\n          \n          // Find Viking Section Movers FlexiRecord\n          const vikingMoversRecord = parsedList.items?.find(record => \n            record.name === 'Viking Section Movers',\n          );\n          \n          if (vikingMoversRecord) {\n            \n            // Try to load the actual FlexiRecord data\n            const allKeys = Object.keys(localStorage);\n            const matchingDataKeys = allKeys.filter(key => \n              key.includes(`viking_flexi_data_${vikingMoversRecord.extraid}_${sectionId}_`),\n            );\n            \n            if (matchingDataKeys.length > 0) {\n              const dataKey = matchingDataKeys[0]; // Use first matching key\n              const cachedData = localStorage.getItem(dataKey);\n              \n              if (cachedData) {\n                const parsedData = JSON.parse(cachedData);\n                \n                // Add members with consistent section information\n                const membersWithSection = (parsedData.items || []).map(member => ({\n                  ...member,\n                  section_id: sectionId,\n                  sectionid: sectionId,\n                  sectionname: sectionName,\n                }));\n                \n                allMembersData.push(...membersWithSection);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`❌ Error loading direct cache for section ${section.sectionid}:`, error.message);\n      }\n    }\n    \n    return allMembersData;\n  };\n\n  const loadFlexiRecordsForAllSections = useCallback(async (sectionsData, forceRefresh = false) => {\n    setFlexiRecordLoadingState(prev => ({ ...prev, loading: true, error: null }));\n\n    try {\n      const token = getToken();\n      if (!token) {\n        logger.warn('No auth token available for loading FlexiRecords - trying offline/cached data', {}, LOG_CATEGORIES.APP);\n      }\n\n      // Discover ALL Viking Section Movers FlexiRecords once (not per section)\n      // This will work with or without token - it will use cached data when offline\n      const discoveredRecords = await discoverVikingSectionMoversFlexiRecords(token);\n      \n      if (!discoveredRecords || discoveredRecords.length === 0) {\n        logger.warn('No Viking Section Movers FlexiRecords discovered via API, trying direct cache access', {\n          sectionCount: sectionsData.length,\n        }, LOG_CATEGORIES.APP);\n        \n        // FALLBACK: Try to load data directly from cache since discovery failed\n        const directCacheResults = await loadFlexiRecordsFromDirectCache(sectionsData);\n        if (directCacheResults.length > 0) {\n          logger.info('Successfully loaded Viking Section Movers from direct cache', {\n            recordCount: directCacheResults.length,\n          }, LOG_CATEGORIES.APP);\n          \n          setMembers(directCacheResults);\n          setFlexiRecordLoadingState({ \n            loading: false, \n            error: null, \n            loadedSections: new Set(directCacheResults.map(m => m.section_id)), \n          });\n          setLoading(false);\n          return;\n        }\n        \n        setFlexiRecordLoadingState(prev => ({ ...prev, loading: false }));\n        setLoading(false);\n        return;\n      }\n\n      logger.info('Discovered Viking Section Movers FlexiRecords', {\n        totalDiscovered: discoveredRecords.length,\n        recordsBySection: discoveredRecords.map(r => ({\n          sectionId: r.sectionId,\n          sectionName: r.sectionName,\n        })),\n      }, LOG_CATEGORIES.APP);\n\n      const allMembersData = [];\n      const loadedSections = new Set();\n\n      // Process each discovered FlexiRecord with its section's most recent term ID\n      for (const record of discoveredRecords) {\n        try {\n          // Get the most recent term ID for THIS FlexiRecord's section\n          const sectionTermId = await fetchMostRecentTermId(record.sectionId, token);\n          \n          if (!sectionTermId) {\n            logger.warn('Could not get most recent term ID for FlexiRecord section', {\n              sectionId: record.sectionId,\n              sectionName: record.sectionName,\n            }, LOG_CATEGORIES.APP);\n            continue;\n          }\n\n          // Load member data from this specific FlexiRecord\n          const flexiData = await getVikingSectionMoversData(record.sectionId, sectionTermId, token, forceRefresh);\n          const members = flexiData?.items || [];\n          \n          logger.info('Loaded members from FlexiRecord', {\n            sectionId: record.sectionId,\n            sectionName: record.sectionName,\n            memberCount: members.length,\n            termId: sectionTermId,\n          }, LOG_CATEGORIES.APP);\n          \n          // Add members with consistent section information\n          const membersWithSection = members.map(member => ({\n            ...member,\n            section_id: record.sectionId,\n            sectionid: record.sectionId,\n            sectionname: record.sectionName,\n          }));\n\n          allMembersData.push(...membersWithSection);\n          loadedSections.add(record.sectionId);\n        } catch (error) {\n          logger.warn('Failed to load members from FlexiRecord', {\n            sectionId: record.sectionId,\n            sectionName: record.sectionName,\n            error: error.message,\n          }, LOG_CATEGORIES.APP);\n        }\n      }\n\n      logger.info('Completed loading Viking Section Movers FlexiRecords for all sections', {\n        totalSections: sectionsData.length,\n        totalMembersLoaded: allMembersData.length,\n        sectionsWithData: loadedSections.size,\n      }, LOG_CATEGORIES.APP);\n\n      setMembers(allMembersData);\n      setFlexiRecordLoadingState({ \n        loading: false, \n        error: null, \n        loadedSections, \n      });\n      setLoading(false);\n\n    } catch (error) {\n      logger.error('Error loading FlexiRecords for all sections', {\n        error: error.message,\n        sectionCount: sectionsData.length,\n      }, LOG_CATEGORIES.ERROR);\n      \n      setFlexiRecordLoadingState({ \n        loading: false, \n        error: error.message, \n        loadedSections: new Set(), \n      });\n      setError(error.message);\n      setLoading(false);\n    }\n  }, [setFlexiRecordLoadingState, setMembers, setLoading, setError]);\n\n\n  const refetch = async () => {\n    setLoading(true);\n    setError(null);\n    setFlexiRecordLoadingState({ loading: false, error: null, loadedSections: new Set() });\n    \n    try {\n      const sectionsData = await databaseService.getSections();\n      setSections(sectionsData || []);\n      \n      // Reload FlexiRecord data for all sections with forceRefresh = true\n      if (sectionsData && sectionsData.length > 0) {\n        await loadFlexiRecordsForAllSections(sectionsData, true);\n      } else {\n        setLoading(false);\n      }\n    } catch (err) {\n      setError(err.message);\n      setLoading(false);\n    }\n  };\n\n  return {\n    sections,\n    members,\n    loading: loading || flexiRecordLoadingState.loading,\n    error: error || flexiRecordLoadingState.error,\n    refetch,\n    // FlexiRecord loading information for debugging\n    flexiRecordState: flexiRecordLoadingState,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/hooks/useVikingSectionMovers.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":11,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":11,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionId\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"termId\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport { \n  discoverVikingSectionMoversFlexiRecords,\n  getVikingSectionMoversData,\n  extractVikingSectionMoversContext,\n  validateVikingSectionMoversCollection,\n} from '../services/flexiRecordService.js';\nimport { getToken } from '../services/auth.js';\nimport logger, { LOG_CATEGORIES } from '../services/logger.js';\n\n/**\n *\n * @param sectionId\n * @param termId\n */\nexport function useVikingSectionMovers(sectionId, termId) {\n  // Core data state\n  const [discoveredFlexiRecords, setDiscoveredFlexiRecords] = useState([]);\n  const [fieldMappings, setFieldMappings] = useState(new Map());\n  const [validationResults, setValidationResults] = useState(null);\n  \n  // Loading and error state\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Validation and status state\n  const [validationStatus, setValidationStatus] = useState({ \n    isValid: true,\n    discoveredCount: 0,\n    validCount: 0,\n    invalidCount: 0,\n  });\n  \n  // Cache and refresh state\n  const [lastFetch, setLastFetch] = useState(null);\n  const [cacheStatus, setCacheStatus] = useState('empty');\n\n  const discoverAndMapFlexiRecords = useCallback(async (forceRefresh = false) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      setCacheStatus('loading');\n\n      const token = getToken();\n        \n      // Step 1: Discover all Viking Section Movers FlexiRecords\n      const discovered = await discoverVikingSectionMoversFlexiRecords(token, forceRefresh);\n\n      // Step 2: Extract field mappings for each discovered FlexiRecord\n      const mappingPromises = discovered.map(async (discoveredRecord) => {\n        try {\n          // Get the full FlexiRecord data for field mapping\n          const flexiRecordData = await getVikingSectionMoversData(\n            discoveredRecord.sectionId,\n            termId,\n            token,\n            forceRefresh,\n          );\n\n          if (flexiRecordData) {\n            // Extract field mapping context\n            const fieldContext = extractVikingSectionMoversContext(\n              flexiRecordData,\n              discoveredRecord.sectionId,\n              termId,\n              discoveredRecord.sectionName,\n            );\n\n            return {\n              sectionId: discoveredRecord.sectionId,\n              fieldContext,\n            };\n          }\n\n          return { sectionId: discoveredRecord.sectionId, fieldContext: null };\n        } catch (err) {\n          logger.warn('Failed to extract field mapping for section', {\n            sectionId: discoveredRecord.sectionId,\n            sectionName: discoveredRecord.sectionName,\n            error: err.message,\n          }, LOG_CATEGORIES.APP);\n\n          return { sectionId: discoveredRecord.sectionId, fieldContext: null };\n        }\n      });\n\n      const mappingResults = await Promise.all(mappingPromises);\n\n      // Build field mappings Map\n      const mappings = new Map();\n      mappingResults.forEach(({ sectionId, fieldContext }) => {\n        if (fieldContext) {\n          mappings.set(sectionId, fieldContext);\n        }\n      });\n\n      setDiscoveredFlexiRecords(discovered);\n      setFieldMappings(mappings);\n        \n      // Step 3: Validate the discovered FlexiRecords and field mappings\n      const validation = validateVikingSectionMoversCollection(discovered, mappings);\n      setValidationResults(validation);\n        \n      const newValidationStatus = {\n        isValid: validation.isValid,\n        discoveredCount: discovered.length,\n        validCount: validation.summary.valid,\n        invalidCount: validation.summary.invalid,\n        sections: discovered.map(d => d.sectionName),\n        validSections: validation.validRecords.map(r => r.sectionName),\n        invalidSections: validation.invalidRecords.map(r => ({\n          sectionName: r.sectionName,\n          error: r.validationError,\n        })),\n      };\n        \n      setValidationStatus(newValidationStatus);\n      setLastFetch(new Date().toISOString());\n      setCacheStatus(validation.isValid ? 'loaded' : 'error');\n\n      logger.info('Viking Section Movers discovery, mapping, and validation completed', {\n        discoveredCount: discovered.length,\n        validCount: validation.summary.valid,\n        invalidCount: validation.summary.invalid,\n        sectionId,\n        termId,\n        cacheStatus: validation.isValid ? 'loaded' : 'error',\n      }, LOG_CATEGORIES.APP);\n\n    } catch (err) {\n      logger.error('Failed to discover and map Viking Section Movers FlexiRecords', {\n        error: err.message,\n        sectionId,\n        termId,\n      }, LOG_CATEGORIES.ERROR);\n\n      setError(err.message);\n      setValidationStatus({ isValid: false, error: err.message, discoveredCount: 0, validCount: 0, invalidCount: 0 });\n      setCacheStatus('error');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sectionId, termId]);\n\n  useEffect(() => {\n    const loadData = async () => {\n      await discoverAndMapFlexiRecords();\n    };\n\n    loadData();\n  }, [sectionId, termId, discoverAndMapFlexiRecords]);\n\n  const validateFlexiRecord = async () => {\n    return validationStatus;\n  };\n\n  const getFieldMappingForSection = (targetSectionId) => {\n    return fieldMappings.get(targetSectionId) || null;\n  };\n\n  const refreshData = async () => {\n    await discoverAndMapFlexiRecords(true);\n  };\n\n  const getCacheAge = () => {\n    if (!lastFetch) return null;\n    return Date.now() - new Date(lastFetch).getTime();\n  };\n\n  const shouldRefreshCache = (maxAgeMs = 5 * 60 * 1000) => {\n    const age = getCacheAge();\n    return age === null || age > maxAgeMs;\n  };\n\n  return {\n    discoveredFlexiRecords,\n    fieldMappings,\n    validationResults,\n    validationStatus,\n    fieldMapping: fieldMappings, // For backward compatibility\n    isLoading,\n    error,\n    lastFetch,\n    cacheStatus,\n    validateFlexiRecord,\n    getFieldMappingForSection,\n    refreshData,\n    getCacheAge,\n    shouldRefreshCache,\n    isValid: validationStatus.isValid,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/services/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/services/movementCalculator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/movements/services/vikingSectionMoversValidation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/components/MedicalDataDisplay.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":5,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.value\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.fieldName\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.data\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.type\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":58,"column":1,"nodeType":"Block","endLine":63,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":58,"column":1,"nodeType":"Block","endLine":63,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":60,"column":1,"nodeType":"Block","endLine":60,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.medicalData\" description.","line":61,"column":1,"nodeType":"Block","endLine":61,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":62,"column":1,"nodeType":"Block","endLine":62,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":85,"column":1,"nodeType":"Block","endLine":90,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":85,"column":1,"nodeType":"Block","endLine":90,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":87,"column":1,"nodeType":"Block","endLine":87,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.member\" description.","line":88,"column":1,"nodeType":"Block","endLine":88,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":89,"column":1,"nodeType":"Block","endLine":89,"endColumn":1}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport { formatMedicalDataForDisplay } from '../../../shared/utils/medicalDataUtils.js';\n\n/**\n *\n * @param root0\n * @param root0.value\n * @param root0.fieldName\n * @param root0.data\n * @param root0.type\n * @param root0.className\n */\nexport function MedicalDataPill({ value, fieldName, data, type = 'info', className = '' }) {\n  \n  // If using the new format with value/fieldName, process the data\n  let displayData, pillStyles;\n  if (value !== undefined && fieldName) {\n    const formatted = formatMedicalDataForDisplay(value, fieldName);\n    displayData = formatted.display;\n    \n    // Use the indicator styles from the medical data utilities\n    if (formatted.indicator.showPill) {\n      pillStyles = formatted.indicator.pillColor;\n    } else {\n      // For \"None\" cases that don't show a pill, just show text\n      return <span className={`text-xs ${className}`}>{formatted.display}</span>;\n    }\n  } else {\n    // Fall back to original data/type format for backward compatibility\n    displayData = data;\n    const getTypeStyles = (type) => {\n      switch (type) {\n      case 'warning':\n        return 'bg-yellow-100 text-yellow-800 border-yellow-200';\n      case 'danger':\n        return 'bg-red-100 text-red-800 border-red-200';\n      case 'success':\n        return 'bg-green-100 text-green-800 border-green-200';\n      default:\n        return 'bg-blue-100 text-blue-800 border-blue-200';\n      }\n    };\n    pillStyles = getTypeStyles(type);\n  }\n\n  if (!displayData && displayData !== '---') {\n    return null;\n  }\n\n  return (\n    <span className={`inline-flex items-center px-2 py-1 rounded text-xs font-medium ${pillStyles} ${className}`}>\n      {displayData}\n    </span>\n  );\n}\n\n/**\n *\n * @param root0\n * @param root0.medicalData\n * @param root0.className\n */\nexport function MedicalDataList({ medicalData, className = '' }) {\n  if (!medicalData || medicalData.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={`space-y-2 ${className}`}>\n      <h4 className=\"text-sm font-medium text-gray-700\">Medical Information</h4>\n      <div className=\"space-y-1\">\n        {medicalData.map((item, index) => (\n          <MedicalDataPill \n            key={index} \n            data={item.condition || item.text || item} \n            type={item.severity || 'info'}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n/**\n *\n * @param root0\n * @param root0.member\n * @param root0.className\n */\nfunction MedicalDataDisplay({ member, className = '' }) {\n  if (!member || !member.medicalData) {\n    return null;\n  }\n\n  return (\n    <div className={`medical-data-display ${className}`}>\n      <MedicalDataList medicalData={member.medicalData} />\n    </div>\n  );\n}\n\nMedicalDataPill.propTypes = {\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n  fieldName: PropTypes.string,\n  data: PropTypes.string,\n  type: PropTypes.oneOf(['info', 'warning', 'danger', 'success']),\n  className: PropTypes.string,\n};\n\nMedicalDataList.propTypes = {\n  medicalData: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        condition: PropTypes.string,\n        text: PropTypes.string,\n        severity: PropTypes.string,\n      }),\n    ]),\n  ),\n  className: PropTypes.string,\n};\n\nMedicalDataDisplay.propTypes = {\n  member: PropTypes.shape({\n    medicalData: PropTypes.array,\n  }),\n  className: PropTypes.string,\n};\n\nexport default MedicalDataDisplay;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/components/SectionCardsFlexMasonry.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/components/SectionFilter.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":12,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, memo } from 'react';\n\n/**\n * SectionFilter - Reusable pill-based filter for sections\n * Provides toggle buttons for filtering by section similar to attendance status filters\n *\n * @param {object} props - Component props\n * @param {object} props.sectionFilters - Object mapping section IDs to boolean visibility\n * @param {Function} props.onFiltersChange - Callback when filters change\n * @param {Array} props.sections - Array of section objects with sectionid and sectionname\n * @param {string} props.className - Additional CSS classes\n */\nfunction SectionFilter({\n  sectionFilters,\n  onFiltersChange,\n  sections,\n  className = '',\n}) {\n  const handleFilterToggle = useCallback((sectionId) => {\n    if (!sectionId || typeof onFiltersChange !== 'function') return;\n    \n    const newFilters = {\n      ...sectionFilters,\n      [sectionId]: !sectionFilters[sectionId],\n    };\n    onFiltersChange(newFilters);\n  }, [sectionFilters, onFiltersChange]);\n\n  // Get section color based on section type (matching dashboard colors)\n  const getSectionColor = useCallback((section) => {\n    if (!section) {\n      return 'bg-scout-purple text-white border-scout-purple';\n    }\n    \n    // Try to determine section type from sectionname or section field\n    const sectionType = (\n      section.section ||\n      section.sectionname ||\n      ''\n    ).toLowerCase();\n\n    if (sectionType.includes('earlyyears'))\n      return 'bg-scout-red text-white border-scout-red';\n    if (sectionType.includes('beavers'))\n      return 'bg-scout-blue text-white border-scout-blue';\n    if (sectionType.includes('cubs'))\n      return 'bg-scout-forest-green text-white border-scout-forest-green';\n    if (sectionType.includes('scouts'))\n      return 'bg-scout-navy text-white border-scout-navy';\n    if (sectionType.includes('adults'))\n      return 'bg-scout-purple text-white border-scout-purple';\n    if (sectionType.includes('waitinglist'))\n      return 'bg-scout-teal text-white border-scout-teal';\n\n    // Default fallback to purple for unknown sections\n    return 'bg-scout-purple text-white border-scout-purple';\n  }, []);\n\n  if (!sections || sections.length === 0) {\n    return null;\n  }\n\n  return (\n    <div\n      className={`flex gap-2 flex-wrap items-center ${className}`}\n      role=\"group\"\n      aria-label=\"Section filters\"\n      data-oid=\"oh13yim\"\n    >\n      {/* Individual section filters */}\n      {sections.map((section) => {\n        const isActive = sectionFilters[section.sectionid];\n        const activeStyles = getSectionColor(section);\n        const colorName = activeStyles.match(/bg-scout-([\\w-]+)/)?.[1];\n        const inactiveStyles = colorName \n          ? `bg-white text-scout-${colorName} border-2 border-scout-${colorName}`\n          : 'bg-white text-gray-600 border-2 border-gray-300';\n\n        return (\n          <button\n            key={section.sectionid}\n            onClick={() => handleFilterToggle(section.sectionid)}\n            className={`px-3 py-1 text-xs font-medium rounded-full transition-all duration-200 hover:shadow-sm ${\n              isActive ? activeStyles : inactiveStyles\n            }`}\n            type=\"button\"\n            aria-pressed={isActive}\n            aria-label={`Filter by ${section.sectionname} section`}\n            title={section.sectionname}\n            data-oid=\"7y4f3-0\"\n          >\n            {section.sectionname}\n          </button>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(SectionFilter);\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/components/SectionsList.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":11,"column":1,"nodeType":"Block","endLine":19,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":11,"column":1,"nodeType":"Block","endLine":19,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sections\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.selectedSections\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSectionToggle\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.loadingSection\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.allSections\" description.","line":18,"column":1,"nodeType":"Block","endLine":18,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":72,"column":1,"nodeType":"Block","endLine":79,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":72,"column":1,"nodeType":"Block","endLine":79,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":74,"column":1,"nodeType":"Block","endLine":74,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.sections\" description.","line":75,"column":1,"nodeType":"Block","endLine":75,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onSectionToggle\" description.","line":76,"column":1,"nodeType":"Block","endLine":76,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.allSections\" description.","line":77,"column":1,"nodeType":"Block","endLine":77,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.loadingSection\" description.","line":78,"column":1,"nodeType":"Block","endLine":78,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":289,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":289,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":301,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":301,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":301,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":301,"endColumn":27}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { getListOfMembers } from '../../../shared/services/api/api.js';\nimport { getToken } from '../../../shared/services/auth/tokenService.js';\nimport { MemberDetailModal, MedicalDataPill } from '../../../shared/components/ui';\nimport LoadingScreen from '../../../shared/components/LoadingScreen.jsx';\nimport { formatMedicalDataForDisplay } from '../../../shared/utils/medicalDataUtils.js';\nimport { calculateAge } from '../../../shared/utils/ageUtils.js';\nimport { groupContactInfo } from '../../../shared/utils/contactGroups.js';\nimport { notifyError, notifySuccess, notifyWarning } from '../../../shared/utils/notifications.js';\n\n/**\n *\n * @param root0\n * @param root0.sections\n * @param root0.selectedSections\n * @param root0.onSectionToggle\n * @param root0.loadingSection\n * @param root0.allSections\n */\nfunction SectionsList({\n  sections,\n  selectedSections = [],\n  onSectionToggle,\n  loadingSection = null,\n  allSections,\n}) {\n  \n  if (!sections || sections.length === 0) {\n    return (\n      <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"de.aoaz\">\n        <div className=\"text-center p-8\" data-oid=\"ry9t81c\">\n          <h2\n            className=\"text-xl font-semibold text-gray-900 mb-2\"\n            data-oid=\"a4t6f:.\"\n          >\n            No Sections Available\n          </h2>\n          <p className=\"text-gray-600\" data-oid=\"fbi04qa\">\n            No sections found for your account. Please check your OSM\n            permissions.\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n\n\n\n  return (\n    <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"2c.s3hh\">\n      <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"d7c-ou8\">\n        <div className=\"flex items-center justify-between\">\n          <h2 className=\"text-lg font-semibold text-gray-900 m-0\" data-oid=\"solgnx_\">Select Sections</h2>\n        </div>\n      </div>\n\n      {/* Members Area - Always show the table */}\n      <div className=\"p-4 border-t border-gray-200\">\n        <MembersTableContent\n          sections={selectedSections}\n          onSectionToggle={onSectionToggle}\n          allSections={allSections}\n          loadingSection={loadingSection}\n        />\n      </div>\n    </div>\n  );\n}\n\n// Members Table Content - Integrated into main card\n/**\n *\n * @param root0\n * @param root0.sections\n * @param root0.onSectionToggle\n * @param root0.allSections\n * @param root0.loadingSection\n */\nfunction MembersTableContent({ sections, onSectionToggle, allSections, loadingSection }) {\n  const [members, setMembers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [selectedMember, setSelectedMember] = useState(null);\n  const [showMemberModal, setShowMemberModal] = useState(false);\n  \n  \n  // Data filter state - for controlling which columns to show\n  const [dataFilters, setDataFilters] = useState({\n    contacts: false, // Primary and Emergency contacts (hidden by default as requested)\n  });\n\n  // Load members when sections change\n  useEffect(() => {\n    const loadMembers = async () => {\n      if (!sections || sections.length === 0) {\n        setMembers([]);\n        setLoading(false);\n        return;\n      }\n\n      try {\n        setLoading(true);\n        const token = getToken();\n        const membersData = await getListOfMembers(sections, token);\n        setMembers(membersData || []);\n      } catch (error) {\n        console.error('Failed to load members:', error);\n        setMembers([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadMembers();\n  }, [sections]);\n\n  // Use shared groupContactInfo utility\n\n  // Extract comprehensive member data (same as AttendanceView)\n  const getComprehensiveMemberData = (member) => {\n    const contactGroups = groupContactInfo(member);\n    \n    // Helper to get field from any group\n    const getField = (groupNames, fieldNames) => {\n      for (const groupName of Array.isArray(groupNames) ? groupNames : [groupNames]) {\n        const group = contactGroups[groupName];\n        if (group) {\n          for (const fieldName of Array.isArray(fieldNames) ? fieldNames : [fieldNames]) {\n            if (group[fieldName]) return group[fieldName];\n          }\n        }\n      }\n      return '';\n    };\n\n    // Helper to combine multiple fields\n    const combineFields = (groupNames, fieldNames, separator = ', ') => {\n      const values = [];\n      for (const groupName of Array.isArray(groupNames) ? groupNames : [groupNames]) {\n        const group = contactGroups[groupName];\n        if (group) {\n          for (const fieldName of Array.isArray(fieldNames) ? fieldNames : [fieldNames]) {\n            if (group[fieldName]) values.push(group[fieldName]);\n          }\n        }\n      }\n      return values.join(separator);\n    };\n\n    return {\n      // Basic info\n      name: `${member.firstname || member.first_name} ${member.lastname || member.last_name}`,\n      section: member.sections?.[0] || 'Unknown',\n      patrol: member.patrol || '',\n      age: calculateAge(member.date_of_birth),\n      \n      // Primary Contacts (1 and 2)\n      primary_contacts: (() => {\n        const contacts = [];\n        \n        // Primary Contact 1\n        const pc1_name = combineFields(['primary_contact_1'], ['first_name', 'last_name'], ' ') || '';\n        const pc1_phone = combineFields(['primary_contact_1'], ['phone_1', 'phone_2']) || '';\n        const pc1_email = combineFields(['primary_contact_1'], ['email_1', 'email_2']) || '';\n        \n        if (pc1_name || pc1_phone || pc1_email) {\n          contacts.push({ name: pc1_name, phone: pc1_phone, email: pc1_email, label: 'PC1' });\n        }\n        \n        // Primary Contact 2\n        const pc2_name = combineFields(['primary_contact_2'], ['first_name', 'last_name'], ' ') || '';\n        const pc2_phone = combineFields(['primary_contact_2'], ['phone_1', 'phone_2']) || '';\n        const pc2_email = combineFields(['primary_contact_2'], ['email_1', 'email_2']) || '';\n        \n        if (pc2_name || pc2_phone || pc2_email) {\n          contacts.push({ name: pc2_name, phone: pc2_phone, email: pc2_email, label: 'PC2' });\n        }\n        \n        return contacts;\n      })(),\n      \n      // Emergency Contacts\n      emergency_contacts: (() => {\n        const contacts = [];\n        \n        // Emergency Contact\n        const ec_name = combineFields(['emergency_contact'], ['first_name', 'last_name'], ' ') || '';\n        const ec_phone = combineFields(['emergency_contact'], ['phone_1', 'phone_2']) || '';\n        \n        if (ec_name || ec_phone) {\n          contacts.push({ name: ec_name, phone: ec_phone, label: 'Emergency' });\n        }\n        \n        return contacts;\n      })(),\n      \n      // Essential Information (comprehensive approach)\n      essential_information: contactGroups.essential_information || {},\n      allergies: contactGroups.essential_information?.allergies || '',\n      medical_details: contactGroups.essential_information?.medical_details || '',\n      dietary_requirements: contactGroups.essential_information?.dietary_requirements || '',\n      tetanus_year_of_last_jab: contactGroups.essential_information?.tetanus_year_of_last_jab || '',\n      swimmer: contactGroups.essential_information?.swimmer || '',\n      other_useful_information: contactGroups.essential_information?.other_useful_information || '',\n      confirmed_by_parents: contactGroups.essential_information?.confirmed_by_parents || '',\n      \n      // Consents\n      consent_photos: getField(['consents'], ['photographs', 'photos']) || '',\n      consent_sensitive: getField(['consents'], ['sensitive_information']) || '',\n      consent_paracetamol: getField(['consents'], ['paracetamol']) || '',\n      consent_ibuprofen: getField(['consents'], ['ibuprofen']) || '',\n      consent_suncream: getField(['consents'], ['suncream', 'sun_cream']) || '',\n    };\n  };\n\n  // Handle member click\n  const handleMemberClick = (member) => {\n    setSelectedMember(member);\n    setShowMemberModal(true);\n  };\n\n  // Handle modal close\n  const handleModalClose = () => {\n    setShowMemberModal(false);\n    setSelectedMember(null);\n  };\n\n  // CSV Export function\n  const exportToCSV = () => {\n    if (members.length === 0) {\n      notifyWarning('No members to export');\n      return;\n    }\n\n    try {\n      const headers = [\n        'First Name',\n        'Last Name',\n        'Section',\n        'Patrol',\n        'Age',\n        'Allergies',\n        'Medical Details', \n        'Dietary Requirements',\n        'Tetanus Year',\n        'Swimmer',\n        'Other Info',\n        'Confirmed By',\n        'Photo Consent',\n        'Sensitive Info Consent',\n        'Paracetamol Consent',\n        'Ibuprofen Consent',\n        'Suncream Consent',\n      ];\n\n      const csv = (v) => `\"${String(v ?? '').replace(/\"/g, '\"\"')}\"`;\n      const csvRows = [\n        headers.map(csv).join(','),\n        ...members.map((member) => {\n          const memberData = getComprehensiveMemberData(member);\n          \n          return [\n            csv(member.firstname),\n            csv(member.lastname),\n            csv(member.sections?.[0] || 'Unknown'),\n            csv(memberData.patrol),\n            csv(memberData.age),\n            csv(formatMedicalDataForDisplay(memberData.allergies, 'allergies').csvValue),\n            csv(formatMedicalDataForDisplay(memberData.medical_details, 'medical_details').csvValue),\n            csv(formatMedicalDataForDisplay(memberData.dietary_requirements, 'dietary_requirements').csvValue),\n            csv(formatMedicalDataForDisplay(memberData.tetanus_year_of_last_jab, 'tetanus_year_of_last_jab').csvValue),\n            csv(formatMedicalDataForDisplay(memberData.swimmer, 'swimmer').csvValue),\n            csv(formatMedicalDataForDisplay(memberData.other_useful_information, 'other_useful_information').csvValue),\n            csv(formatMedicalDataForDisplay(memberData.confirmed_by_parents, 'confirmed_by_parents').csvValue),\n            csv(memberData.consent_photos || '---'),\n            csv(memberData.consent_sensitive || '---'),\n            csv(memberData.consent_paracetamol || '---'),\n            csv(memberData.consent_ibuprofen || '---'),\n            csv(memberData.consent_suncream || '---'),\n          ].join(',');\n        }),\n      ];\n\n      const csvContent = '\\uFEFF' + csvRows.join('\\n');\n      const blob = new globalThis.Blob([csvContent], {\n        type: 'text/csv;charset=utf-8;',\n      });\n      const link = document.createElement('a');\n      const url = URL.createObjectURL(blob);\n      link.setAttribute('href', url);\n      \n      const sectionNames = sections.map(s => s.sectionname).join('_');\n      const safeSectionNames = sectionNames.replace(/[^a-zA-Z0-9]/g, '_');\n      const dateStr = new Date().toISOString().split('T')[0];\n      \n      link.setAttribute('download', `sections_members_${safeSectionNames}_${dateStr}.csv`);\n      link.style.visibility = 'hidden';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      setTimeout(() => URL.revokeObjectURL(url), 0);\n      \n      notifySuccess(`Exported ${members.length} member records`);\n    } catch (error) {\n      console.error('Error exporting CSV:', error);\n      notifyError('Failed to export member data');\n    }\n  };\n\n  if (loading) {\n    return <LoadingScreen message=\"Loading members...\" />;\n  }\n\n  return (\n    <div>\n      {/* Header with Export Button */}\n      <div className=\"flex items-center justify-between mb-4\">\n        <h4 className=\"text-lg font-medium text-gray-900\">Members ({members.length})</h4>\n        {members.length > 0 && (\n          <button\n            onClick={exportToCSV}\n            type=\"button\"\n            className=\"inline-flex items-center justify-center rounded-md font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed border-2 border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-gray-300 px-4 py-2 text-base\"\n          >\n            <svg\n              className=\"w-4 h-4 mr-2\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n            >\n              <path d=\"M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n            </svg>\n            Export CSV\n          </button>\n        )}\n      </div>\n\n      {/* Filter Section */}\n      <div className=\"space-y-3 mb-4 p-3 bg-gray-50 rounded border-b border-gray-200\">\n        <div className=\"flex flex-col sm:flex-row gap-3\">\n          <div className=\"flex-1\">\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Sections:\n            </label>\n            <div className=\"flex flex-wrap gap-2\">\n              {allSections && allSections\n                .slice()\n                .sort((a, b) => {\n                  const getSectionOrder = (sectionType) => {\n                    const type = sectionType.toLowerCase();\n                    if (type.includes('earlyyears')) return 1;\n                    if (type.includes('beavers')) return 2;\n                    if (type.includes('cubs')) return 3;\n                    if (type.includes('scouts')) return 4;\n                    if (type.includes('adults')) return 5;\n                    if (type.includes('waitinglist')) return 6;\n                    return 7;\n                  };\n                  const getDayOrder = (sectionName) => {\n                    const name = sectionName.toLowerCase();\n                    if (name.includes('monday')) return 1;\n                    if (name.includes('tuesday')) return 2;\n                    if (name.includes('wednesday')) return 3;\n                    if (name.includes('thursday')) return 4;\n                    if (name.includes('friday')) return 5;\n                    if (name.includes('saturday')) return 6;\n                    if (name.includes('sunday')) return 7;\n                    return 8;\n                  };\n                  const ao = getSectionOrder(a.section);\n                  const bo = getSectionOrder(b.section);\n                  return ao !== bo ? ao - bo : getDayOrder(a.sectionname) - getDayOrder(b.sectionname);\n                })\n                .map((section) => {\n                  const isSelected = sections.some(s => s.sectionid === section.sectionid);\n                  const isLoading = loadingSection === section.sectionid;\n                  \n                  return (\n                    <button\n                      key={section.sectionid}\n                      onClick={() => onSectionToggle(section)}\n                      disabled={isLoading}\n                      className={`px-3 py-1 rounded-md text-sm font-medium border transition-colors ${\n                        isSelected\n                          ? 'bg-scout-blue text-white border-scout-blue'\n                          : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'\n                      }`}\n                      type=\"button\"\n                    >\n                      {isLoading ? '...' : section.sectionname}\n                    </button>\n                  );\n                })}\n            </div>\n          </div>\n          <div className=\"flex-1\">\n            <label className=\"block text-sm font-medium text-gray-700 mb-2\">\n                Data:\n            </label>\n            <div className=\"flex flex-wrap gap-2\">\n              <button\n                onClick={() => setDataFilters(prev => ({ ...prev, contacts: !prev.contacts }))}\n                className={`px-3 py-1 rounded-md text-sm font-medium border transition-colors ${\n                  dataFilters.contacts\n                    ? 'bg-scout-blue text-white border-scout-blue'\n                    : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'\n                }`}\n                type=\"button\"\n              >\n                  Contacts\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n        \n      {members.length === 0 ? (\n        <div className=\"bg-white rounded-lg border border-gray-200 p-8 text-center\">\n          <p className=\"text-gray-500\">No members found for the selected sections.</p>\n        </div>\n      ) : (\n        <div className=\"overflow-x-auto\">\n          <table className=\"min-w-full divide-y divide-gray-200\">\n            <thead className=\"bg-gray-50\">\n              <tr>\n                {/* Basic Info Headers */}\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider sticky left-0 bg-gray-50\">\n                Member\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                Section\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                Patrol\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                Age\n                </th>\n              \n                {/* Contact Info Headers - conditionally shown */}\n                {dataFilters.contacts && (\n                  <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-blue-50\">\n                  Primary Contacts\n                  </th>\n                )}\n              \n                {/* Emergency Contact Headers - conditionally shown */}\n                {dataFilters.contacts && (\n                  <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-red-50\">\n                  Emergency Contacts\n                  </th>\n                )}\n              \n                {/* Essential Information Headers */}\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Allergies\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Medical\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Dietary\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Tetanus\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Swimmer\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Other Info\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-orange-50 w-32\">\n                Confirmed By\n                </th>\n              \n                {/* Consent Headers */}\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Photos\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Sensitive Info\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Paracetamol\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Ibuprofen\n                </th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-green-50\">\n                Suncream\n                </th>\n              </tr>\n            </thead>\n            <tbody className=\"bg-white divide-y divide-gray-200\">\n              {members.map((member, index) => {\n              // Get comprehensive member data\n                const memberData = getComprehensiveMemberData(member);\n\n                return (\n                  <tr key={member.scoutid || index} className=\"hover:bg-gray-50 text-xs\">\n                    {/* Basic Info Cells */}\n                    <td className=\"px-3 py-2 whitespace-nowrap sticky left-0 bg-white\">\n                      <button\n                        onClick={() => handleMemberClick(member)}\n                        className=\"font-semibold text-scout-blue hover:text-scout-blue-dark cursor-pointer transition-colors text-left\"\n                      >\n                        {memberData.name}\n                      </button>\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-gray-900\">\n                      {memberData.section}\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-gray-900\">\n                      {memberData.patrol}\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-gray-900\">\n                      {memberData.age}\n                    </td>\n                  \n                    {/* Contact Info Cells - conditionally shown */}\n                    {dataFilters.contacts && (\n                      <td className=\"px-3 py-2 whitespace-nowrap text-gray-900 bg-blue-25\">\n                        {memberData.primary_contacts.length > 0 ? (\n                          <div className=\"space-y-1\">\n                            {memberData.primary_contacts.map((contact, index) => (\n                              <div key={index} className=\"text-xs\">\n                                <div className=\"font-medium\">{contact.label}: {contact.name}</div>\n                                {contact.phone && <div className=\"text-gray-600\">📞 {contact.phone}</div>}\n                                {contact.email && <div className=\"text-gray-600\">📧 {contact.email}</div>}\n                              </div>\n                            ))}\n                          </div>\n                        ) : (\n                          <span className=\"text-gray-400\">None</span>\n                        )}\n                      </td>\n                    )}\n                  \n                    {/* Emergency Contact Cells - conditionally shown */}\n                    {dataFilters.contacts && (\n                      <td className=\"px-3 py-2 whitespace-nowrap text-gray-900 bg-red-25\">\n                        {memberData.emergency_contacts.length > 0 ? (\n                          <div className=\"space-y-1\">\n                            {memberData.emergency_contacts.map((contact, index) => (\n                              <div key={index} className=\"text-xs\">\n                                <div className=\"font-medium\">{contact.name}</div>\n                                {contact.phone && <div className=\"text-gray-600\">📞 {contact.phone}</div>}\n                              </div>\n                            ))}\n                          </div>\n                        ) : (\n                          <span className=\"text-gray-400\">None</span>\n                        )}\n                      </td>\n                    )}\n                  \n                    {/* Essential Information Cells - Six comprehensive columns */}\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.allergies} \n                          fieldName=\"allergies\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.medical_details} \n                          fieldName=\"medical_details\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.dietary_requirements} \n                          fieldName=\"dietary_requirements\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.tetanus_year_of_last_jab} \n                          fieldName=\"tetanus_year_of_last_jab\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.swimmer} \n                          fieldName=\"swimmer\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.other_useful_information} \n                          fieldName=\"other_useful_information\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-gray-900 bg-orange-25 w-32\">\n                      <div className=\"max-w-[8rem] break-words\">\n                        <MedicalDataPill \n                          value={memberData.confirmed_by_parents} \n                          fieldName=\"confirmed_by_parents\"\n                          className=\"text-xs\"\n                        />\n                      </div>\n                    </td>\n                  \n                    {/* Consent Cells */}\n                    <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                      {\n                        memberData.consent_photos === 'No' ? (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                          </span>\n                        ) : memberData.consent_photos === 'Yes' ? (\n                          <span className=\"text-xs text-gray-700\">\n                          Yes\n                          </span>\n                        ) : (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                          </span>\n                        )\n                      }\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                      {\n                        memberData.consent_sensitive === 'No' ? (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                          </span>\n                        ) : memberData.consent_sensitive === 'Yes' ? (\n                          <span className=\"text-xs text-gray-700\">\n                          Yes\n                          </span>\n                        ) : (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                          </span>\n                        )\n                      }\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                      {\n                        memberData.consent_paracetamol === 'No' ? (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                          </span>\n                        ) : memberData.consent_paracetamol === 'Yes' ? (\n                          <span className=\"text-xs text-gray-700\">\n                          Yes\n                          </span>\n                        ) : (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                          </span>\n                        )\n                      }\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                      {\n                        memberData.consent_ibuprofen === 'No' ? (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                          </span>\n                        ) : memberData.consent_ibuprofen === 'Yes' ? (\n                          <span className=\"text-xs text-gray-700\">\n                          Yes\n                          </span>\n                        ) : (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                          </span>\n                        )\n                      }\n                    </td>\n                    <td className=\"px-3 py-2 whitespace-nowrap text-center bg-green-25\">\n                      {\n                        memberData.consent_suncream === 'No' ? (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-red text-white\">\n                          No\n                          </span>\n                        ) : memberData.consent_suncream === 'Yes' ? (\n                          <span className=\"text-xs text-gray-700\">\n                          Yes\n                          </span>\n                        ) : (\n                          <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-scout-yellow text-gray-900\">\n                          ---\n                          </span>\n                        )\n                      }\n                    </td>\n                  </tr>\n                );\n              })}\n            </tbody>\n          </table>\n        </div>\n      )}\n      \n      {/* Member Detail Modal */}\n      <MemberDetailModal\n        member={selectedMember}\n        isOpen={showMemberModal}\n        onClose={handleModalClose}\n      />\n    </div>\n  );\n}\n\nexport default SectionsList;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/components/SectionsPage.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/components/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/hooks/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/features/sections/services/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/layouts/DesktopLayout.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/layouts/MobileLayout.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/main.jsx","messages":[{"ruleId":"jsdoc/check-tag-names","severity":2,"message":"Invalid JSDoc tag name \"scout-themed\".","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/check-tag-names","severity":2,"message":"Invalid JSDoc tag name \"offline-aware\".","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Application entry point for Viking Event Management mobile app.\n *\n * This file initializes the React application with proper error monitoring and\n * Scout-specific configuration. It sets up Sentry error tracking before rendering\n * the main App component, ensuring comprehensive error reporting for Scout leaders\n * managing events and member data.\n *\n * The entry point handles:\n * - Sentry initialization for production error tracking\n * - React StrictMode for development safety\n * - Root DOM element mounting for the Scout management interface\n *\n * @scout-themed Application serves UK Scout Groups with offline-first design\n * @offline-aware Supports cached data when OSM API is unavailable\n * @since 1.0.0\n * @example\n * // This file is automatically executed during app startup\n * // No manual imports needed - handled by build system\n * \n * // Development server\n * npm run dev\n * \n * // Production build  \n * npm run build\n * @example\n * // Sentry integration provides:\n * // - Real-time error reporting for Scout leaders\n * // - Performance monitoring for offline operations\n * // - Release tracking for deployment validation\n * // - User context for Scout group identification\n * @example\n * // Entry point enables Scout workflows:\n * // 1. Automatic offline data synchronization\n * // 2. Member movement tracking between sections\n * // 3. Event attendance management\n * // 4. OSM API integration with proper rate limiting\n * // 5. Mobile-optimized interface for Scout leaders\n */\nimport { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App.jsx';\nimport { initSentry } from './shared/services/utils';\n\n// Initialize Sentry before rendering the app\ninitSentry();\n\ncreateRoot(document.getElementById('root')).render(\n  <StrictMode data-oid=\"i-itztv\">\n    <App data-oid=\"jnrms1z\" />\n  </StrictMode>,\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/routes/AppRouter.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/AuthButton.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":20,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n * AuthButton - Context-aware authentication button for header\n *\n * Displays different button text and behavior based on authentication state:\n * - No data: \"Sign in to OSM\"\n * - Has cached data: \"Refresh data\"\n * - Token expired: \"Sign in to refresh\"\n * - Syncing: \"Syncing...\" (disabled)\n *\n * @param {object} props - Component props\n * @param {string} props.authState - Current authentication state\n * @param {Function} props.onLogin - Login handler function\n * @param {Function} props.onRefresh - Refresh handler function\n * @param {boolean} props.isLoading - Whether sync is in progress\n * @param {boolean} props.isOfflineMode - Whether the app is in offline mode\n * @param {string} props.className - Additional CSS classes\n * @param {string} props.size - Button size (xs, sm, md, lg, xl)\n */\nfunction AuthButton({\n  authState,\n  onLogin,\n  onRefresh,\n  isLoading = false,\n  isOfflineMode = false,\n  className = '',\n  size,\n  ...rest\n}) {\n  const getButtonConfig = () => {\n    if (isLoading) {\n      return {\n        text: 'Syncing...',\n        onClick: null,\n        disabled: true,\n        variant: 'outline',\n        ariaLabel: 'Currently syncing data with OSM',\n      };\n    }\n\n    switch (authState) {\n    case 'no_data':\n      return {\n        text: 'Sign in to OSM',\n        onClick: onLogin,\n        disabled: false,\n        variant: 'scout-purple',\n        ariaLabel: 'Sign in to Online Scout Manager to access data',\n      };\n\n    case 'cached_only':\n      if (isOfflineMode) {\n        return {\n          text: 'Offline - Sign in to refresh',\n          onClick: onLogin,\n          disabled: false,\n          variant: 'outline',\n          ariaLabel: 'You are offline with cached data - sign in to refresh data from OSM',\n        };\n      }\n      return {\n        text: 'Sign in to refresh',\n        onClick: onLogin, // Need to login first to get token for refresh\n        disabled: false,\n        variant: 'scout-purple',\n        ariaLabel: 'Sign in to OSM to refresh data - currently using cached data',\n      };\n\n    case 'token_expired':\n      return {\n        text: 'Sign in to refresh',\n        onClick: onLogin,\n        disabled: false,\n        variant: 'scout-purple',\n        ariaLabel: 'Session expired - sign in again to refresh data',\n      };\n\n    case 'authenticated':\n      return {\n        text: 'Refresh',\n        onClick: onRefresh || onLogin,\n        disabled: false,\n        variant: 'outline',\n        ariaLabel: 'Refresh data from OSM',\n      };\n\n    case 'syncing':\n      return {\n        text: 'Syncing...',\n        onClick: null,\n        disabled: true,\n        variant: 'outline',\n        ariaLabel: 'Currently syncing data with OSM',\n      };\n\n    default:\n      return {\n        text: 'Sign in',\n        onClick: onLogin,\n        disabled: false,\n        variant: 'scout-blue',\n        ariaLabel: 'Sign in to Online Scout Manager',\n      };\n    }\n  };\n\n  const config = getButtonConfig();\n\n  const getButtonClasses = (variant, size) => {\n    const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';\n    \n    const sizeClasses = {\n      xs: 'px-2 py-1 text-xs',\n      sm: 'px-3 py-1.5 text-sm',\n      md: 'px-4 py-2 text-sm',\n      lg: 'px-6 py-3 text-base',\n      xl: 'px-8 py-4 text-lg',\n    };\n    \n    const variantClasses = {\n      'scout-purple': 'bg-scout-purple text-white hover:bg-scout-purple-dark focus:ring-scout-purple-light active:bg-scout-purple-dark',\n      'scout-blue': 'bg-scout-blue text-white hover:bg-scout-blue-dark focus:ring-scout-blue-light active:bg-scout-blue-dark',\n      'outline': 'border border-gray-300 text-gray-700 bg-white hover:bg-gray-50 focus:ring-blue-300 active:bg-gray-100',\n    };\n    \n    return `${baseClasses} ${sizeClasses[size] || sizeClasses.md} ${variantClasses[variant] || variantClasses['scout-blue']}`;\n  };\n\n  return (\n    <button\n      onClick={config.onClick}\n      disabled={config.disabled}\n      className={`${getButtonClasses(config.variant, size)} auth-button ${className}`}\n      aria-label={config.ariaLabel}\n      data-testid=\"auth-button\"\n      {...rest}\n      data-oid=\"14si21j\"\n    >\n      {config.text}\n    </button>\n  );\n}\n\nexport default AuthButton;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/BlockedScreen.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.message\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.message\n */\nfunction BlockedScreen({ message = 'Access blocked' }) {\n  return (\n    <div className=\"flex items-center justify-center min-h-screen bg-gray-50\">\n      <div className=\"max-w-md w-full space-y-8\">\n        <div className=\"text-center\">\n          <h2 className=\"mt-6 text-3xl font-extrabold text-gray-900\">\n            Access Blocked\n          </h2>\n          <p className=\"mt-2 text-sm text-gray-600\">\n            {message}\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default BlockedScreen;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/DataFreshness.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":19,"column":1,"nodeType":"Block","endLine":26,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":19,"column":1,"nodeType":"Block","endLine":26,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":21,"column":1,"nodeType":"Block","endLine":21,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.lastSync\" description.","line":22,"column":1,"nodeType":"Block","endLine":22,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.authState\" description.","line":23,"column":1,"nodeType":"Block","endLine":23,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":24,"column":1,"nodeType":"Block","endLine":24,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.compact\" description.","line":25,"column":1,"nodeType":"Block","endLine":25,"endColumn":1}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { parseTimestamp } from '../utils/asyncUtils.js';\n\nconst AUTH_STATES = {\n  NO_DATA: 'no_data',\n  SYNCING: 'syncing',\n  AUTHENTICATED: 'authenticated',\n  CACHED_ONLY: 'cached_only',\n  TOKEN_EXPIRED: 'token_expired',\n};\n\nconst STALENESS_COLOURS = {\n  fresh: 'text-yellow-600',\n  moderate: 'text-orange-600',\n  stale: 'text-red-600',\n  'very-stale': 'text-red-700',\n};\n\n/**\n *\n * @param root0\n * @param root0.lastSync\n * @param root0.authState\n * @param root0.className\n * @param root0.compact\n */\nfunction DataFreshness({ lastSync, authState, className = '', compact = false }) {\n  const getDataAge = (timestamp) => {\n    const syncTimeMs = parseTimestamp(timestamp);\n    if (!syncTimeMs) return null;\n\n    const diffMs = Math.max(0, Date.now() - syncTimeMs);\n    const minutes = Math.floor(diffMs / (1000 * 60));\n    const hours = Math.floor(diffMs / (1000 * 60 * 60));\n    const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n    const months = Math.floor(days / 30);\n\n    if (minutes < 1) return 'Just now';\n    if (minutes < 60) return `${minutes}m ago`;\n    if (hours < 24) return `${hours}h ago`;\n    if (days < 30) return `${days}d ago`;\n    return `${months}mo ago`;\n  };\n\n  const getStalenessLevel = (timestamp) => {\n    const syncTimeMs = parseTimestamp(timestamp);\n    if (!syncTimeMs) return 'unknown';\n\n    const diffMs = Math.max(0, Date.now() - syncTimeMs);\n    const HOUR = 60 * 60 * 1000;\n    const DAY = 24 * HOUR;\n    const WEEK = 7 * DAY;\n\n    if (diffMs < HOUR) return 'fresh';\n    if (diffMs < 4 * HOUR) return 'moderate';\n    if (diffMs < DAY) return 'stale';\n    if (diffMs < WEEK) return 'very-stale';\n    return 'ancient';\n  };\n\n  const getDisplayInfo = () => {\n    const age = getDataAge(lastSync);\n    const staleness = getStalenessLevel(lastSync);\n\n    switch (authState) {\n    case AUTH_STATES.NO_DATA:\n      return {\n        text: age ? `Cached data from ${age}` : 'Sign in to get fresh data',\n        className: 'text-gray-500',\n      };\n    case AUTH_STATES.SYNCING:\n      return {\n        text: 'Syncing...',\n        className: 'text-blue-600 animate-pulse',\n      };\n    case AUTH_STATES.AUTHENTICATED:\n      return {\n        text: age ? `Last synced: ${age}` : 'Recently synced',\n        className: staleness === 'fresh' ? 'text-green-600' : 'text-blue-600',\n      };\n    case AUTH_STATES.CACHED_ONLY:\n    case AUTH_STATES.TOKEN_EXPIRED: {\n      const urgencyClass = {...STALENESS_COLOURS, ancient: 'text-red-900'}[staleness] || 'text-gray-600';\n      return {\n        text: age ? `Cached data from ${age}` : 'Using cached data',\n        className: urgencyClass,\n      };\n    }\n    default:\n      return {\n        text: 'Unknown status',\n        className: 'text-gray-500',\n      };\n    }\n  };\n\n  const info = getDisplayInfo();\n  if (!info.text) return null;\n\n  return (\n    <div className={`${compact ? 'text-xs' : 'text-sm'} ${info.className} ${className}`}>\n      <span title={info.text}>\n        {compact ? info.text.replace('Last synced: ', 'Synced: ').replace('Cached data from ', 'Cached: ') : info.text}\n      </span>\n    </div>\n  );\n}\n\nexport default DataFreshness;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ErrorBoundary.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":5,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":7,"column":3,"nodeType":"Block","endLine":10,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"props\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":16,"column":3,"nodeType":"Block","endLine":19,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":16,"column":3,"nodeType":"Block","endLine":19,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":16,"column":3,"nodeType":"Block","endLine":19,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"error\" description.","line":18,"column":1,"nodeType":"Block","endLine":18,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":24,"column":3,"nodeType":"Block","endLine":28,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"error\" description.","line":26,"column":1,"nodeType":"Block","endLine":26,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"errorInfo\" description.","line":27,"column":1,"nodeType":"Block","endLine":27,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":33,"column":3,"nodeType":"Block","endLine":35,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":33,"column":3,"nodeType":"Block","endLine":35,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":33,"column":3,"nodeType":"Block","endLine":35,"endColumn":6}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n */\nclass ErrorBoundary extends React.Component {\n  /**\n   *\n   * @param props\n   */\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  /**\n   *\n   * @param error\n   */\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  /**\n   *\n   * @param error\n   * @param errorInfo\n   */\n  componentDidCatch(error, errorInfo) {\n    console.error('ErrorBoundary caught an error:', error, errorInfo);\n  }\n\n  /**\n   *\n   */\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"flex items-center justify-center min-h-screen bg-gray-50\">\n          <div className=\"max-w-md w-full space-y-8\">\n            <div className=\"text-center\">\n              <h2 className=\"mt-6 text-3xl font-extrabold text-gray-900\">\n                Something went wrong\n              </h2>\n              <p className=\"mt-2 text-sm text-gray-600\">\n                An unexpected error occurred. Please try refreshing the page.\n              </p>\n              <button\n                onClick={() => window.location.reload()}\n                className=\"mt-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-scout-blue hover:bg-scout-blue-dark\"\n              >\n                Refresh Page\n              </button>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/Footer.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":5,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":5,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n */\nfunction Footer() {\n  const version = import.meta.env.VITE_APP_VERSION || '2.0.0';\n  \n  return (\n    <footer className=\"bg-gray-100 border-t border-gray-200 py-2 px-4 text-center\">\n      <div className=\"text-xs text-gray-500\">\n        Viking Event Management v{version}\n      </div>\n    </footer>\n  );\n}\n\nexport default Footer;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/LoadingScreen.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.message\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.message\n */\nfunction LoadingScreen({ message = 'Loading...' }) {\n  return (\n    <div className=\"flex items-center justify-center min-h-screen\">\n      <div className=\"text-center\">\n        <div className=\"animate-spin rounded-full h-32 w-32 border-b-2 border-scout-blue mx-auto\"></div>\n        <p className=\"mt-4 text-gray-600\">{message}</p>\n      </div>\n    </div>\n  );\n}\n\nexport default LoadingScreen;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/LoginScreen.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":7,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.message\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\n/**\n *\n * @param root0\n * @param root0.message\n */\nfunction LoginScreen({ message = 'Please sign in to continue' }) {\n  return (\n    <div className=\"flex items-center justify-center min-h-screen bg-gray-50\">\n      <div className=\"max-w-md w-full space-y-8\">\n        <div className=\"text-center\">\n          <h2 className=\"mt-6 text-3xl font-extrabold text-gray-900\">\n            Sign In Required\n          </h2>\n          <p className=\"mt-2 text-sm text-gray-600\">\n            {message}\n          </p>\n        </div>\n        <div className=\"text-center\">\n          <button className=\"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-scout-blue hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-blue\">\n            Sign In with OSM\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default LoginScreen;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/TokenCountdown.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":10,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.authState\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.compact\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setInterval' is not defined.","line":57,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'clearInterval' is not defined.","line":58,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":58,"endColumn":31}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n *\n * @param root0\n * @param root0.authState\n * @param root0.className\n * @param root0.compact\n */\nfunction TokenCountdown({ authState, className = '', compact = false }) {\n  const [timeRemaining, setTimeRemaining] = useState(null);\n  const [displayText, setDisplayText] = useState('');\n\n  useEffect(() => {\n    if (authState !== 'authenticated') {\n      setTimeRemaining(null);\n      setDisplayText('');\n      return;\n    }\n\n    const updateCountdown = () => {\n      const expiresAt = sessionStorage.getItem('token_expires_at');\n      if (!expiresAt) {\n        setTimeRemaining(null);\n        setDisplayText('');\n        return;\n      }\n\n      const expirationTime = parseInt(expiresAt);\n      const now = Date.now();\n      const msRemaining = expirationTime - now;\n\n      if (msRemaining <= 0) {\n        setTimeRemaining(0);\n        setDisplayText('Expired');\n        return;\n      }\n\n      const minutesRemaining = Math.floor(msRemaining / (60 * 1000));\n      const secondsRemaining = Math.floor((msRemaining % (60 * 1000)) / 1000);\n\n      setTimeRemaining(msRemaining);\n\n      if (minutesRemaining >= 60) {\n        const hoursRemaining = Math.floor(minutesRemaining / 60);\n        const remainingMinutes = minutesRemaining % 60;\n        setDisplayText(`${hoursRemaining}h ${remainingMinutes}m`);\n      } else if (minutesRemaining >= 1) {\n        setDisplayText(`${minutesRemaining}m ${secondsRemaining}s`);\n      } else {\n        setDisplayText(`${secondsRemaining}s`);\n      }\n    };\n\n    updateCountdown();\n    const interval = setInterval(updateCountdown, 1000);\n    return () => clearInterval(interval);\n  }, [authState]);\n\n  if (authState !== 'authenticated' || !timeRemaining) {\n    return null;\n  }\n\n  return (\n    <div className={`${compact ? 'text-xs' : 'text-sm'} text-gray-600 ${className}`}>\n      <span>\n        {compact ? 'Session: ' : (\n          <span className=\"hidden md:inline\">Session: </span>\n        )}\n      </span>\n      <span>{displayText}</span>\n    </div>\n  );\n}\n\nTokenCountdown.propTypes = {\n  authState: PropTypes.oneOf([\n    'no_data',\n    'cached_only', \n    'authenticated',\n    'token_expired',\n    'syncing',\n  ]).isRequired,\n  className: PropTypes.string,\n  compact: PropTypes.bool,\n};\n\nexport default TokenCountdown;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/TokenExpiredDialog.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":3,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isOpen\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onRefresh\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onLogout\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onReLogin\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onStayOffline\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.hasCachedData\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.message\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\n\n/**\n *\n * @param root0\n * @param root0.isOpen\n * @param root0.onRefresh\n * @param root0.onLogout\n * @param root0.onReLogin\n * @param root0.onStayOffline\n * @param root0.hasCachedData\n * @param root0.message\n */\nfunction TokenExpiredDialog({ \n  isOpen = false, \n  onRefresh = () => {}, \n  onLogout = () => {},\n  onReLogin = null,\n  onStayOffline = null,\n  hasCachedData = false,\n  message = 'Your session has expired. Please refresh or log in again.',\n}) {\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingAction, setLoadingAction] = useState('');\n  const dialogRef = useRef(null);\n\n  // Focus management for accessibility\n  useEffect(() => {\n    if (isOpen && dialogRef.current) {\n      dialogRef.current.focus();\n    }\n  }, [isOpen]);\n\n  if (!isOpen) return null;\n\n  // Use new auth flow if handlers are provided\n  const useNewAuthFlow = onReLogin && onStayOffline;\n  \n  // Enhanced message based on cached data availability\n  const enhancedMessage = useNewAuthFlow \n    ? hasCachedData \n      ? 'Your session has expired. You can continue working with cached data offline, or log in again to sync your latest changes.'\n      : 'Your session has expired. Please log in again to continue.'\n    : message;\n\n  const handleAction = async (action, actionName) => {\n    setIsLoading(true);\n    setLoadingAction(actionName);\n    \n    try {\n      await action();\n    } catch (error) {\n      console.error(`Error during ${actionName}:`, error);\n    } finally {\n      setIsLoading(false);\n      setLoadingAction('');\n    }\n  };\n\n  return (\n    <div \n      className=\"fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50\"\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby=\"token-expired-title\"\n      aria-describedby=\"token-expired-description\"\n    >\n      <div className=\"relative top-20 mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white\">\n        <div className=\"mt-3 text-center\">\n          <h3 \n            id=\"token-expired-title\"\n            className=\"text-lg leading-6 font-medium text-gray-900\"\n            ref={dialogRef}\n            tabIndex={-1}\n          >\n            Session Expired\n          </h3>\n          <div className=\"mt-2 px-4 py-3\">\n            <p id=\"token-expired-description\" className=\"text-sm text-gray-500\">\n              {enhancedMessage}\n            </p>\n          </div>\n          <div className=\"flex flex-col space-y-3 px-4 py-3 sm:flex-row sm:space-y-0 sm:space-x-3\">\n            {useNewAuthFlow ? (\n              <>\n                <button\n                  onClick={() => handleAction(onReLogin, 'login')}\n                  disabled={isLoading}\n                  className=\"px-4 py-2 bg-scout-blue text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-scout-blue disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200\"\n                  aria-describedby={isLoading && loadingAction === 'login' ? 'login-loading' : undefined}\n                >\n                  {isLoading && loadingAction === 'login' ? (\n                    <span className=\"flex items-center justify-center\">\n                      <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4 text-white\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                      </svg>\n                      Logging in...\n                      <span id=\"login-loading\" className=\"sr-only\">Loading, please wait</span>\n                    </span>\n                  ) : (\n                    'Log In Again'\n                  )}\n                </button>\n                {hasCachedData && (\n                  <button\n                    onClick={() => handleAction(onStayOffline, 'offline')}\n                    disabled={isLoading}\n                    className=\"px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200\"\n                    aria-describedby={isLoading && loadingAction === 'offline' ? 'offline-loading' : undefined}\n                  >\n                    {isLoading && loadingAction === 'offline' ? (\n                      <span className=\"flex items-center justify-center\">\n                        <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4 text-white\" fill=\"none\" viewBox=\"0 0 24 24\">\n                          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                          <path className=\"opacity-75\" fill=\"currentColor\" d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                        </svg>\n                        Switching...\n                        <span id=\"offline-loading\" className=\"sr-only\">Loading, please wait</span>\n                      </span>\n                    ) : (\n                      'Work Offline'\n                    )}\n                  </button>\n                )}\n              </>\n            ) : (\n              <>\n                <button\n                  onClick={() => handleAction(onRefresh, 'refresh')}\n                  disabled={isLoading}\n                  className=\"px-4 py-2 bg-scout-blue text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-scout-blue-dark focus:outline-none focus:ring-2 focus:ring-scout-blue disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200\"\n                  aria-describedby={isLoading && loadingAction === 'refresh' ? 'refresh-loading' : undefined}\n                >\n                  {isLoading && loadingAction === 'refresh' ? (\n                    <span className=\"flex items-center justify-center\">\n                      <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4 text-white\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                      </svg>\n                      Refreshing...\n                      <span id=\"refresh-loading\" className=\"sr-only\">Loading, please wait</span>\n                    </span>\n                  ) : (\n                    'Refresh'\n                  )}\n                </button>\n                <button\n                  onClick={() => handleAction(onLogout, 'logout')}\n                  disabled={isLoading}\n                  className=\"px-4 py-2 bg-gray-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200\"\n                  aria-describedby={isLoading && loadingAction === 'logout' ? 'logout-loading' : undefined}\n                >\n                  {isLoading && loadingAction === 'logout' ? (\n                    <span className=\"flex items-center justify-center\">\n                      <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4 text-white\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                      </svg>\n                      Logging out...\n                      <span id=\"logout-loading\" className=\"sr-only\">Loading, please wait</span>\n                    </span>\n                  ) : (\n                    'Log Out'\n                  )}\n                </button>\n              </>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default TokenExpiredDialog;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/VikingHeader.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":8,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":8,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.user\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onLogout\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onLogin\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onRefresh\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isOfflineMode\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.authState\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.lastSyncTime\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport ConfirmModal from './ui/ConfirmModal';\n// Auth-related components\nimport AuthButton from './AuthButton.jsx';\nimport DataFreshness from './DataFreshness.jsx';\nimport TokenCountdown from './TokenCountdown.jsx';\n\n/**\n *\n * @param root0\n * @param root0.user\n * @param root0.onLogout\n * @param root0.onLogin\n * @param root0.onRefresh\n * @param root0.isOfflineMode\n * @param root0.authState\n * @param root0.lastSyncTime\n */\nfunction VikingHeader({\n  user,\n  onLogout,\n  onLogin: _onLogin,\n  onRefresh: _onRefresh,\n  isOfflineMode,\n  authState = 'no_data',\n  lastSyncTime = null,\n}) {\n  const [showLogoutModal, setShowLogoutModal] = useState(false);\n\n  const handleLogout = () => {\n    setShowLogoutModal(true);\n  };\n\n  return (\n    <header\n      className=\"bg-white shadow-sm border-b border-gray-200 px-6 py-4\"\n      data-oid=\"v-qjxzy\"\n    >\n      <div\n        className=\"flex justify-between items-center max-w-7xl mx-auto\"\n        data-oid=\"pua2r8c\"\n      >\n        <div className=\"flex flex-col\" data-oid=\".fyugfv\">\n          <h1 className=\"text-2xl font-bold text-scout-blue\" data-oid=\"dfv63mf\">\n            Viking Scouts (1st Walton on Thames)\n          </h1>\n          {user && (\n            <div className=\"flex flex-col mt-2 text-sm text-gray-600\">\n              <span className=\"text-gray-700 font-medium\">\n                Hi, {user.firstname}\n                {isOfflineMode && (\n                  <span className=\"ml-2 inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-amber-500 text-white\">\n                    Offline\n                  </span>\n                )}\n              </span>\n              <div className=\"flex items-center gap-4 text-xs text-gray-500 mt-1\">\n                <DataFreshness\n                  lastSync={lastSyncTime}\n                  authState={authState}\n                  compact={true}\n                />\n                <TokenCountdown\n                  authState={authState}\n                  compact={true}\n                />\n              </div>\n            </div>\n          )}\n        </div>\n\n        <div className=\"flex items-center space-x-4\" data-oid=\"36ufks8\">\n          <AuthButton\n            authState={authState}\n            onLogin={_onLogin}\n            onRefresh={_onRefresh}\n            isOfflineMode={isOfflineMode}\n            className=\"mr-2\"\n            size=\"sm\"\n            data-testid=\"auth-button\"\n            data-oid=\"-wvy88p\"\n          />\n\n          {user && (\n            <button\n              className=\"inline-flex items-center justify-center rounded-md font-medium px-3 py-1.5 text-sm bg-white border-2 border-scout-red text-scout-red hover:bg-scout-red hover:text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-scout-red-light transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed\"\n              onClick={handleLogout}\n              type=\"button\"\n              aria-label={isOfflineMode ? 'Clear cached data and logout' : 'Logout from application'}\n              data-oid=\"fhg::su\"\n            >\n              {isOfflineMode ? 'Clear Data' : 'Logout'}\n            </button>\n          )}\n        </div>\n      </div>\n\n      {/* Logout/Clear Data Confirmation Modal */}\n      <ConfirmModal\n        isOpen={showLogoutModal}\n        title={isOfflineMode ? 'Clear Cached Data' : 'Confirm Logout'}\n        message={\n          isOfflineMode\n            ? 'Are you sure you want to clear all cached data? This will remove all offline access to your events and member data.'\n            : 'Are you sure you want to logout?'\n        }\n        confirmText={isOfflineMode ? 'Clear Data' : 'Logout'}\n        cancelText=\"Cancel\"\n        onConfirm={() => {\n          setShowLogoutModal(false);\n          onLogout();\n        }}\n        onCancel={() => setShowLogoutModal(false)}\n        confirmVariant=\"error\"\n        data-oid=\"hx.8rc_\"\n      />\n\n    </header>\n  );\n}\n\nexport default VikingHeader;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/forms/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/guards/RequireAuth.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":7,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":7,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.children\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.redirectTo\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.showLoginScreen\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.fallbackComponent\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\n// TODO: Move useAuth hook to shared layer to avoid circular dependency\n// import { useAuth } from '../../../features/auth/hooks/useAuth.js';\nimport LoginScreen from '../LoginScreen.jsx';\n\n/**\n *\n * @param root0\n * @param root0.children\n * @param root0.redirectTo\n * @param root0.showLoginScreen\n * @param root0.fallbackComponent\n */\nfunction RequireAuth({ \n  children, \n  redirectTo = '/',\n  showLoginScreen = true,\n  fallbackComponent = null,\n}) {\n  // TODO: Temporarily disable auth functionality due to circular dependency\n  const authState = 'authenticated'; // Mock for now\n  const isLoading = false;\n  const user = { id: 1 }; // Mock user\n  const location = useLocation();\n\n  if (isLoading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"animate-spin rounded-full h-32 w-32 border-b-2 border-scout-blue\"></div>\n      </div>\n    );\n  }\n\n  const isAuthenticated = authState !== 'no_data' || !!user;\n\n  if (!isAuthenticated) {\n    if (showLoginScreen) {\n      return <LoginScreen message=\"Please sign in to access this feature\" />;\n    }\n\n    if (fallbackComponent) {\n      return fallbackComponent;\n    }\n\n    return (\n      <Navigate \n        to={redirectTo} \n        state={{ \n          from: location,\n          message: 'Please sign in to access this feature',\n        }} \n        replace \n      />\n    );\n  }\n\n  return children;\n}\n\nexport default RequireAuth;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/guards/RouteGuard.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":6,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":6,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.children\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.authLevel\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.showLoginScreen\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.requiredPermissions\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.fallbackComponent\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n// TODO: Move useAuth hook to shared layer to avoid circular dependency\n// import { useAuth } from '../../../features/auth/hooks/useAuth.js';\nimport LoginScreen from '../LoginScreen.jsx';\n\n/**\n *\n * @param root0\n * @param root0.children\n * @param root0.authLevel\n * @param root0.showLoginScreen\n * @param root0.requiredPermissions\n * @param root0.fallbackComponent\n */\nfunction RouteGuard({ \n  children, \n  authLevel = 'none',\n  showLoginScreen = true,\n  requiredPermissions = [],\n  fallbackComponent = null,\n}) {\n  // TODO: Temporarily disable auth functionality due to circular dependency\n  const authState = 'authenticated'; // Mock for now\n  const isLoading = false;\n  const user = null;\n\n  if (isLoading) {\n    return (\n      <div \n        className=\"flex items-center justify-center min-h-screen bg-gray-50\"\n        role=\"status\"\n        aria-live=\"polite\"\n        aria-label=\"Loading application\"\n      >\n        <div className=\"flex flex-col items-center space-y-4\">\n          <div className=\"animate-spin rounded-full h-16 w-16 border-b-2 border-scout-blue\"></div>\n          <p className=\"text-gray-600 text-sm font-medium\">Loading...</p>\n          <span className=\"sr-only\">Please wait while we load the application</span>\n        </div>\n      </div>\n    );\n  }\n\n  const hasAccess = () => {\n    switch (authLevel) {\n    case 'none':\n      return true;\n    case 'offline_capable':\n      return authState === 'authenticated' || \n               authState === 'cached_only' || \n               authState === 'token_expired' ||\n               (user && authState !== 'no_data');\n    case 'authenticated': {\n      const isAuthenticated = authState === 'authenticated' && user;\n        \n      if (isAuthenticated && requiredPermissions.length > 0) {\n        return requiredPermissions.every(permission => \n          user.permissions && user.permissions.includes(permission),\n        );\n      }\n        \n      return isAuthenticated;\n    }\n    default:\n      return true;\n    }\n  };\n\n  if (!hasAccess()) {\n    if (fallbackComponent) {\n      return fallbackComponent;\n    }\n    \n    if (showLoginScreen) {\n      const message = requiredPermissions.length > 0 \n        ? `You need additional permissions to access this feature: ${requiredPermissions.join(', ')}`\n        : 'Please sign in to access this feature';\n      return <LoginScreen message={message} />;\n    }\n    \n    return (\n      <div className=\"flex items-center justify-center min-h-screen bg-gray-50\">\n        <div className=\"text-center max-w-md mx-auto px-4\">\n          <div className=\"mb-4\">\n            <svg \n              className=\"mx-auto h-12 w-12 text-gray-400\" \n              fill=\"none\" \n              stroke=\"currentColor\" \n              viewBox=\"0 0 24 24\"\n              aria-hidden=\"true\"\n            >\n              <path \n                strokeLinecap=\"round\" \n                strokeLinejoin=\"round\" \n                strokeWidth={2} \n                d=\"M12 15v2m0 0v2m0-2h2m-2 0H10M5 12V7a5 5 0 1110 0v5m-5 7a7 7 0 110-14 7 7 0 010 14z\" \n              />\n            </svg>\n          </div>\n          <h2 className=\"text-2xl font-semibold text-gray-900 mb-2\">Access Restricted</h2>\n          <p className=\"text-gray-600 mb-4\">\n            {requiredPermissions.length > 0 \n              ? `You need additional permissions: ${requiredPermissions.join(', ')}`\n              : 'You need to be signed in to access this content'\n            }\n          </p>\n        </div>\n      </div>\n    );\n  }\n\n  return children;\n}\n\nexport default RouteGuard;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/guards/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/layout/MainNavigation.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":6,"column":1,"nodeType":"Block","endLine":6,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onNavigateToSectionMovements\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Link, useLocation } from 'react-router-dom';\n\n/**\n *\n * @param root0\n * @param root0.onNavigateToSectionMovements\n */\nfunction MainNavigation({ onNavigateToSectionMovements }) {\n  const location = useLocation();\n  \n  // Determine current page from URL path\n  const getCurrentPage = () => {\n    const path = location.pathname;\n    if (path.startsWith('/events')) return 'events';\n    if (path.startsWith('/sections')) return 'sections';\n    if (path.startsWith('/movers')) return 'movers';\n    return 'events'; // default\n  };\n\n  const currentPage = getCurrentPage();\n\n  return (\n    <div className=\"border-b border-gray-200 bg-white\">\n      <div className=\"max-w-7xl mx-auto\">\n        <div className=\"px-6 sm:px-8\">\n          <div\n            className=\"flex space-x-8 overflow-x-auto\"\n            role=\"tablist\"\n            aria-label=\"Main navigation\"\n          >\n            {/* Events Tab */}\n            <Link\n              to=\"/events\"\n              className={`py-3 px-1 border-b-2 font-medium text-sm whitespace-nowrap ${\n                currentPage === 'events'\n                  ? 'border-scout-blue text-scout-blue'\n                  : 'border-transparent text-gray-600 hover:text-gray-900 hover:border-gray-300'\n              }`}\n              role=\"tab\"\n              aria-selected={currentPage === 'events'}\n              aria-controls=\"events-panel\"\n              aria-label=\"Switch to Events view\"\n            >\n              📅 Events\n            </Link>\n\n            {/* Sections Tab */}\n            <Link\n              to=\"/sections\"\n              className={`py-3 px-1 border-b-2 font-medium text-sm whitespace-nowrap ${\n                currentPage === 'sections'\n                  ? 'border-scout-blue text-scout-blue'\n                  : 'border-transparent text-gray-600 hover:text-gray-900 hover:border-gray-300'\n              }`}\n              role=\"tab\"\n              aria-selected={currentPage === 'sections'}\n              aria-controls=\"sections-panel\"\n              aria-label=\"Switch to Sections view\"\n            >\n              👥 Sections\n            </Link>\n\n            {/* Movers Button */}\n            <button\n              onClick={onNavigateToSectionMovements}\n              className=\"py-3 px-1 border-b-2 border-transparent font-medium text-sm whitespace-nowrap text-gray-600 hover:text-gray-900 hover:border-gray-300\"\n              aria-label=\"Navigate to Section Movers\"\n            >\n              🔄 Movers\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default MainNavigation;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/layout/ResponsiveLayout.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":6,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":6,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.children\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.user\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onLogout\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onLogin\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onRefresh\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.currentView\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isOfflineMode\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.authState\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.lastSyncTime\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { isMobileLayout } from '../../utils/platform.js';\nimport MobileLayout from '../../../layouts/MobileLayout.jsx';\nimport DesktopLayout from '../../../layouts/DesktopLayout.jsx';\n\n/**\n *\n * @param root0\n * @param root0.children\n * @param root0.user\n * @param root0.onLogout\n * @param root0.onLogin\n * @param root0.onRefresh\n * @param root0.currentView\n * @param root0.isOfflineMode\n * @param root0.authState\n * @param root0.lastSyncTime\n */\nfunction ResponsiveLayout({\n  children,\n  user,\n  onLogout,\n  onLogin,\n  onRefresh,\n  currentView,\n  isOfflineMode = false,\n  authState = 'no_data',\n  lastSyncTime = null,\n  ...props\n}) {\n  const [isMobile, setIsMobile] = React.useState(isMobileLayout());\n\n  React.useEffect(() => {\n    const handleResize = () => {\n      setIsMobile(isMobileLayout());\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  const LayoutComponent = isMobile ? MobileLayout : DesktopLayout;\n\n  return (\n    <div data-testid=\"responsive-layout\" className=\"h-full\" data-oid=\"z6:bgu7\">\n      <LayoutComponent\n        user={user}\n        onLogout={onLogout}\n        onLogin={onLogin}\n        onRefresh={onRefresh}\n        currentView={currentView}\n        isOfflineMode={isOfflineMode}\n        authState={authState}\n        lastSyncTime={lastSyncTime}\n        {...props}\n      >\n        {children}\n      </LayoutComponent>\n    </div>\n  );\n}\n\nexport default ResponsiveLayout;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/layout/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/Alert.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.children\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.variant\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.size\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.dismissible\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onDismiss\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.icon\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { cn } from '../../utils/cn';\n\n/**\n * Tailwind-based Alert component with Scout theming\n * Used for important messages, notifications, and feedback\n * @param root0\n * @param root0.children\n * @param root0.variant\n * @param root0.size\n * @param root0.dismissible\n * @param root0.onDismiss\n * @param root0.icon\n * @param root0.className\n */\nconst Alert = ({\n  children,\n  variant = 'info',\n  size = 'md',\n  dismissible = false,\n  onDismiss,\n  icon = true,\n  className = '',\n  ...props\n}) => {\n  const baseClasses = 'rounded-lg border';\n\n  const variants = {\n    // Standard variants\n    success: 'bg-green-50 border-green-200 text-green-800',\n    warning: 'bg-yellow-50 border-yellow-200 text-yellow-800',\n    error: 'bg-red-50 border-red-200 text-red-800',\n    info: 'bg-blue-50 border-blue-200 text-blue-800',\n\n    // Scout variants\n    'scout-blue': 'bg-scout-blue/10 border-scout-blue/20 text-scout-blue-dark',\n    'scout-green':\n      'bg-scout-green/10 border-scout-green/20 text-scout-green-dark',\n    'scout-red': 'bg-scout-red/10 border-scout-red/20 text-scout-red-dark',\n    'scout-orange':\n      'bg-scout-orange/10 border-scout-orange/20 text-scout-orange-dark',\n\n    // Special variants\n    neutral: 'bg-gray-50 border-gray-200 text-gray-700',\n    dark: 'bg-gray-800 border-gray-700 text-white',\n  };\n\n  const sizes = {\n    sm: 'p-3 text-sm',\n    md: 'p-4 text-base',\n    lg: 'p-6 text-lg',\n  };\n\n  const icons = {\n    success: (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"lvxhnmb\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n          clipRule=\"evenodd\"\n          data-oid=\"xaa-h8i\"\n        />\n      </svg>\n    ),\n\n    warning: (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\".9chbzc\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\"\n          clipRule=\"evenodd\"\n          data-oid=\"d8j9ifr\"\n        />\n      </svg>\n    ),\n\n    error: (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"3nlj04q\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\"\n          clipRule=\"evenodd\"\n          data-oid=\"6sc1ii0\"\n        />\n      </svg>\n    ),\n\n    info: (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"p.dp9y6\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\"\n          clipRule=\"evenodd\"\n          data-oid=\"z54j6x6\"\n        />\n      </svg>\n    ),\n\n    'scout-blue': (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"gapxvxh\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\"\n          clipRule=\"evenodd\"\n          data-oid=\"ied9vrs\"\n        />\n      </svg>\n    ),\n\n    'scout-green': (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"2uzm0uv\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\"\n          clipRule=\"evenodd\"\n          data-oid=\"c.n.ogb\"\n        />\n      </svg>\n    ),\n\n    'scout-red': (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"9fonk6k\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\"\n          clipRule=\"evenodd\"\n          data-oid=\"v:.5h9_\"\n        />\n      </svg>\n    ),\n\n    'scout-orange': (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"i..:8kd\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\"\n          clipRule=\"evenodd\"\n          data-oid=\"tb:noim\"\n        />\n      </svg>\n    ),\n\n    neutral: (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"o43m:jl\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\"\n          clipRule=\"evenodd\"\n          data-oid=\"39vpxf9\"\n        />\n      </svg>\n    ),\n\n    dark: (\n      <svg\n        className=\"w-5 h-5\"\n        fill=\"currentColor\"\n        viewBox=\"0 0 20 20\"\n        data-oid=\"hgo-8mz\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\"\n          clipRule=\"evenodd\"\n          data-oid=\"w5gh:q7\"\n        />\n      </svg>\n    ),\n  };\n\n  return (\n    <div\n      className={cn(baseClasses, variants[variant], sizes[size], className)}\n      role=\"alert\"\n      {...props}\n      data-oid=\".kboob.\"\n    >\n      <div className=\"flex\" data-oid=\"e8hlro6\">\n        {icon && (\n          <div className=\"flex-shrink-0\" data-oid=\"cixgqrx\">\n            {icons[variant] || icons.info}\n          </div>\n        )}\n\n        <div className={cn('flex-1', icon && 'ml-3')} data-oid=\"t9y3ta5\">\n          {children}\n        </div>\n\n        {dismissible && (\n          <div\n            className={cn('ml-auto pl-3', !icon && 'flex-shrink-0')}\n            data-oid=\"eg91ewk\"\n          >\n            <button\n              onClick={onDismiss}\n              className=\"inline-flex text-current hover:text-current/80 transition-colors\"\n              aria-label=\"Dismiss alert\"\n              data-oid=\"6ifq1qx\"\n            >\n              <svg\n                className=\"w-5 h-5\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n                data-oid=\"fba7p9l\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\"\n                  clipRule=\"evenodd\"\n                  data-oid=\"jc_6ypg\"\n                />\n              </svg>\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst AlertTitle = ({ children, className = '', ...props }) => {\n  return (\n    <h3\n      className={cn('text-sm font-medium mb-1', className)}\n      {...props}\n      data-oid=\"i8vi:ws\"\n    >\n      {children}\n    </h3>\n  );\n};\n\nconst AlertDescription = ({ children, className = '', ...props }) => {\n  return (\n    <div className={cn('text-sm', className)} {...props} data-oid=\"ls1o2mn\">\n      {children}\n    </div>\n  );\n};\n\nconst AlertActions = ({ children, className = '', ...props }) => {\n  return (\n    <div\n      className={cn('mt-4 flex gap-2', className)}\n      {...props}\n      data-oid=\"9nj4b-2\"\n    >\n      {children}\n    </div>\n  );\n};\n\n// Export compound components\nAlert.Title = AlertTitle;\nAlert.Description = AlertDescription;\nAlert.Actions = AlertActions;\n\nexport default Alert;\nexport { AlertTitle, AlertDescription, AlertActions };\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/ConfirmModal.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":4,"column":1,"nodeType":"Block","endLine":17,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isOpen\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.title\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.message\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.confirmText\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.cancelText\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onConfirm\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onCancel\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.confirmVariant\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.cancelVariant\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport Modal from './Modal';\n\n/**\n * ConfirmModal - A reusable confirmation modal component\n * Uses the existing Modal infrastructure for consistent styling\n * @param root0\n * @param root0.isOpen\n * @param root0.title\n * @param root0.message\n * @param root0.confirmText\n * @param root0.cancelText\n * @param root0.onConfirm\n * @param root0.onCancel\n * @param root0.confirmVariant\n * @param root0.cancelVariant\n */\nconst ConfirmModal = ({\n  isOpen = false,\n  title = 'Confirm Action',\n  message = 'Are you sure you want to proceed?',\n  confirmText = 'Confirm',\n  cancelText = 'Cancel',\n  onConfirm,\n  onCancel,\n  confirmVariant = 'primary',\n  cancelVariant = 'secondary',\n  ...props\n}) => {\n  // Map Button variants to Tailwind classes\n  const getVariantClasses = (variant) => {\n    const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed';\n    \n    const variantClasses = {\n      primary: 'bg-scout-blue text-white hover:bg-scout-blue-dark focus:ring-scout-blue-light active:bg-scout-blue-dark',\n      secondary: 'bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-300 active:bg-gray-700',\n      error: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-300 active:bg-red-800',\n      success: 'bg-green-600 text-white hover:bg-green-700 focus:ring-green-300 active:bg-green-800',\n      warning: 'bg-orange-600 text-white hover:bg-orange-700 focus:ring-orange-300 active:bg-orange-800',\n    };\n    \n    return `${baseClasses} ${variantClasses[variant] || variantClasses.primary}`;\n  };\n\n  const handleConfirm = () => {\n    onConfirm?.();\n  };\n\n  const handleCancel = () => {\n    onCancel?.();\n  };\n\n  return (\n    <Modal\n      isOpen={isOpen}\n      onClose={handleCancel}\n      size=\"sm\"\n      closeOnOverlayClick={false}\n      closeOnEscape={true}\n      showCloseButton={false}\n      {...props}\n      data-oid=\"z5ogv08\"\n    >\n      <Modal.Header data-oid=\"nllwui0\">\n        <Modal.Title data-oid=\"t4l9n15\">{title}</Modal.Title>\n      </Modal.Header>\n\n      <Modal.Body data-oid=\"st9dolf\">\n        <p className=\"text-gray-700 whitespace-pre-line\" data-oid=\"r1mkeo8\">\n          {message}\n        </p>\n      </Modal.Body>\n\n      <Modal.Footer align=\"right\" data-oid=\":03x86e\">\n        <button\n          type=\"button\"\n          className={`${getVariantClasses(cancelVariant)} mr-3`}\n          onClick={handleCancel}\n          data-oid=\"67yua3-\"\n        >\n          {cancelText}\n        </button>\n        <button\n          type=\"button\"\n          className={getVariantClasses(confirmVariant)}\n          onClick={handleConfirm}\n          data-oid=\"ta88f56\"\n        >\n          {confirmText}\n        </button>\n      </Modal.Footer>\n    </Modal>\n  );\n};\n\nexport default ConfirmModal;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/MedicalDataDisplay.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":5,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":7,"column":1,"nodeType":"Block","endLine":7,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.value\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.fieldName\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.data\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.type\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":58,"column":1,"nodeType":"Block","endLine":63,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":58,"column":1,"nodeType":"Block","endLine":63,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":60,"column":1,"nodeType":"Block","endLine":60,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.medicalData\" description.","line":61,"column":1,"nodeType":"Block","endLine":61,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":62,"column":1,"nodeType":"Block","endLine":62,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":85,"column":1,"nodeType":"Block","endLine":90,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":85,"column":1,"nodeType":"Block","endLine":90,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":87,"column":1,"nodeType":"Block","endLine":87,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.member\" description.","line":88,"column":1,"nodeType":"Block","endLine":88,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":89,"column":1,"nodeType":"Block","endLine":89,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":132,"column":1,"nodeType":"Block","endLine":138,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":132,"column":1,"nodeType":"Block","endLine":138,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":134,"column":1,"nodeType":"Block","endLine":134,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.label\" description.","line":135,"column":1,"nodeType":"Block","endLine":135,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.value\" description.","line":136,"column":1,"nodeType":"Block","endLine":136,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.fieldName\" description.","line":137,"column":1,"nodeType":"Block","endLine":137,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":156,"column":1,"nodeType":"Block","endLine":160,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":156,"column":1,"nodeType":"Block","endLine":160,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":158,"column":1,"nodeType":"Block","endLine":158,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.member\" description.","line":159,"column":1,"nodeType":"Block","endLine":159,"endColumn":1}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport { formatMedicalDataForDisplay, getMedicalFieldsFromMember } from '../../utils/medicalDataUtils.js';\n\n/**\n *\n * @param root0\n * @param root0.value\n * @param root0.fieldName\n * @param root0.data\n * @param root0.type\n * @param root0.className\n */\nexport function MedicalDataPill({ value, fieldName, data, type = 'info', className = '' }) {\n  \n  // If using the new format with value/fieldName, process the data\n  let displayData, pillStyles;\n  if (value !== undefined && fieldName) {\n    const formatted = formatMedicalDataForDisplay(value, fieldName);\n    displayData = formatted.display;\n    \n    // Use the indicator styles from the medical data utilities\n    if (formatted.indicator.showPill) {\n      pillStyles = formatted.indicator.pillColor;\n    } else {\n      // For \"None\" cases that don't show a pill, just show text\n      return <span className={`text-xs ${className}`}>{formatted.display}</span>;\n    }\n  } else {\n    // Fall back to original data/type format for backward compatibility\n    displayData = data;\n    const getTypeStyles = (type) => {\n      switch (type) {\n      case 'warning':\n        return 'bg-yellow-100 text-yellow-800 border-yellow-200';\n      case 'danger':\n        return 'bg-red-100 text-red-800 border-red-200';\n      case 'success':\n        return 'bg-green-100 text-green-800 border-green-200';\n      default:\n        return 'bg-blue-100 text-blue-800 border-blue-200';\n      }\n    };\n    pillStyles = getTypeStyles(type);\n  }\n\n  if (!displayData && displayData !== '---') {\n    return null;\n  }\n\n  return (\n    <span className={`inline-flex items-center px-2 py-1 rounded text-xs font-medium ${pillStyles} ${className}`}>\n      {displayData}\n    </span>\n  );\n}\n\n/**\n *\n * @param root0\n * @param root0.medicalData\n * @param root0.className\n */\nexport function MedicalDataList({ medicalData, className = '' }) {\n  if (!medicalData || medicalData.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={`space-y-2 ${className}`}>\n      <h4 className=\"text-sm font-medium text-gray-700\">Medical Information</h4>\n      <div className=\"space-y-1\">\n        {medicalData.map((item, index) => (\n          <MedicalDataPill \n            key={index} \n            data={item.condition || item.text || item} \n            type={item.severity || 'info'}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n/**\n *\n * @param root0\n * @param root0.member\n * @param root0.className\n */\nfunction MedicalDataDisplay({ member, className = '' }) {\n  if (!member || !member.medicalData) {\n    return null;\n  }\n\n  return (\n    <div className={`medical-data-display ${className}`}>\n      <MedicalDataList medicalData={member.medicalData} />\n    </div>\n  );\n}\n\nMedicalDataPill.propTypes = {\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n  fieldName: PropTypes.string,\n  data: PropTypes.string,\n  type: PropTypes.oneOf(['info', 'warning', 'danger', 'success']),\n  className: PropTypes.string,\n};\n\nMedicalDataList.propTypes = {\n  medicalData: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.shape({\n        condition: PropTypes.string,\n        text: PropTypes.string,\n        severity: PropTypes.string,\n      }),\n    ]),\n  ),\n  className: PropTypes.string,\n};\n\nMedicalDataDisplay.propTypes = {\n  member: PropTypes.shape({\n    medicalData: PropTypes.array,\n  }),\n  className: PropTypes.string,\n};\n\n/**\n *\n * @param root0\n * @param root0.label\n * @param root0.value\n * @param root0.fieldName\n */\nexport function MedicalDataField({ label, value, fieldName }) {\n  return (\n    <div>\n      <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n        {label}\n      </label>\n      <div className=\"flex items-start gap-2\">\n        <MedicalDataPill \n          value={value} \n          fieldName={fieldName}\n          className=\"text-sm\"\n        />\n      </div>\n    </div>\n  );\n}\n\n/**\n *\n * @param root0\n * @param root0.member\n */\nexport function MedicalDataSummary({ member }) {\n  const medical = getMedicalFieldsFromMember(member);\n  \n  const hasData = medical.allergies.value || \n                  medical.medical_details.value || \n                  medical.dietary_requirements.value;\n  \n  if (!hasData) {\n    return (\n      <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-green-100 text-green-800 border-green-200\">\n        No medical data\n      </span>\n    );\n  }\n\n  const pillCount = [\n    medical.allergies.value,\n    medical.medical_details.value,\n    medical.dietary_requirements.value,\n  ].filter(Boolean).length;\n\n  return (\n    <span className=\"inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-orange-100 text-orange-800 border-orange-200\">\n      {pillCount} medical condition{pillCount !== 1 ? 's' : ''}\n    </span>\n  );\n}\n\nMedicalDataField.propTypes = {\n  label: PropTypes.string.isRequired,\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n  fieldName: PropTypes.string.isRequired,\n};\n\nMedicalDataSummary.propTypes = {\n  member: PropTypes.object.isRequired,\n};\n\nexport default MedicalDataDisplay;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/MemberDetailModal.jsx","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":8,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":8,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.member\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isOpen\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onClose\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":60,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":17}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef, useState } from 'react';\nimport { isMobileLayout } from '../../utils/platform.js';\nimport { groupContactInfo } from '../../utils/contactGroups.js';\nimport { calculateAge } from '../../utils/ageUtils.js';\nimport { handlePhoneCall } from '../../utils/phoneUtils.js';\nimport { MedicalDataPill } from './MedicalDataDisplay.jsx';\n\n/**\n *\n * @param root0\n * @param root0.member\n * @param root0.isOpen\n * @param root0.onClose\n */\nfunction MemberDetailModal({ member, isOpen, onClose }) {\n  const modalRef = useRef(null);\n  const isMobile = isMobileLayout();\n  const [errorNotification, setErrorNotification] = useState(null);\n\n  // Handle click outside to close\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (modalRef.current && !modalRef.current.contains(event.target)) {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n      document.body.style.overflow = 'hidden'; // Prevent background scroll\n      // Clear any existing error notifications when modal opens\n      setErrorNotification(null);\n    }\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.body.style.overflow = 'unset';\n    };\n  }, [isOpen, onClose]);\n\n  // Handle ESC key\n  useEffect(() => {\n    const handleEscKey = (event) => {\n      if (event.key === 'Escape' && isOpen) {\n        onClose();\n      }\n    };\n\n    document.addEventListener('keydown', handleEscKey);\n    return () => document.removeEventListener('keydown', handleEscKey);\n  }, [isOpen, onClose]);\n\n  if (!isOpen || !member) return null;\n\n  // Handle phone call with error notification\n  const onPhoneCall = (phone) => {\n    handlePhoneCall(phone, (errorMessage) => {\n      setErrorNotification(errorMessage);\n      // Auto-hide error after 5 seconds\n      setTimeout(() => setErrorNotification(null), 5000);\n    });\n  };\n\n\n  const contactGroups = groupContactInfo(member);\n  const age = calculateAge(member.date_of_birth);\n\n  // Helper to check if a field is medical data that should use color coding\n  const isMedicalField = (fieldKey) => {\n    const medicalFields = ['allergies', 'medical_details', 'dietary_requirements'];\n    return medicalFields.includes(fieldKey.toLowerCase());\n  };\n\n  // Group labels for display\n  // Note: Backend cleaning process converts \"Doctor's Surgery\" → \"doctor_s_surgery\"\n  const groupLabels = {\n    primary_contact: 'Primary Contact',\n    primary_contact_1: 'Primary Contact 1',\n    primary_contact_2: 'Primary Contact 2',\n    emergency_contact: 'Emergency Contact',\n    emergency_contact_1: 'Emergency Contact 1',\n    emergency_contact_2: 'Emergency Contact 2',\n    doctor: 'Doctor',\n    doctor_s_surgery: 'Doctor\\'s Surgery', // Maps from \"Doctor's Surgery\" after apostrophe → underscore conversion\n    member_contact: 'Member Contact',\n    medical_information: 'Medical Information',\n    gender: 'Gender',\n    permissions: 'Permissions',\n  };\n\n  return (\n    <div\n      className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4\"\n      data-oid=\"4a:p5i2\"\n    >\n      <div\n        ref={modalRef}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby={`member-modal-title-${member.member_id || member.scoutid}`}\n        aria-describedby={`member-modal-description-${member.member_id || member.scoutid}`}\n        className={`\n          bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden\n          ${isMobile ? 'mx-2' : 'mx-4'}\n        `}\n        data-oid=\"-nqy1gk\"\n      >\n        {/* Header */}\n        <div\n          className=\"bg-scout-blue text-white px-6 py-4 flex items-center justify-between\"\n          data-oid=\"0w81yxn\"\n        >\n          <div className=\"flex items-center space-x-4\" data-oid=\"s48hbia\">\n            <div className=\"flex-shrink-0\" data-oid=\"jhbdbsm\">\n              {member.photo_guid ? (\n                <img\n                  src={`/api/photo/${member.photo_guid}`}\n                  alt={`${member.firstname} ${member.lastname}`}\n                  className=\"w-12 h-12 rounded-full object-cover\"\n                  data-oid=\"8w..8_t\"\n                />\n              ) : (\n                <div\n                  className=\"w-12 h-12 rounded-full bg-scout-purple flex items-center justify-center text-white font-semibold\"\n                  data-oid=\"ts8319g\"\n                >\n                  {member.firstname?.[0]}\n                  {member.lastname?.[0]}\n                </div>\n              )}\n            </div>\n            <div data-oid=\"qo9qxuk\">\n              <h2\n                id={`member-modal-title-${member.member_id || member.scoutid}`}\n                className=\"text-xl font-semibold\"\n                data-oid=\"ydxryqt\"\n              >\n                {member.firstname} {member.lastname}\n              </h2>\n              <div\n                id={`member-modal-description-${member.member_id || member.scoutid}`}\n                className=\"flex items-center space-x-2 text-scout-blue-light\"\n                data-oid=\"ssubb.5\"\n              >\n                {age && <span data-oid=\"dlr.a_x\">Age {age}</span>}\n                {member.patrol && (\n                  <span data-oid=\"cc.tx.o\">• {member.patrol}</span>\n                )}\n                {!age && !member.patrol && (\n                  <span data-oid=\"v5wn5fm\">\n                    Member details and contact information\n                  </span>\n                )}\n              </div>\n            </div>\n          </div>\n          <button\n            onClick={onClose}\n            className=\"text-white hover:text-scout-blue-light transition-colors\"\n            data-oid=\"oqfmm.o\"\n          >\n            <svg\n              className=\"w-6 h-6\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              data-oid=\"tjvij6f\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M6 18L18 6M6 6l12 12\"\n                data-oid=\"r1_8bsk\"\n              />\n            </svg>\n          </button>\n        </div>\n\n        {/* Error Notification */}\n        {errorNotification && (\n          <div\n            className=\"bg-red-50 border-l-4 border-red-400 p-4 mx-6 mt-4 rounded\"\n            data-oid=\"ws7wvy.\"\n          >\n            <div className=\"flex items-center\" data-oid=\"zx1e4ek\">\n              <svg\n                className=\"w-5 h-5 text-red-400 mr-3\"\n                fill=\"currentColor\"\n                viewBox=\"0 0 20 20\"\n                data-oid=\"xkzyiul\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\"\n                  clipRule=\"evenodd\"\n                  data-oid=\"ps.-nft\"\n                />\n              </svg>\n              <p className=\"text-sm text-red-700\" data-oid=\"oc5ok9u\">\n                {errorNotification}\n              </p>\n              <button\n                onClick={() => setErrorNotification(null)}\n                className=\"ml-auto text-red-400 hover:text-red-600\"\n                aria-label=\"Dismiss error\"\n                data-oid=\"cq5cip4\"\n              >\n                <svg\n                  className=\"w-4 h-4\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                  data-oid=\"mfdgtl3\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth={2}\n                    d=\"M6 18L18 6M6 6l12 12\"\n                    data-oid=\"td1:l-j\"\n                  />\n                </svg>\n              </button>\n            </div>\n          </div>\n        )}\n\n        {/* Content - Scrollable */}\n        <div\n          className=\"overflow-y-auto max-h-[calc(90vh-120px)]\"\n          data-oid=\"c6evg-j\"\n        >\n          <div className=\"p-6 space-y-6\" data-oid=\"f:7u082\">\n            {/* Basic Information */}\n            <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"pbzk4gk\">\n              <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"adj.8h8\">\n                <h3 className=\"text-lg font-semibold text-gray-900 m-0\" data-oid=\"c56cxhk\">Basic Information</h3>\n              </div>\n              <div className=\"p-4 space-y-3\" data-oid=\"c3959gi\">\n                <div\n                  className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\"\n                  data-oid=\"5cmma5x\"\n                >\n                  <div data-oid=\".0u8h_r\">\n                    <label\n                      className=\"block text-sm font-medium text-gray-700 mb-1\"\n                      data-oid=\"1_x6fxy\"\n                    >\n                      Member ID\n                    </label>\n                    <p className=\"text-sm text-gray-900\" data-oid=\"oy4zgml\">\n                      {member.scoutid || member.member_id}\n                    </p>\n                  </div>\n                  <div data-oid=\"ux8_pxo\">\n                    <label\n                      className=\"block text-sm font-medium text-gray-700 mb-1\"\n                      data-oid=\"qwx_7vd\"\n                    >\n                      Date of Birth\n                    </label>\n                    <p className=\"text-sm text-gray-900\" data-oid=\"w3:7qgm\">\n                      {member.date_of_birth\n                        ? new Date(member.date_of_birth).toLocaleDateString()\n                        : 'Not provided'}\n                    </p>\n                  </div>\n                  <div data-oid=\"jicupny\">\n                    <label\n                      className=\"block text-sm font-medium text-gray-700 mb-1\"\n                      data-oid=\"6f99mvw\"\n                    >\n                      Section(s)\n                    </label>\n                    <div className=\"flex flex-wrap gap-1\" data-oid=\"1fp8xb2\">\n                      {(() => {\n                        const sections = (\n                          member.sections || [member.sectionname]\n                        ).filter(Boolean);\n                        return sections.length > 0 ? (\n                          sections.map((section, idx) => (\n                            <span\n                              key={idx}\n                              className=\"inline-flex items-center font-medium rounded-full px-2.5 py-0.5 text-xs bg-scout-blue text-white\"\n                              data-oid=\"x9k1uyl\"\n                            >\n                              {section}\n                            </span>\n                          ))\n                        ) : (\n                          <span\n                            className=\"text-sm text-gray-500\"\n                            data-oid=\":mktyw7\"\n                          >\n                            No sections assigned\n                          </span>\n                        );\n                      })()}\n                    </div>\n                  </div>\n                  <div data-oid=\"b17_do0\">\n                    <label\n                      className=\"block text-sm font-medium text-gray-700 mb-1\"\n                      data-oid=\"2:_mv-b\"\n                    >\n                      Member Type\n                    </label>\n                    <span\n                      className={`inline-flex items-center font-medium rounded-full px-2.5 py-0.5 text-xs ${\n                        member.person_type === 'Leaders'\n                          ? 'bg-scout-purple text-white'\n                          : member.person_type === 'Young Leaders'\n                            ? 'bg-scout-blue text-white'\n                            : 'bg-scout-green text-white'\n                      }`}\n                      data-oid=\"_snnuwg\"\n                    >\n                      {member.person_type || 'Young People'}\n                    </span>\n                  </div>\n                  {member.started && (\n                    <div data-oid=\"b72e5m-\">\n                      <label\n                        className=\"block text-sm font-medium text-gray-700 mb-1\"\n                        data-oid=\"du3fy4c\"\n                      >\n                        Started\n                      </label>\n                      <p className=\"text-sm text-gray-900\" data-oid=\"705k0e2\">\n                        {new Date(member.started).toLocaleDateString()}\n                      </p>\n                    </div>\n                  )}\n                  {member.patrol_role_level_label && (\n                    <div data-oid=\"jpbseuq\">\n                      <label\n                        className=\"block text-sm font-medium text-gray-700 mb-1\"\n                        data-oid=\"1:x5cht\"\n                      >\n                        Role\n                      </label>\n                      <p className=\"text-sm text-gray-900\" data-oid=\"uawxzfs\">\n                        {member.patrol_role_level_label}\n                      </p>\n                    </div>\n                  )}\n                </div>\n              </div>\n            </div>\n\n            {/* Essential Information - moved up for immediate visibility */}\n            {contactGroups.essential_information && (\n              <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"_hcy7t3\">\n                <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"ukfj_ep\">\n                  <h3 className=\"text-lg font-semibold text-gray-900 m-0\" data-oid=\"3ilra-k\">\n                    Essential Information\n                  </h3>\n                </div>\n                <div className=\"p-4 space-y-3\" data-oid=\"k1mgp:k\">\n                  <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\" data-oid=\"28l6-m6\">\n                    {Object.entries(contactGroups.essential_information).map(([fieldKey, fieldValue]) => (\n                      <div key={fieldKey} data-oid=\"vvzdn00\">\n                        <label className=\"block text-sm font-medium text-gray-700 mb-1\" data-oid=\"0-.-z__\">\n                          {fieldKey.replace(/_/g, ' ').replace(/\\b\\w/g, (l) => l.toUpperCase())}\n                        </label>\n                        {fieldKey.includes('phone') ? (\n                          <button\n                            type=\"button\"\n                            onClick={() => onPhoneCall(fieldValue)}\n                            onKeyDown={(e) => {\n                              if (e.key === 'Enter' || e.key === ' ') {\n                                e.preventDefault();\n                                onPhoneCall(fieldValue);\n                              }\n                            }}\n                            aria-label={`Call ${fieldValue}`}\n                            className=\"text-sm text-scout-blue hover:text-scout-blue-dark underline cursor-pointer transition-colors focus:outline-none focus:ring-2 focus:ring-scout-blue focus:ring-offset-2 rounded\"\n                            data-oid=\"j21j0lb\"\n                          >\n                            {fieldValue}\n                          </button>\n                        ) : fieldKey.includes('email') ? (\n                          <a\n                            href={`mailto:${fieldValue}`}\n                            rel=\"noopener noreferrer\"\n                            aria-label={`Send email to ${fieldValue}`}\n                            className=\"text-sm text-scout-blue hover:text-scout-blue-dark underline cursor-pointer transition-colors\"\n                            data-oid=\"q4r:6l_\"\n                          >\n                            {fieldValue}\n                          </a>\n                        ) : isMedicalField(fieldKey) ? (\n                          <MedicalDataPill \n                            value={fieldValue} \n                            fieldName={fieldKey}\n                            className=\"text-sm\"\n                          />\n                        ) : (\n                          <p className=\"text-sm text-gray-900 whitespace-pre-wrap\" data-oid=\"yj2ex-_\">\n                            {fieldValue}\n                          </p>\n                        )}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Consents */}\n            {contactGroups.consents && (\n              <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"_hcy7t3\">\n                <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"ukfj_ep\">\n                  <h3 className=\"text-lg font-semibold text-gray-900 m-0\" data-oid=\"3ilra-k\">\n                    Consents\n                  </h3>\n                </div>\n                <div className=\"p-4 space-y-3\" data-oid=\"k1mgp:k\">\n                  <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\" data-oid=\"28l6-m6\">\n                    {Object.entries(contactGroups.consents).map(([fieldKey, fieldValue]) => (\n                      <div key={fieldKey} data-oid=\"vvzdn00\">\n                        <label className=\"block text-sm font-medium text-gray-700 mb-1\" data-oid=\"0-.-z__\">\n                          {fieldKey.replace(/_/g, ' ').replace(/\\b\\w/g, (l) => l.toUpperCase())}\n                        </label>\n                        <p className=\"text-sm text-gray-900 whitespace-pre-wrap\" data-oid=\"yj2ex-_\">\n                          {fieldValue}\n                        </p>\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Remaining Contact Information */}\n            {Object.entries(contactGroups)\n              .filter(([groupKey]) => !['essential_information', 'consents'].includes(groupKey))\n              .map(([groupKey, groupData]) => (\n                <div key={groupKey} className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"_hcy7t3\">\n                  <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"ukfj_ep\">\n                    <h3 className=\"text-lg font-semibold text-gray-900 m-0\" data-oid=\"3ilra-k\">\n                      {groupLabels[groupKey] ||\n                      groupKey\n                        .replace(/_/g, ' ')\n                        .replace(/\\b\\w/g, (l) => l.toUpperCase())}\n                    </h3>\n                  </div>\n                  <div className=\"p-4 space-y-3\" data-oid=\"k1mgp:k\">\n                    <div\n                      className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\"\n                      data-oid=\"28l6-m6\"\n                    >\n                      {Object.entries(groupData).map(([fieldKey, fieldValue]) => (\n                        <div key={fieldKey} data-oid=\"vvzdn00\">\n                          <label\n                            className=\"block text-sm font-medium text-gray-700 mb-1\"\n                            data-oid=\"0-.-z__\"\n                          >\n                            {fieldKey\n                              .replace(/_/g, ' ')\n                              .replace(/\\b\\w/g, (l) => l.toUpperCase())}\n                          </label>\n                          {fieldKey.includes('phone') ? (\n                            <button\n                              type=\"button\"\n                              onClick={() => onPhoneCall(fieldValue)}\n                              onKeyDown={(e) => {\n                                if (e.key === 'Enter' || e.key === ' ') {\n                                  e.preventDefault();\n                                  onPhoneCall(fieldValue);\n                                }\n                              }}\n                              aria-label={`Call ${fieldValue}`}\n                              className=\"text-sm text-scout-blue hover:text-scout-blue-dark underline cursor-pointer transition-colors focus:outline-none focus:ring-2 focus:ring-scout-blue focus:ring-offset-2 rounded\"\n                              data-oid=\"j21j0lb\"\n                            >\n                              {fieldValue}\n                            </button>\n                          ) : fieldKey.includes('email') ? (\n                            <a\n                              href={`mailto:${fieldValue}`}\n                              rel=\"noopener noreferrer\"\n                              aria-label={`Send email to ${fieldValue}`}\n                              className=\"text-sm text-scout-blue hover:text-scout-blue-dark underline cursor-pointer transition-colors\"\n                              data-oid=\"q4r:6l_\"\n                            >\n                              {fieldValue}\n                            </a>\n                          ) : isMedicalField(fieldKey) ? (\n                            <MedicalDataPill \n                              value={fieldValue} \n                              fieldName={fieldKey}\n                              className=\"text-sm\"\n                            />\n                          ) : (\n                            <p\n                              className=\"text-sm text-gray-900 whitespace-pre-wrap\"\n                              data-oid=\"yj2ex-_\"\n                            >\n                              {fieldValue}\n                            </p>\n                          )}\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                </div>\n              ))}\n\n            {/* Legacy emergency contacts if available */}\n            {member.emergency_contacts &&\n              member.emergency_contacts.length > 0 && (\n              <div className=\"bg-white rounded-lg border border-gray-200 shadow-sm\" data-oid=\"5j0ykq7\">\n                <div className=\"px-4 py-3 border-b border-gray-200 bg-gray-50 rounded-t-lg\" data-oid=\"50z4nlo\">\n                  <h3 className=\"text-lg font-semibold text-gray-900 m-0\" data-oid=\"9w1o:j5\">\n                      Emergency Contacts (Legacy)\n                  </h3>\n                </div>\n                <div className=\"p-4 space-y-3\" data-oid=\"1n:bfai\">\n                  {member.emergency_contacts.map((contact, idx) => (\n                    <div\n                      key={idx}\n                      className=\"border-b border-gray-200 pb-3 last:border-b-0\"\n                      data-oid=\"c074mao\"\n                    >\n                      <div\n                        className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\"\n                        data-oid=\"n14le-2\"\n                      >\n                        {Object.entries(contact).map(([key, value]) => (\n                          <div key={key} data-oid=\"0.tysyp\">\n                            <label\n                              className=\"block text-sm font-medium text-gray-700 mb-1\"\n                              data-oid=\"s.mc1r:\"\n                            >\n                              {key\n                                .replace(/_/g, ' ')\n                                .replace(/\\b\\w/g, (l) => l.toUpperCase())}\n                            </label>\n                            {key.includes('phone') ? (\n                              <button\n                                onClick={() => onPhoneCall(value)}\n                                className=\"text-sm text-scout-blue hover:text-scout-blue-dark underline cursor-pointer transition-colors\"\n                                data-oid=\"wf8xba-\"\n                              >\n                                {value}\n                              </button>\n                            ) : (\n                              <p\n                                className=\"text-sm text-gray-900\"\n                                data-oid=\"vviarjy\"\n                              >\n                                {value}\n                              </p>\n                            )}\n                          </div>\n                        ))}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n\n          </div>\n        </div>\n\n        {/* Footer */}\n        <div\n          className=\"bg-gray-50 px-6 py-4 flex justify-end\"\n          data-oid=\"kg_9nkz\"\n        >\n          <button\n            onClick={onClose}\n            className=\"inline-flex items-center justify-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-scout-blue focus:ring-offset-2 transition-colors\"\n            data-oid=\"u6m635w\"\n          >\n            Close\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default MemberDetailModal;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/Modal.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":5,"column":1,"nodeType":"Block","endLine":17,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0\" description.","line":8,"column":1,"nodeType":"Block","endLine":8,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.isOpen\" description.","line":9,"column":1,"nodeType":"Block","endLine":9,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.onClose\" description.","line":10,"column":1,"nodeType":"Block","endLine":10,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.size\" description.","line":11,"column":1,"nodeType":"Block","endLine":11,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.showCloseButton\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.closeOnOverlayClick\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.closeOnEscape\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.className\" description.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"root0.children\" description.","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { cn } from '../../utils/cn';\n\n/**\n * Tailwind-based Modal component with Scout theming\n * Supports different sizes and accessibility features\n * @param root0\n * @param root0.isOpen\n * @param root0.onClose\n * @param root0.size\n * @param root0.showCloseButton\n * @param root0.closeOnOverlayClick\n * @param root0.closeOnEscape\n * @param root0.className\n * @param root0.children\n */\nconst Modal = ({\n  isOpen = false,\n  onClose,\n  size = 'md',\n  showCloseButton = true,\n  closeOnOverlayClick = true,\n  closeOnEscape = true,\n  className = '',\n  children,\n  ...props\n}) => {\n  const modalRef = useRef(null);\n\n  // Handle escape key\n  useEffect(() => {\n    if (!closeOnEscape || !isOpen) return;\n\n    const handleEscape = (e) => {\n      if (e.key === 'Escape') {\n        onClose?.();\n      }\n    };\n\n    document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [isOpen, closeOnEscape, onClose]);\n\n  // Handle body scroll lock\n  useEffect(() => {\n    if (isOpen) {\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = 'unset';\n    }\n\n    return () => {\n      document.body.style.overflow = 'unset';\n    };\n  }, [isOpen]);\n\n  // Focus management\n  useEffect(() => {\n    if (isOpen && modalRef.current) {\n      modalRef.current.focus();\n    }\n  }, [isOpen]);\n\n  const sizes = {\n    xs: 'max-w-xs',\n    sm: 'max-w-sm',\n    md: 'max-w-md',\n    lg: 'max-w-lg',\n    xl: 'max-w-xl',\n    '2xl': 'max-w-2xl',\n    '3xl': 'max-w-3xl',\n    '4xl': 'max-w-4xl',\n    '5xl': 'max-w-5xl',\n    '6xl': 'max-w-6xl',\n    '7xl': 'max-w-7xl',\n    full: 'max-w-full',\n  };\n\n  const handleOverlayClick = (e) => {\n    if (closeOnOverlayClick && e.target === e.currentTarget) {\n      onClose?.();\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const modalContent = (\n    <div className=\"fixed inset-0 z-50 overflow-y-auto\" data-oid=\"0j002ev\">\n      {/* Backdrop */}\n      <div\n        className=\"fixed inset-0 bg-black bg-opacity-50 transition-opacity\"\n        onClick={handleOverlayClick}\n        data-oid=\"9xzdqvm\"\n      />\n\n      {/* Modal */}\n      <div\n        className=\"flex items-center justify-center min-h-full p-4\"\n        data-oid=\"gup2bpa\"\n      >\n        <div\n          ref={modalRef}\n          tabIndex={-1}\n          className={cn(\n            'relative bg-white rounded-lg shadow-xl transform transition-all w-full',\n            sizes[size],\n            className,\n          )}\n          {...props}\n          data-oid=\"cja.ic5\"\n        >\n          {showCloseButton && (\n            <button\n              onClick={onClose}\n              className=\"absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors z-10\"\n              aria-label=\"Close modal\"\n              data-oid=\"kk.x6s6\"\n            >\n              <svg\n                className=\"w-6 h-6\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n                data-oid=\"yz3e3lm\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M6 18L18 6M6 6l12 12\"\n                  data-oid=\"7y0ojfl\"\n                />\n              </svg>\n            </button>\n          )}\n\n          {children}\n        </div>\n      </div>\n    </div>\n  );\n\n  // Use portal to render modal at body level\n  return createPortal(modalContent, document.body);\n};\n\nconst ModalHeader = ({ children, className = '', ...props }) => {\n  return (\n    <div\n      className={cn('px-6 py-4 border-b border-gray-200', className)}\n      {...props}\n      data-oid=\"u_gqh6x\"\n    >\n      {children}\n    </div>\n  );\n};\n\nconst ModalTitle = ({\n  children,\n  className = '',\n  as: Component = 'h2',\n  ...props\n}) => {\n  return (\n    <Component\n      className={cn('text-xl font-semibold text-gray-900 pr-8', className)}\n      {...props}\n      data-oid=\"fyw.-_:\"\n    >\n      {children}\n    </Component>\n  );\n};\n\nconst ModalBody = ({ children, className = '', ...props }) => {\n  return (\n    <div className={cn('px-6 py-4', className)} {...props} data-oid=\"6je2995\">\n      {children}\n    </div>\n  );\n};\n\nconst ModalFooter = ({\n  children,\n  align = 'right',\n  className = '',\n  ...props\n}) => {\n  const alignClasses = {\n    left: 'justify-start',\n    center: 'justify-center',\n    right: 'justify-end',\n    between: 'justify-between',\n  };\n\n  return (\n    <div\n      className={cn(\n        'px-6 py-4 border-t border-gray-200 flex gap-3',\n        alignClasses[align],\n        className,\n      )}\n      {...props}\n      data-oid=\"nc3lcsc\"\n    >\n      {children}\n    </div>\n  );\n};\n\n// Export compound components\nModal.Header = ModalHeader;\nModal.Title = ModalTitle;\nModal.Body = ModalBody;\nModal.Footer = ModalFooter;\n\nexport default Modal;\nexport { ModalHeader, ModalTitle, ModalBody, ModalFooter };\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/SectionCardsFlexMasonry.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/SectionFilter.jsx","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":3,"column":1,"nodeType":"Block","endLine":12,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, memo } from 'react';\n\n/**\n * SectionFilter - Reusable pill-based filter for sections\n * Provides toggle buttons for filtering by section similar to attendance status filters\n *\n * @param {object} props - Component props\n * @param {object} props.sectionFilters - Object mapping section IDs to boolean visibility\n * @param {Function} props.onFiltersChange - Callback when filters change\n * @param {Array} props.sections - Array of section objects with sectionid and sectionname\n * @param {string} props.className - Additional CSS classes\n */\nfunction SectionFilter({\n  sectionFilters,\n  onFiltersChange,\n  sections,\n  className = '',\n}) {\n  const handleFilterToggle = useCallback((sectionId) => {\n    if (!sectionId || typeof onFiltersChange !== 'function') return;\n    \n    const newFilters = {\n      ...sectionFilters,\n      [sectionId]: !sectionFilters[sectionId],\n    };\n    onFiltersChange(newFilters);\n  }, [sectionFilters, onFiltersChange]);\n\n  // Get section color based on section type (matching dashboard colors)\n  const getSectionColor = useCallback((section) => {\n    if (!section) {\n      return 'bg-scout-purple text-white border-scout-purple';\n    }\n    \n    // Try to determine section type from sectionname or section field\n    const sectionType = (\n      section.section ||\n      section.sectionname ||\n      ''\n    ).toLowerCase();\n\n    if (sectionType.includes('earlyyears'))\n      return 'bg-scout-red text-white border-scout-red';\n    if (sectionType.includes('beavers'))\n      return 'bg-scout-blue text-white border-scout-blue';\n    if (sectionType.includes('cubs'))\n      return 'bg-scout-forest-green text-white border-scout-forest-green';\n    if (sectionType.includes('scouts'))\n      return 'bg-scout-navy text-white border-scout-navy';\n    if (sectionType.includes('adults'))\n      return 'bg-scout-purple text-white border-scout-purple';\n    if (sectionType.includes('waitinglist'))\n      return 'bg-scout-teal text-white border-scout-teal';\n\n    // Default fallback to purple for unknown sections\n    return 'bg-scout-purple text-white border-scout-purple';\n  }, []);\n\n  if (!sections || sections.length === 0) {\n    return null;\n  }\n\n  return (\n    <div\n      className={`flex gap-2 flex-wrap items-center ${className}`}\n      role=\"group\"\n      aria-label=\"Section filters\"\n      data-oid=\"oh13yim\"\n    >\n      {/* Individual section filters */}\n      {sections.map((section) => {\n        const isActive = sectionFilters[section.sectionid];\n        const activeStyles = getSectionColor(section);\n        const colorName = activeStyles.match(/bg-scout-([\\w-]+)/)?.[1];\n        const inactiveStyles = colorName \n          ? `bg-white text-scout-${colorName} border-2 border-scout-${colorName}`\n          : 'bg-white text-gray-600 border-2 border-gray-300';\n\n        return (\n          <button\n            key={section.sectionid}\n            onClick={() => handleFilterToggle(section.sectionid)}\n            className={`px-3 py-1 text-xs font-medium rounded-full transition-all duration-200 hover:shadow-sm ${\n              isActive ? activeStyles : inactiveStyles\n            }`}\n            type=\"button\"\n            aria-pressed={isActive}\n            aria-label={`Filter by ${section.sectionname} section`}\n            title={section.sectionname}\n            data-oid=\"7y4f3-0\"\n          >\n            {section.sectionname}\n          </button>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default memo(SectionFilter);","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/components/ui/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/hooks/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/hooks/useSignInOut.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'AbortController' is not defined.","line":32,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":32,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":288,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":288,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":311,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":311,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":334,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":334,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":394,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":394,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":479,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":479,"endColumn":21}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useRef, useEffect } from 'react';\nimport { fetchMostRecentTermId, updateFlexiRecord } from '../services/api/api.js';\nimport { getFlexiRecordsList } from '../../features/events/services/flexiRecordService.js';\n// TODO: Move getFlexiRecordStructure to shared layer to avoid circular dependency\n// import { getFlexiRecordStructure } from '../../features/events/services/flexiRecordService.js';\nimport { parseFlexiStructure } from '../utils/flexiRecordTransforms.js';\nimport { getToken } from '../services/auth/tokenService.js';\nimport { safeGetItem, safeGetSessionItem } from '../utils/storageUtils.js';\nimport { isDemoMode } from '../../config/demoMode.js';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\n\n// Inter-call delay to prevent API clashing - tunable for flaky APIs\nconst STEP_DELAY_MS = 150;\n\n/**\n * Custom hook for handling sign-in/out functionality with memory leak prevention\n * \n * @param {Array} events - Array of event data\n * @param {Function} onDataRefresh - Callback to refresh Viking Event data after operations\n * @param {object} notificationHandlers - Optional notification handlers from toast utilities\n * @param {Function} notificationHandlers.notifyError - Function to display error notifications\n * @param {Function} notificationHandlers.notifyWarning - Function to display warning notifications\n * @returns {object} Hook state and functions\n */\nexport function useSignInOut(events, onDataRefresh, notificationHandlers = {}) {\n  const [buttonLoading, setButtonLoading] = useState({});\n  const abortControllerRef = useRef(null);\n  const { notifyError, notifyWarning } = notificationHandlers;\n\n  // Initialize AbortController and cleanup on unmount to prevent memory leaks\n  useEffect(() => {\n    abortControllerRef.current = new AbortController();\n    \n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  // Get current user info from cached startup data  \n  const getCurrentUserInfo = () => {\n    // First try sessionStorage user_info (set during auth)\n    const userInfo = safeGetSessionItem('user_info', {});\n    if (userInfo.firstname && userInfo.lastname) {\n      return userInfo;\n    }\n    \n    // Fallback to startup data in localStorage with demo mode awareness\n    const demoMode = isDemoMode();\n    const cacheKey = demoMode ? 'demo_viking_startup_data_offline' : 'viking_startup_data_offline';\n    const startupData = safeGetItem(cacheKey, {});\n    // Prefer globals (where user info is actually stored) before falling back\n    const fromGlobals = startupData?.globals\n      ? { firstname: startupData.globals.firstname, lastname: startupData.globals.lastname }\n      : null;\n    return fromGlobals || { firstname: 'Unknown', lastname: 'User' };\n  };\n\n  // Helper to get field ID from field mapping\n  const getFieldId = (fieldName, fieldMapping) => {\n    for (const [fieldId, fieldInfo] of fieldMapping.entries()) {\n      if (fieldInfo.name === fieldName) {\n        return fieldId;\n      }\n    }\n    throw new Error(`Field '${fieldName}' not found in flexirecord structure`);\n  };\n\n  // Get Viking Event Mgmt flexirecord data for a section\n  const getVikingEventFlexiRecord = async (sectionId, termId, token) => {\n    // Use the same fallback mechanism as camp groups - check localStorage directly\n    try {\n      const structureKeys = Object.keys(localStorage).filter(key => \n        key.includes('viking_flexi_structure_') && key.includes('offline'),\n      );\n      \n      const dataKeys = Object.keys(localStorage).filter(key => \n        key.includes('viking_flexi_data_') && key.includes(`_${sectionId}_`) && key.includes('offline'),\n      );\n      \n      console.log('🐛 Sign-in/out: Found cache keys:', {\n        structureKeys,\n        dataKeys,\n        sectionId,\n      });\n\n      if (structureKeys.length > 0 && dataKeys.length > 0) {\n        // Also check the data to see what FlexiRecord ID matches\n        const dataKey = dataKeys[0];\n        const keyParts = dataKey.replace('viking_flexi_data_', '').replace('_offline', '').split('_');\n        const realFlexiRecordId = keyParts[0];\n        \n        console.log('🐛 Sign-in/out: Data key analysis:', {\n          dataKey,\n          realFlexiRecordId,\n          keyParts,\n        });\n        \n        // Try to find a structure that matches this FlexiRecord ID\n        for (const structureKey of structureKeys) {\n          try {\n            const structureData = JSON.parse(localStorage.getItem(structureKey));\n            \n            console.log('🐛 Sign-in/out: Examining structure:', {\n              structureKey,\n              structureFlexiRecordId: structureData?.flexirecordid || structureData?._structure?.flexirecordid,\n              structureExtraid: structureData?.extraid || structureData?._structure?.extraid,\n              expectedFlexiRecordId: realFlexiRecordId,\n              hasFieldMapping: !!structureData?.fieldMapping,\n              hasStructureFieldMapping: !!structureData?._structure?.fieldMapping,\n              actualStructure: structureData, // Show the full structure for debugging\n            });\n            \n            // Check if this structure matches the FlexiRecord ID from the data\n            // In OSM API, flexirecordid is stored as extraid\n            const structureFlexiRecordId = structureData?.extraid || structureData?._structure?.extraid || \n                                         structureData?.flexirecordid || structureData?._structure?.flexirecordid;\n            if (String(structureFlexiRecordId) !== String(realFlexiRecordId)) {\n              console.log('🐛 Sign-in/out: Structure FlexiRecord ID mismatch, skipping');\n              continue;\n            }\n            \n            // Parse the raw structure to get field mapping (same as flexiRecordService does)\n            const fieldMapping = {};\n            try {\n              const parsedMapping = parseFlexiStructure(structureData);\n              if (parsedMapping && parsedMapping.size > 0) {\n                // Convert fieldMapping Map to object (same format as flexiRecordService)\n                parsedMapping.forEach((fieldInfo, fieldId) => {\n                  fieldMapping[fieldId] = {\n                    columnId: fieldId,\n                    ...fieldInfo,\n                  };\n                });\n                console.log('🐛 Sign-in/out: Parsed structure:', {\n                  structureKey,\n                  parsedFieldCount: parsedMapping.size,\n                });\n              }\n            } catch (error) {\n              console.log('🐛 Sign-in/out: Failed to parse structure:', error);\n            }\n            \n            const fieldNames = Object.values(fieldMapping).map(f => f?.name).filter(Boolean);\n            \n            console.log('🐛 Sign-in/out: Structure field analysis:', {\n              structureKey,\n              fieldMapping: Object.keys(fieldMapping).length > 0 ? fieldMapping : 'empty',\n              fieldNames,\n              rawStructureKeys: Object.keys(structureData || {}),\n              hasStructureProperty: !!structureData?._structure,\n              structureColumns: structureData?.structure?.cols || structureData?.cols || 'none',\n            });\n            \n            // Look for SignedOutBy field (case insensitive)\n            const hasSignedOutByField = Object.values(fieldMapping).some(field => {\n              const name = field.name?.toLowerCase();\n              return name === 'signedoutby' || name === 'signed out by';\n            });\n            \n            if (hasSignedOutByField) {\n              console.log('🐛 Sign-in/out: Found Viking Event structure with SignedOutBy field:', {\n                structureKey,\n                realFlexiRecordId,\n                fieldNames,\n              });\n              \n              return {\n                extraid: realFlexiRecordId,\n                structure: structureData,\n                fieldMapping: parseFlexiStructure(structureData._structure || structureData),\n              };\n            } else {\n              console.log('🐛 Sign-in/out: Structure missing SignedOutBy field:', {\n                structureKey,\n                fieldNames,\n              });\n            }\n          } catch (error) {\n            console.warn('Failed to parse Viking Event structure:', structureKey, error);\n          }\n        }\n      }\n      \n      console.log('🐛 Sign-in/out: No suitable Viking Event structure found in cache', {\n        structureKeys: structureKeys.length,\n        dataKeys: dataKeys.length,\n        sectionId,\n      });\n      \n    } catch (error) {\n      console.warn('Failed to load Viking Event data from cache:', error);\n    }\n    \n    // Fallback to Viking Event FlexiRecords approach (same as camp groups)\n    const flexiRecords = await getFlexiRecordsList(sectionId, token);\n    \n    const vikingRecord = flexiRecords.items.find(record => \n      record.name && record.name.toLowerCase().includes('viking event'),\n    );\n    \n    if (!vikingRecord) {\n      throw new Error('Viking Event Mgmt flexirecord not found for this section');\n    }\n    \n    console.log('🐛 Sign-in/out: Found Viking Event flexirecord from API:', {\n      extraid: vikingRecord.extraid,\n      name: vikingRecord.name,\n    });\n    \n    // The TODO is that we need to get the structure for this flexirecord\n    // For now, this will cause the \"Field 'SignedOutBy' not found\" error\n    // because we don't have the structure to parse the field mapping\n    throw new Error('FlexiRecord structure not available - need to implement structure fetching for FlexiRecord ID: ' + vikingRecord.extraid);\n  };\n\n  // Main sign in/out handler with memory leak prevention\n  const handleSignInOut = async (member, action) => {\n    // Freeze token for this operation to ensure consistency\n    const opToken = getToken();\n    \n    try {\n      // Check if component is still mounted before starting\n      if (abortControllerRef.current?.signal.aborted) {\n        return;\n      }\n      \n      // Set loading state for this specific button\n      setButtonLoading(prev => ({ ...prev, [member.scoutid]: true }));\n      \n      // Get current user info from cached startup data\n      const userInfo = getCurrentUserInfo();\n      const currentUser = `${userInfo.firstname} ${userInfo.lastname}`;\n      const timestamp = new Date().toISOString();\n      \n      // Get termId from events\n      const event = events.find(e => e.sectionid === member.sectionid);\n      const termId = event?.termid || await fetchMostRecentTermId(member.sectionid, opToken);\n      \n      if (!termId) {\n        throw new Error('No term ID available - required for flexirecord updates');\n      }\n      \n      // Get section type from cached section config\n      const demoMode = isDemoMode();\n      const sectionsKey = demoMode\n        ? 'demo_viking_sections_offline'\n        : 'viking_sections_offline';\n      const cachedSections = safeGetItem(sectionsKey, []);\n      const sectionConfig = cachedSections.find(section => section.sectionid === member.sectionid);\n      const sectionType = sectionConfig?.sectiontype || 'beavers';\n      \n      // Get Viking Event Mgmt flexirecord structure for this section\n      const vikingFlexiRecord = await getVikingEventFlexiRecord(member.sectionid, termId, opToken);\n      \n      // Check if component is still mounted after async operation\n      if (abortControllerRef.current?.signal.aborted) {\n        return;\n      }\n      \n      if (action === 'signin') {\n        // Execute API calls sequentially with longer delays to prevent clashing\n        const callNames = ['SignedInBy', 'SignedInWhen', 'Clear SignedOutBy', 'Clear SignedOutWhen'];\n        \n        try {\n          // Step 1: Set SignedInBy\n          logger.info(`Setting ${callNames[0]} for member`, {\n            memberName: member.name || member.firstname,\n            action: callNames[0],\n          }, LOG_CATEGORIES.API);\n          await updateFlexiRecord(\n            member.sectionid,\n            member.scoutid,\n            vikingFlexiRecord.extraid,\n            getFieldId('SignedInBy', vikingFlexiRecord.fieldMapping),\n            currentUser,\n            termId,\n            sectionType,\n            opToken,\n          );\n          logger.info(`${callNames[0]} completed successfully`, {\n            memberName: member.name || member.firstname,\n            action: callNames[0],\n          }, LOG_CATEGORIES.API);\n          \n          // Delay to prevent clashing\n          await new Promise(r => setTimeout(r, STEP_DELAY_MS));\n          \n          // Step 2: Set SignedInWhen\n          logger.info(`Setting ${callNames[1]} for member`, {\n            memberName: member.name || member.firstname,\n            action: callNames[1],\n          }, LOG_CATEGORIES.API);\n          await updateFlexiRecord(\n            member.sectionid,\n            member.scoutid,\n            vikingFlexiRecord.extraid,\n            getFieldId('SignedInWhen', vikingFlexiRecord.fieldMapping),\n            timestamp,\n            termId,\n            sectionType,\n            opToken,\n          );\n          logger.info(`${callNames[1]} completed successfully`, {\n            memberName: member.name || member.firstname,\n            action: callNames[1],\n          }, LOG_CATEGORIES.API);\n          \n          // Delay to prevent clashing\n          await new Promise(r => setTimeout(r, STEP_DELAY_MS));\n          \n          // Step 3: Clear SignedOutBy\n          logger.info(`${callNames[2]} for member`, {\n            memberName: member.name || member.firstname,\n            action: callNames[2],\n          }, LOG_CATEGORIES.API);\n          await updateFlexiRecord(\n            member.sectionid,\n            member.scoutid,\n            vikingFlexiRecord.extraid,\n            getFieldId('SignedOutBy', vikingFlexiRecord.fieldMapping),\n            '', // Clear the field\n            termId,\n            sectionType,\n            opToken,\n          );\n          logger.info(`${callNames[2]} completed successfully`, {\n            memberName: member.name || member.firstname,\n            action: callNames[2],\n          }, LOG_CATEGORIES.API);\n          \n          // Delay to prevent clashing\n          await new Promise(r => setTimeout(r, STEP_DELAY_MS));\n          \n          // Step 4: Clear SignedOutWhen\n          logger.info(`${callNames[3]} for member`, {\n            memberName: member.name || member.firstname,\n            action: callNames[3],\n          }, LOG_CATEGORIES.API);\n          await updateFlexiRecord(\n            member.sectionid,\n            member.scoutid,\n            vikingFlexiRecord.extraid,\n            getFieldId('SignedOutWhen', vikingFlexiRecord.fieldMapping),\n            '', // Clear the field\n            termId,\n            sectionType,\n            opToken,\n          );\n          logger.info(`${callNames[3]} completed successfully`, {\n            memberName: member.name || member.firstname,\n            action: callNames[3],\n          }, LOG_CATEGORIES.API);\n          \n        } catch (callError) {\n          logger.error('Sign-in operation failed', { \n            error: callError.message,\n            memberName: member.name || member.firstname, \n          }, LOG_CATEGORIES.API);\n          throw callError; // Re-throw to be handled by outer catch\n        }\n        \n        // Check if component is still mounted after sign-in operations\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n        \n        // Member signed in successfully\n      } else {\n        // Execute sign-out API calls sequentially with longer delays to prevent clashing\n        try {\n          // Step 1: Set SignedOutBy\n          logger.info('Setting SignedOutBy for member', {\n            memberName: member.name || member.firstname,\n            action: 'SignedOutBy',\n          }, LOG_CATEGORIES.API);\n          await updateFlexiRecord(\n            member.sectionid,\n            member.scoutid,\n            vikingFlexiRecord.extraid,\n            getFieldId('SignedOutBy', vikingFlexiRecord.fieldMapping),\n            currentUser,\n            termId,\n            sectionType,\n            opToken,\n          );\n          logger.info('SignedOutBy completed successfully', {\n            memberName: member.name || member.firstname,\n            action: 'SignedOutBy',\n          }, LOG_CATEGORIES.API);\n          \n          // Delay to prevent clashing\n          await new Promise(r => setTimeout(r, STEP_DELAY_MS));\n          \n          // Step 2: Set SignedOutWhen\n          logger.info('Setting SignedOutWhen for member', {\n            memberName: member.name || member.firstname,\n            action: 'SignedOutWhen',\n          }, LOG_CATEGORIES.API);\n          await updateFlexiRecord(\n            member.sectionid,\n            member.scoutid,\n            vikingFlexiRecord.extraid,\n            getFieldId('SignedOutWhen', vikingFlexiRecord.fieldMapping),\n            timestamp,\n            termId,\n            sectionType,\n            opToken,\n          );\n          logger.info('SignedOutWhen completed successfully', {\n            memberName: member.name || member.firstname,\n            action: 'SignedOutWhen',\n          }, LOG_CATEGORIES.API);\n          \n        } catch (callError) {\n          logger.error('Sign-out operation failed', { \n            error: callError.message,\n            memberName: member.name || member.firstname, \n          }, LOG_CATEGORIES.API);\n          throw callError; // Re-throw to be handled by outer catch\n        }\n        \n        // Check if component is still mounted after sign-out operations\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n        \n        // Member signed out successfully\n      }\n      \n      // Check if component is still mounted before refreshing data\n      if (abortControllerRef.current?.signal.aborted) {\n        return;\n      }\n      \n      // Refresh Viking Event data to show updates\n      if (onDataRefresh) {\n        await onDataRefresh();\n      }\n      \n    } catch (error) {\n      // Don't show errors if component was unmounted\n      if (abortControllerRef.current?.signal.aborted) {\n        return;\n      }\n      \n      const memberLabel = member.name || member.firstname || String(member.scoutid);\n      logger.error(`Failed to ${action === 'signin' ? 'sign in' : 'sign out'} member`, {\n        member: { id: member.scoutid, label: memberLabel },\n        action,\n        error: error?.stack || error?.message || String(error),\n      }, LOG_CATEGORIES.API);\n      \n      // Check if this is a token expiration error\n      if (error.message?.includes('No authentication token')) {\n        // Handle authentication failure to trigger auth state update\n        // TODO: Move handleApiAuthError to shared layer\n        const authResult = { offline: false, shouldReload: false }; // Temporary mock\n        \n        if (authResult.offline) {\n          // Token expired but we have cached data - user can still use app offline\n          if (notifyWarning) {\n            notifyWarning('Your session has expired. Please sign in again to refresh data from OSM, or continue using cached data offline.');\n          } else {\n            console.warn('Session expired with offline mode available');\n          }\n        } else {\n          // No cached data available - user needs to log in\n          if (notifyError) {\n            notifyError('Your session has expired. Please sign in to OSM to continue.');\n          } else {\n            console.error('Session expired without cached data');\n          }\n        }\n        \n        // Force a page reload to trigger auth state re-evaluation\n        if (authResult.shouldReload) {\n          setTimeout(() => {\n            window.location.reload();\n          }, 100);\n        }\n      } else {\n        // Regular error - show generic message\n        if (notifyError) {\n          notifyError(`Failed to ${action === 'signin' ? 'sign in' : 'sign out'} ${memberLabel}: ${error.message}`);\n        } else {\n          console.error(`Sign in/out failed: ${error.message}`);\n        }\n      }\n      \n    } finally {\n      // Only clear loading state if component is still mounted\n      if (!abortControllerRef.current?.signal.aborted) {\n        setButtonLoading(prev => ({ ...prev, [member.scoutid]: false }));\n      }\n    }\n  };\n\n  return {\n    buttonLoading,\n    handleSignInOut,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/hooks/useURLSync.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":7,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":7,"column":1,"nodeType":"Block","endLine":9,"endColumn":4},{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":17,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":42}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect } from 'react';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\nimport { useAppState } from '../../contexts/app';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\n\n// Custom hook for synchronizing application state with URL parameters\n/**\n *\n */\nexport function useURLSync() {\n  const navigate = useNavigate();\n  const [searchParams, setSearchParams] = useSearchParams();\n  const { state, setNavigationData } = useAppState();\n  \n  // Update URL when navigation data changes\n  const syncStateToURL = useCallback((stateData = {}) => {\n    const newParams = new URLSearchParams(searchParams);\n    \n    // Clear existing navigation params\n    newParams.delete('event');\n    newParams.delete('section');\n    \n    // Add current navigation data to URL parameters\n    const { selectedEvent, selectedSection } = stateData.navigationData || state.navigationData;\n    \n    if (selectedEvent) {\n      newParams.set('event', selectedEvent);\n    }\n    \n    if (selectedSection) {\n      newParams.set('section', selectedSection);\n    }\n    \n    // Update URL parameters without navigation\n    setSearchParams(newParams, { replace: true });\n    \n    logger.debug('State synced to URL', {\n      selectedEvent,\n      selectedSection,\n      urlParams: Object.fromEntries(newParams.entries()),\n    }, LOG_CATEGORIES.APP);\n    \n  }, [searchParams, setSearchParams, state.navigationData]);\n\n  // Navigate to a new route with optional state preservation\n  const navigateWithState = useCallback((path, options = {}) => {\n    const { preserveParams = true, state: navigationState, replace = false } = options;\n    \n    let finalPath = path;\n    \n    // Preserve URL parameters if requested\n    if (preserveParams && searchParams.toString()) {\n      const separator = path.includes('?') ? '&' : '?';\n      finalPath = `${path}${separator}${searchParams.toString()}`;\n    }\n    \n    const navigateOptions = { replace };\n    if (navigationState) {\n      navigateOptions.state = navigationState;\n    }\n    \n    logger.debug('Navigating with state', {\n      path: finalPath,\n      preserveParams,\n      hasState: !!navigationState,\n    }, LOG_CATEGORIES.APP);\n    \n    navigate(finalPath, navigateOptions);\n    \n  }, [navigate, searchParams]);\n\n  // Update navigation data and sync to URL\n  const updateNavigationData = useCallback((data) => {\n    setNavigationData(data);\n    // Let React handle the URL sync through effects\n  }, [setNavigationData]);\n\n  // Load state from URL parameters on mount\n  useEffect(() => {\n    const selectedEvent = searchParams.get('event');\n    const selectedSection = searchParams.get('section');\n    \n    if (selectedEvent || selectedSection) {\n      const navigationData = {\n        ...(selectedEvent && { selectedEvent }),\n        ...(selectedSection && { selectedSection }),\n      };\n      \n      setNavigationData(navigationData);\n      \n      logger.debug('Navigation data loaded from URL', {\n        selectedEvent,\n        selectedSection,\n      }, LOG_CATEGORIES.APP);\n    }\n  }, [searchParams, setNavigationData]);\n\n  return {\n    // State synchronization\n    syncStateToURL,\n    updateNavigationData,\n    \n    // Navigation helpers\n    navigateWithState,\n    \n    // URL parameter access\n    searchParams,\n    setSearchParams,\n    \n    // Current state\n    navigationData: state.navigationData,\n    currentView: state.currentView,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/base.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":17,"column":1,"nodeType":"Block","endLine":19,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":21,"column":3,"nodeType":"Block","endLine":24,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":23,"column":1,"nodeType":"Block","endLine":23,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":76,"column":3,"nodeType":"Block","endLine":79,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"apiCall\" description.","line":78,"column":1,"nodeType":"Block","endLine":78,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":115,"column":3,"nodeType":"Block","endLine":117,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":115,"column":3,"nodeType":"Block","endLine":117,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":115,"column":3,"nodeType":"Block","endLine":117,"endColumn":6},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":131,"column":14,"nodeType":"Block","endLine":133,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":131,"column":14,"nodeType":"Block","endLine":133,"endColumn":4},{"ruleId":"jsdoc/no-undefined-types","severity":2,"message":"The type 'Response' is undefined.","line":176,"column":1,"nodeType":"Block","endLine":176,"endColumn":1},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":339,"column":1,"nodeType":"Block","endLine":352,"endColumn":4}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Base API configuration and shared utilities\n// Extracted from monolithic api.js for better modularity\n\nimport { sentryUtils } from '../../utils/sentry.js';\nimport logger, { LOG_CATEGORIES } from '../../utils/logger.js';\nimport { authHandler } from '../../auth/authHandler.js';\nimport { sleep } from '../../../utils/asyncUtils.js';\nimport { checkNetworkStatus, addNetworkListener } from '../../../utils/networkUtils.js';\n// Storage utilities imported where needed\nimport { withRateLimitQueue } from '../../../utils/rateLimitQueue.js';\nimport { isDemoMode } from '../../../../config/demoMode.js';\nimport { isTokenExpired } from '../../auth/tokenService.js';\n\nexport const BACKEND_URL = import.meta.env.VITE_API_URL || 'https://vikings-osm-backend.onrender.com';\n\n// Custom error class for expired tokens\n/**\n *\n */\nexport class TokenExpiredError extends Error {\n  /**\n   *\n   * @param message\n   */\n  constructor(message = 'Authentication token has expired') {\n    super(message);\n    this.name = 'TokenExpiredError';\n    this.isTokenExpired = true;\n    this.status = 401;\n    this.code = 'TOKEN_EXPIRED';\n  }\n}\n\n/**\n * Validates token before making API calls to prevent calls with expired tokens\n * @param {string} token - Authentication token to validate\n * @param {string} functionName - Name of the API function for logging\n * @throws {TokenExpiredError} If token is expired\n * @throws {Error} If no token provided\n */\nexport function validateTokenBeforeAPICall(token, functionName) {\n  if (!token) {\n    logger.warn(`${functionName}: No authentication token provided`, {}, LOG_CATEGORIES.API);\n    const err = new Error('No authentication token');\n    err.status = 401;\n    err.code = 'NO_TOKEN';\n    throw err;\n  }\n  \n  if (isTokenExpired()) {\n    logger.warn(`${functionName}: Preventing API call with expired token`, {\n      functionName,\n      tokenPresent: !!token,\n      tokenExpiresAt: sessionStorage.getItem('token_expires_at') || null,\n    }, LOG_CATEGORIES.API);\n    throw new TokenExpiredError(`Cannot call ${functionName} - authentication token has expired`);\n  }\n  \n  logger.debug(`${functionName}: Token validation passed`, {\n    functionName,\n    tokenPresent: !!token,\n  }, LOG_CATEGORIES.API);\n}\n\n/**\n * API call queue to prevent simultaneous requests and manage rate limiting\n * Processes API calls sequentially with controlled delays\n */\nclass APIQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n    this.requestCount = 0;\n  }\n\n  /**\n   *\n   * @param apiCall\n   */\n  async add(apiCall) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ apiCall, resolve, reject });\n      this.process();\n    });\n  }\n\n  async process() {\n    if (this.processing || this.queue.length === 0) {\n      return;\n    }\n\n    this.processing = true;\n    \n    while (this.queue.length > 0) {\n      const { apiCall, resolve, reject } = this.queue.shift();\n      \n      try {\n        this.requestCount++;\n        \n        const result = await apiCall();\n        resolve(result);\n        \n        // Add delay between queued API calls\n        if (this.queue.length > 0) {\n          await sleep(200);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    }\n    \n    this.processing = false;\n  }\n\n  /**\n   *\n   */\n  getStats() {\n    return {\n      queueLength: this.queue.length,\n      processing: this.processing,\n      totalRequests: this.requestCount,\n    };\n  }\n}\n\n// Global API queue instance\nexport const apiQueue = new APIQueue();\n\n// Export queue stats for debugging\nexport const /**\n *\n */\n  getAPIQueueStats = () => apiQueue.getStats();\n\n/**\n * Enhanced rate limit monitoring for OSM API responses\n * Logs warnings when rate limits are approaching critical thresholds\n * @param {object} responseData - API response data containing rate limit info\n * @param {string} apiName - Name of the API call for logging context\n */\nexport function logRateLimitInfo(responseData, apiName) {\n  if (responseData && responseData._rateLimitInfo) {\n    const info = responseData._rateLimitInfo;\n        \n    if (info.osm) {\n      const osm = info.osm;\n      const percentUsed = osm.limit > 0 ? ((osm.limit - osm.remaining) / osm.limit * 100).toFixed(1) : 0;\n            \n      if (osm.remaining < 20 && osm.limit > 0) {\n        logger.warn('OSM rate limit warning', {\n          apiName,\n          remaining: osm.remaining,\n          percentUsed,\n        }, LOG_CATEGORIES.API);\n      }\n            \n      if (osm.remaining < 10 && osm.limit > 0) {\n        logger.error('CRITICAL: Low OSM requests remaining', {\n          apiName,\n          remaining: osm.remaining,\n          percentUsed,\n        }, LOG_CATEGORIES.API);\n      }\n    }\n        \n    if (info.backend) {\n      // Backend rate limit info available\n    }\n  }\n}\n\n/**\n * Enhanced API response handler with comprehensive error handling\n * Manages rate limiting, authentication, and Sentry monitoring\n * @param {Response} response - Fetch API response object\n * @param {string} apiName - Name of the API call for logging and monitoring\n * @returns {Promise<object>} Parsed JSON response data\n * @throws {Error} For rate limits, auth failures, or API errors\n */\nexport async function handleAPIResponseWithRateLimit(response, apiName) {\n  // Add breadcrumb for API call\n  sentryUtils.addBreadcrumb({\n    type: 'http',\n    level: 'info',\n    message: `API call: ${apiName}`,\n    data: {\n      method: response.request?.method || 'GET',\n      url: response.url,\n      status_code: response.status,\n    },\n  });\n\n  if (response.status === 429) {\n    const errorData = await response.json().catch(() => ({}));\n        \n    // Log rate limiting to Sentry\n    logger.warn(logger.fmt`Rate limit hit for API: ${apiName}`, {\n      api: apiName,\n      status: response.status,\n      retryAfter: errorData.rateLimitInfo?.retryAfter,\n    });\n        \n    // Create error object that RateLimitQueue can handle\n    const rateLimitError = new Error('Rate limit exceeded');\n    rateLimitError.status = 429;\n    \n    if (errorData.rateLimitInfo) {\n      const retryAfter = errorData.rateLimitInfo.retryAfter;\n      logger.warn(`${apiName} rate limited by OSM`, { retryAfter }, LOG_CATEGORIES.API);\n      \n      // Set retryAfter for RateLimitQueue to use\n      if (retryAfter) {\n        rateLimitError.retryAfter = retryAfter;\n        rateLimitError.message = `OSM API rate limit exceeded. Please wait ${retryAfter} seconds before trying again.`;\n      } else {\n        rateLimitError.message = 'OSM API rate limit exceeded. Please wait before trying again.';\n      }\n    } else {\n      // Backend rate limiting - extract from backend response format\n      const backendRetryAfter = errorData.rateLimit?.retryAfter;\n      if (backendRetryAfter) {\n        rateLimitError.retryAfter = backendRetryAfter;\n        rateLimitError.message = `Backend rate limit exceeded. Please wait ${backendRetryAfter} seconds.`;\n      } else {\n        rateLimitError.message = 'Rate limited. The backend is managing request flow to prevent blocking.';\n      }\n      logger.warn(`${apiName} rate limited by backend`, { retryAfter: backendRetryAfter }, LOG_CATEGORIES.API);\n    }\n    \n    throw rateLimitError;\n  }\n    \n  // Simple auth handling with circuit breaker\n  if (!authHandler.handleAPIResponse(response, apiName)) {\n    const error = new Error('Authentication failed');\n    error.status = response.status;\n    throw error;\n  }\n    \n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    const errorMessage = errorData.message || errorData.error || `HTTP ${response.status}`;\n        \n    if (errorMessage && typeof errorMessage === 'string') {\n      const errorLower = errorMessage.toLowerCase();\n      if (errorLower.includes('blocked') || errorLower.includes('permanently blocked')) {\n        logger.error('CRITICAL: OSM API BLOCKED', {\n          apiName,\n          errorMessage,\n        }, LOG_CATEGORIES.API);\n        sessionStorage.setItem('osm_blocked', 'true');\n        throw new Error(`OSM API BLOCKED: ${errorMessage}`);\n      }\n    }\n        \n    logger.error('API error', {\n      apiName,\n      errorMessage,\n    }, LOG_CATEGORIES.API);\n    throw new Error(`${apiName} failed: ${errorMessage}`);\n  }\n    \n  try {\n    const data = await response.json();\n    logRateLimitInfo(data, apiName);\n    return data;\n  } catch {\n    logger.error(`${apiName} returned invalid JSON`, {}, LOG_CATEGORIES.API);\n    throw new Error(`${apiName} returned invalid response`);\n  }\n}\n\n// Network status checking with proper initialization\nlet isOnline = true;\n\n// Initialize network status properly on startup\n(async () => {\n  try {\n    isOnline = await checkNetworkStatus();\n    logger.info('Initial network status', {\n      status: isOnline ? 'Online' : 'Offline',\n    }, LOG_CATEGORIES.API);\n    \n    // Then set up monitoring for changes\n    addNetworkListener((status) => {\n      isOnline = status.connected;\n      logger.info('Network status changed', {\n        status: status.connected ? 'Online' : 'Offline',\n      }, LOG_CATEGORIES.API);\n    });\n  } catch (error) {\n    logger.warn('Failed to initialize network status, assuming online', {\n      error: error.message,\n    }, LOG_CATEGORIES.API);\n    isOnline = true;\n  }\n})();\n\nexport { isOnline };\n\n/**\n * Clear all FlexiRecord-related caches from localStorage\n * Useful after fixing authentication issues or when data becomes stale\n * @returns {object} Summary of cleared cache entries\n * \n * @example\n * const result = clearFlexiRecordCaches();\n * console.log(`Cleared ${result.clearedLocalStorageKeys} cache entries`);\n */\nexport function clearFlexiRecordCaches() {\n  // Clear localStorage caches (especially consolidated cache which shouldn't exist)\n  const keys = Object.keys(localStorage);\n  const flexiKeys = keys.filter(key => \n    key.includes('viking_flexi_records_') || \n    key.includes('viking_flexi_structure_') ||\n    key.includes('viking_flexi_consolidated_'),\n  );\n  \n  // Log what we're clearing for debugging\n  const consolidatedKeys = flexiKeys.filter(key => key.includes('viking_flexi_consolidated_'));\n  if (consolidatedKeys.length > 0) {\n    logger.info('Clearing old consolidated cache entries', {\n      count: consolidatedKeys.length,\n      keys: consolidatedKeys,\n    }, LOG_CATEGORIES.API);\n  }\n  \n  flexiKeys.forEach(key => {\n    localStorage.removeItem(key);\n    logger.debug('Removed localStorage key', { key }, LOG_CATEGORIES.API);\n  });\n  \n  return {\n    clearedLocalStorageKeys: flexiKeys.length,\n  };\n}\n\n/**\n * Tests connectivity to the backend API server\n * @returns {Promise<object>} Connection test result with status\n * @returns {Promise<{status: 'ok'}>} When connection successful\n * @returns {Promise<{status: 'error', httpStatus: number, error: string}>} When connection fails\n * \n * @example\n * const result = await testBackendConnection();\n * if (result.status === 'ok') {\n *   console.log('Backend is reachable');\n * } else {\n *   console.error('Backend connection failed:', result.error);\n * }\n */\nexport async function testBackendConnection() {\n  // Skip health checks in demo mode\n  const demoMode = isDemoMode();\n  if (demoMode) {\n    return { status: 'ok' };\n  }\n  \n  try {\n    const result = await withRateLimitQueue(async () => {\n      const response = await fetch(`${BACKEND_URL}/health`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n      });\n      \n      if (response.ok) {\n        await response.text();\n        return { status: 'ok' };\n      } else {\n        logger.error('Backend connection test failed', { status: response.status }, LOG_CATEGORIES.API);\n        return { status: 'error', httpStatus: response.status };\n      }\n    });\n    \n    return result;\n  } catch (error) {\n    logger.error('Backend connection test error', { error: error.message }, LOG_CATEGORIES.API);\n    return { status: 'error', error: error.message };\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/events.js","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":495,"column":1,"nodeType":"Block","endLine":499,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"eventId\" description.","line":497,"column":1,"nodeType":"Block","endLine":497,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionId\" description.","line":498,"column":1,"nodeType":"Block","endLine":498,"endColumn":1}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Events API service\n// Extracted from monolithic api.js for better modularity\n\nimport {\n  BACKEND_URL,\n  validateTokenBeforeAPICall,\n  handleAPIResponseWithRateLimit,\n} from './base.js';\nimport { withRateLimitQueue } from '../../../utils/rateLimitQueue.js';\nimport { checkNetworkStatus } from '../../../utils/networkUtils.js';\nimport { safeGetItem } from '../../../utils/storageUtils.js';\nimport { isDemoMode } from '../../../../config/demoMode.js';\nimport { authHandler } from '../../auth/authHandler.js';\nimport databaseService from '../../storage/database.js';\nimport logger, { LOG_CATEGORIES } from '../../utils/logger.js';\n\n/**\n * Retrieves events for a specific section and term\n * @param {number|string} sectionId - OSM section identifier\n * @param {number|string} termId - OSM term identifier\n * @param {string} token - OSM authentication token\n * @returns {Promise<Array<object>>} Array of events with attendance data\n * @throws {Error} When API request fails and no cached data available\n * \n * @example\n * const events = await getEvents(123, '456', userToken);\n * console.log(`Found ${events.length} events`);\n */\nexport async function getEvents(sectionId, termId, token) {\n  try {\n    // Skip API calls in demo mode - use cached data only\n    const demoMode = isDemoMode();\n    if (demoMode) {\n      const cacheKey = `demo_viking_events_${sectionId}_${termId}_offline`;\n      const cached = safeGetItem(cacheKey, []);\n      return cached;\n    }\n    \n    // Check network status first\n    const isOnlineNow = await checkNetworkStatus();\n        \n    // If offline, get from local database\n    if (!isOnlineNow) {\n      const events = await databaseService.getEvents(sectionId);\n      return events;\n    }\n    \n    // Simple circuit breaker - use cache if auth already failed\n    if (!authHandler.shouldMakeAPICall()) {\n      logger.info('Auth failed - using cached events only', { sectionId, termId }, LOG_CATEGORIES.API);\n      const events = await databaseService.getEvents(sectionId);\n      return events;\n    }\n\n    const data = await withRateLimitQueue(async () => {\n      // Online and allowed – validate now\n      validateTokenBeforeAPICall(token, 'getEvents');\n      \n      const response = await fetch(`${BACKEND_URL}/get-events?sectionid=${sectionId}&termid=${termId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`,\n        },\n      });\n\n      return await handleAPIResponseWithRateLimit(response, 'getEvents');\n    });\n    // Events are in the 'items' property of the response\n    const events = (data && data.items) ? data.items : [];\n    \n    // Filter out any demo events that might be in production data\n    const filteredEvents = events.filter((event) => {\n      const eid = event?.eventid;\n      return !(typeof eid === 'string' && eid.startsWith('demo_event_'));\n    });\n\n    // Save to local database when online (even if empty to cache the result)\n    await databaseService.saveEvents(sectionId, filteredEvents);\n\n    return filteredEvents;\n\n  } catch (error) {\n    logger.error('Error fetching events', { sectionId, termId, error: error.message }, LOG_CATEGORIES.API);\n        \n    // If online request fails, try local database as fallback\n    const isOnlineNow = await checkNetworkStatus();\n    if (isOnlineNow) {\n      try {\n        const events = await databaseService.getEvents(sectionId);\n        return events;\n      } catch (dbError) {\n        logger.error('Database fallback failed', { dbError: dbError.message }, LOG_CATEGORIES.API);\n      }\n    }\n        \n    throw error;\n  }\n}\n\n/**\n * Retrieves attendance data for a specific event\n * @param {number|string} sectionId - OSM section identifier\n * @param {number|string} eventId - OSM event identifier\n * @param {number|string} termId - OSM term identifier\n * @param {string} token - OSM authentication token\n * @returns {Promise<Array<object>>} Array of attendance records\n * @throws {Error} When API request fails and no cached data available\n * \n * @example\n * const attendance = await getEventAttendance(123, 789, '456', userToken);\n * console.log(`${attendance.length} people attended`);\n */\nexport async function getEventAttendance(sectionId, eventId, termId, token) {\n  try {\n    // Skip API calls in demo mode - use cached data only\n    const demoMode = isDemoMode();\n    if (demoMode) {\n      const cacheKey = `demo_viking_attendance_${sectionId}_${termId}_${eventId}_offline`;\n      const cached = safeGetItem(cacheKey, []);\n      // Normalize to array format if cached as object with items\n      const attendance = Array.isArray(cached) ? cached : (cached.items || []);\n      if (import.meta.env.DEV) {\n        logger.debug('Demo mode: Using cached attendance', {\n          sectionId,\n          eventId,\n          termId,\n          attendanceCount: attendance.length,\n        }, LOG_CATEGORIES.API);\n      }\n      return attendance;\n    }\n    \n    // Check network status first\n    const isOnlineNow = await checkNetworkStatus();\n        \n    // If offline, get from local database\n    if (!isOnlineNow) {\n      const attendance = await databaseService.getAttendance(eventId);\n      return attendance;\n    }\n\n    // Simple circuit breaker - use cache if auth already failed\n    if (!authHandler.shouldMakeAPICall()) {\n      logger.info('Auth failed - using cached attendance only', { eventId }, LOG_CATEGORIES.API);\n      const attendance = await databaseService.getAttendance(eventId);\n      return attendance;\n    }\n\n    const data = await withRateLimitQueue(async () => {\n      validateTokenBeforeAPICall(token, 'getEventAttendance');\n      \n      const response = await fetch(`${BACKEND_URL}/get-event-attendance?sectionid=${sectionId}&termid=${termId}&eventid=${eventId}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`,\n        },\n      });\n\n      return await handleAPIResponseWithRateLimit(response, 'getEventAttendance');\n    });\n    // Attendance is in the 'items' property of the response\n    const attendance = (data && data.items) ? data.items : [];\n\n    // Save to local database when online\n    if (attendance.length > 0) {\n      await databaseService.saveAttendance(eventId, attendance);\n    }\n\n    return attendance;\n\n  } catch (error) {\n    logger.error('Error fetching event attendance', { eventId, error: error.message }, LOG_CATEGORIES.API);\n        \n    // If online request fails, try local database as fallback\n    const isOnlineNow = await checkNetworkStatus();\n    if (isOnlineNow) {\n      try {\n        const attendance = await databaseService.getAttendance(eventId);\n        return attendance;\n      } catch (dbError) {\n        logger.error('Database fallback failed', { dbError: dbError.message }, LOG_CATEGORIES.API);\n      }\n    }\n        \n    throw error;\n  }\n}\n\n/**\n * Gets event summary including sharing information\n * @param {number|string} eventId - OSM event identifier\n * @param {string} token - OSM authentication token\n * @returns {Promise<object>} Event summary with sharing data\n * @throws {Error} When API request fails\n * \n * @example\n * const summary = await getEventSummary('1573792', token);\n * if (summary.sharing?.is_owner) {\n *   // This section owns a shared event\n * }\n */\nexport async function getEventSummary(eventId, token) {\n  try {\n    // Skip API calls in demo mode - return mock data\n    const demoMode = isDemoMode();\n    if (demoMode) {\n      if (import.meta.env.DEV) {\n        logger.debug('Demo mode: Returning mock event summary', {\n          eventId,\n        }, LOG_CATEGORIES.API);\n      }\n      // Return a basic mock summary for demo mode\n      return {\n        eventId,\n        attendees: 0,\n        invited: 0,\n        confirmed: 0,\n      };\n    }\n    \n    validateTokenBeforeAPICall(token, 'getEventSummary');\n    \n    // Check network status first\n    const isOnlineNow = await checkNetworkStatus();\n    \n    if (!isOnlineNow) {\n      throw new Error('No network connection available for event summary');\n    }\n\n    if (!token) {\n      throw new Error('Authentication token required for event summary');\n    }\n\n    // Simple circuit breaker - use cache if auth already failed\n    if (!authHandler.shouldMakeAPICall()) {\n      throw new Error('Authentication failed - cannot fetch event summary');\n    }\n\n    const data = await withRateLimitQueue(async () => {\n      const response = await fetch(`${BACKEND_URL}/get-event-summary?eventid=${encodeURIComponent(eventId)}`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`,\n        },\n      });\n\n      return await handleAPIResponseWithRateLimit(response, 'getEventSummary');\n    });\n\n    return data || null;\n\n  } catch (error) {\n    logger.error('Error fetching event summary', { \n      eventId, \n      error: error.message, \n    }, LOG_CATEGORIES.API);\n    throw error;\n  }\n}\n\n/**\n * Retrieves sharing status for an event to see which sections it has been shared with\n * @param {number|string} eventId - OSM event identifier  \n * @param {number|string} sectionId - OSM section identifier (owner section)\n * @param {string} token - OSM authentication token\n * @returns {Promise<object>} Sharing status data with shared sections list\n * @throws {Error} When API request fails\n * \n * @example\n * const sharingStatus = await getEventSharingStatus('12345', '67890', token);\n * console.log(`Event shared with ${sharingStatus.items.length} sections`);\n */\nexport async function getEventSharingStatus(eventId, sectionId, token) {\n  try {\n    // Skip API calls in demo mode - return mock data\n    const demoMode = isDemoMode();\n    if (demoMode) {\n      if (import.meta.env.DEV) {\n        logger.debug('Demo mode: Returning mock sharing status', {\n          eventId,\n          sectionId,\n        }, LOG_CATEGORIES.API);\n      }\n      // Return empty sharing status for demo mode\n      return {\n        items: [],\n      };\n    }\n    \n    validateTokenBeforeAPICall(token, 'getEventSharingStatus');\n    \n    // Check network status first\n    const isOnlineNow = await checkNetworkStatus();\n    \n    if (!isOnlineNow) {\n      throw new Error('No network connection available for sharing status');\n    }\n\n    if (!token) {\n      throw new Error('No authentication token');\n    }\n\n    // Simple circuit breaker - use cache if auth already failed\n    if (!authHandler.shouldMakeAPICall()) {\n      throw new Error('Authentication failed - cannot fetch sharing status');\n    }\n\n    const data = await withRateLimitQueue(async () => {\n      const response = await fetch(\n        `${BACKEND_URL}/get-event-sharing-status?eventid=${encodeURIComponent(eventId)}&sectionid=${encodeURIComponent(sectionId)}`,\n        {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`,\n          },\n        },\n      );\n\n      return await handleAPIResponseWithRateLimit(response, 'getEventSharingStatus');\n    });\n\n    return data || { items: [] };\n\n  } catch (error) {\n    logger.error('Error fetching event sharing status', { \n      eventId, \n      sectionId, \n      error: error.message, \n    }, LOG_CATEGORIES.API);\n    \n    // Re-throw the error to let calling code handle it\n    throw error;\n  }\n}\n\n/**\n * Retrieves combined attendance data from all sections participating in a shared event\n * @param {number|string} eventId - OSM event identifier\n * @param {number|string} sectionId - OSM section identifier (owner section)  \n * @param {string} token - OSM authentication token\n * @returns {Promise<object>} Combined attendance data from all shared sections\n * @throws {Error} When API request fails\n * \n * @example\n * const sharedAttendance = await getSharedEventAttendance('12345', '67890', token);\n * console.log(`${sharedAttendance.combined_attendance.length} total attendees`);\n */\nexport async function getSharedEventAttendance(eventId, sectionId, token) {\n  try {\n    // Check for cached data first - use demo prefix if in demo mode\n    const demoMode = isDemoMode();\n    const prefix = demoMode ? 'demo_' : '';\n    const cacheKey = `${prefix}viking_shared_attendance_${eventId}_${sectionId}_offline`;\n    try {\n      const cached = localStorage.getItem(cacheKey);\n      if (cached) {\n        const cachedData = JSON.parse(cached);\n        // Check if cache is still fresh (within 1 hour)\n        const cacheAge = Date.now() - (cachedData._cacheTimestamp || 0);\n        const maxAge = 60 * 60 * 1000; // 1 hour\n        \n        if (cacheAge < maxAge) {\n          logger.debug('Using cached shared attendance data', { eventId, sectionId }, LOG_CATEGORIES.API);\n          return cachedData;\n        } else {\n          logger.debug('Cached shared attendance data expired, fetching fresh data', { eventId, sectionId }, LOG_CATEGORIES.API);\n        }\n      }\n    } catch (cacheError) {\n      logger.warn('Failed to parse cached shared attendance data', { error: cacheError.message }, LOG_CATEGORIES.API);\n    }\n    \n    // In demo mode, if no cached data found, generate fallback\n    if (demoMode) {\n      logger.debug('Demo mode: No cached shared attendance found, generating fallback data', { eventId, sectionId }, LOG_CATEGORIES.API);\n      return generateDemoSharedAttendance(eventId, sectionId);\n    }\n    \n    // Check network status first\n    const isOnlineNow = await checkNetworkStatus();\n    \n    if (!isOnlineNow) {\n      // If offline, try to return stale cache\n      try {\n        const cached = localStorage.getItem(cacheKey);\n        if (cached) {\n          const cachedData = JSON.parse(cached);\n          logger.info('Using stale cached shared attendance data (offline)', { eventId, sectionId }, LOG_CATEGORIES.API);\n          return cachedData;\n        }\n      } catch (cacheError) {\n        // Ignore cache errors when offline\n      }\n      throw new Error('No network connection and no cached shared attendance available');\n    }\n\n    validateTokenBeforeAPICall(token, 'getSharedEventAttendance');\n\n    // Simple circuit breaker - use cache if auth already failed  \n    if (!authHandler.shouldMakeAPICall()) {\n      // Try to return stale cache if auth failed\n      try {\n        const cached = localStorage.getItem(cacheKey);\n        if (cached) {\n          const cachedData = JSON.parse(cached);\n          logger.info('Using stale cached shared attendance data (auth failed)', { eventId, sectionId }, LOG_CATEGORIES.API);\n          return cachedData;\n        }\n      } catch (cacheError) {\n        // Ignore cache errors when auth failed\n      }\n      throw new Error('Authentication failed and no cached shared attendance available');\n    }\n\n    const data = await withRateLimitQueue(async () => {\n      const response = await fetch(\n        `${BACKEND_URL}/get-shared-event-attendance?eventid=${encodeURIComponent(eventId)}&sectionid=${encodeURIComponent(sectionId)}`,\n        {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${token}`,\n          },\n        },\n      );\n\n      return await handleAPIResponseWithRateLimit(response, 'getSharedEventAttendance');\n    });\n\n    const result = data || { combined_attendance: [], summary: {}, sections: [] };\n    \n    // Log the data shape for development (only when fresh API data is received)\n    if (import.meta.env.DEV) {\n      console.log('🔍 Shared Event Attendance API Response Shape:', {\n        eventId,\n        sectionId,\n        dataStructure: {\n          combined_attendance_count: result.combined_attendance?.length || 0,\n          combined_attendance_sample: result.combined_attendance?.[0] || null,\n          summary_keys: Object.keys(result.summary || {}),\n          summary_data: result.summary,\n          sections_count: result.sections?.length || 0,\n          sections_sample: result.sections?.[0] || null,\n          top_level_keys: Object.keys(result),\n        },\n        full_response: result,\n      });\n    }\n    \n    // Cache the successful response\n    try {\n      const dataToCache = {\n        ...result,\n        _cacheTimestamp: Date.now(),\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(dataToCache));\n      logger.debug('Cached shared attendance data', { eventId, sectionId }, LOG_CATEGORIES.API);\n    } catch (cacheError) {\n      logger.warn('Failed to cache shared attendance data', { error: cacheError.message }, LOG_CATEGORIES.API);\n    }\n\n    return result;\n\n  } catch (error) {\n    logger.error('Error fetching shared event attendance', { \n      eventId, \n      sectionId, \n      error: error.message, \n    }, LOG_CATEGORIES.API);\n    \n    // Try to return stale cached data as a last resort\n    const demoMode = isDemoMode();\n    const prefix = demoMode ? 'demo_' : '';\n    const sharedCacheKey = `${prefix}viking_shared_attendance_${eventId}_${sectionId}_offline`;\n    try {\n      const cached = localStorage.getItem(sharedCacheKey);\n      if (cached) {\n        const cachedData = JSON.parse(cached);\n        logger.info('Using stale cached shared attendance data (API error fallback)', { eventId, sectionId }, LOG_CATEGORIES.API);\n        return cachedData;\n      }\n    } catch (cacheError) {\n      // Ignore cache errors in fallback\n    }\n    \n    // Re-throw the error to let calling code handle it\n    throw error;\n  }\n}\n\n/**\n * Get cached shared attendance data for demo mode\n * @param eventId\n * @param sectionId\n */\nfunction generateDemoSharedAttendance(eventId, sectionId) {\n  // Simply fetch the cached shared attendance data - use demo prefix\n  const sharedCacheKey = `demo_viking_shared_attendance_${eventId}_${sectionId}_offline`;\n  const cachedSharedAttendance = localStorage.getItem(sharedCacheKey);\n  \n  if (import.meta.env.DEV) {\n    logger.debug('Demo mode: Looking for cached shared attendance', {\n      eventId,\n      sectionId,\n      cacheKey: sharedCacheKey,\n      found: !!cachedSharedAttendance,\n    }, LOG_CATEGORIES.API);\n  }\n  \n  if (cachedSharedAttendance) {\n    try {\n      const attendanceData = JSON.parse(cachedSharedAttendance);\n      return attendanceData;\n    } catch (error) {\n      logger.warn('Failed to parse cached shared attendance', { error: error.message }, LOG_CATEGORIES.API);\n    }\n  }\n  \n  // Return empty structure if no cached data found\n  return {\n    identifier: 'scoutsectionid',\n    items: [],\n    _cacheTimestamp: Date.now(),\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/flexiRecords.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/members.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/api/terms.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/api/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/auth/authHandler.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":4,"column":1,"nodeType":"Block","endLine":6,"endColumn":4},{"ruleId":"jsdoc/no-undefined-types","severity":2,"message":"The type 'Response' is undefined.","line":15,"column":1,"nodeType":"Block","endLine":15,"endColumn":1},{"ruleId":"jsdoc/check-param-names","severity":2,"message":"Expected @param names to be \"response, _apiName\". Got \"response, apiName, _apiName\".","line":16,"column":1,"nodeType":"Block","endLine":16,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"_apiName\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1},{"ruleId":"jsdoc/require-returns-description","severity":2,"message":"Missing JSDoc @returns description.","line":58,"column":1,"nodeType":"Block","endLine":58,"endColumn":1}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Simple Authentication Error Handler\n// Minimal solution to prevent multiple 403 errors and provide clear UX\n\n/**\n *\n */\nclass SimpleAuthHandler {\n  constructor() {\n    this.hasShownAuthError = false;\n    this.onAuthError = null; // Callback for components to react to auth failures\n  }\n\n  /**\n   * Handle API response and track authentication failures\n   * @param {Response} response - Fetch response object\n   * @param {string} apiName - Name of the API call for logging\n   * @param _apiName\n   * @returns {boolean} - true if auth is OK, false if auth failed\n   */\n  handleAPIResponse(response, _apiName) {\n    if (response.status === 401 || response.status === 403) {\n      if (!this.hasShownAuthError) {\n        this.hasShownAuthError = true;\n        // Authentication failed - blocked further API calls this session\n        \n        // Notify components about auth failure\n        if (this.onAuthError) {\n          this.onAuthError();\n        }\n      }\n      return false; // Signal auth failure\n    }\n    return true; // Auth OK\n  }\n\n  /**\n   * Check if we should make an API call (simple circuit breaker)\n   * @returns {boolean} - true if safe to make API calls\n   */\n  shouldMakeAPICall() {\n    if (!this.hasShownAuthError) {\n      return true;\n    }\n    // Skipping API call - authentication already failed this session\n    return false;\n  }\n\n  /**\n   * Reset auth error state (call when user gets new token or reconnects)\n   */\n  reset() {\n    // Resetting auth error state\n    this.hasShownAuthError = false;\n  }\n\n  /**\n   * Check if authentication has failed this session\n   * @returns {boolean}\n   */\n  hasAuthFailed() {\n    return this.hasShownAuthError;\n  }\n}\n\n// Export singleton instance\nexport const authHandler = new SimpleAuthHandler();\n\nexport default authHandler;","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/auth/tokenService.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":10,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":10,"column":1,"nodeType":"Block","endLine":12,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":26,"column":1,"nodeType":"Block","endLine":29,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":28,"column":1,"nodeType":"Block","endLine":28,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":50,"column":1,"nodeType":"Block","endLine":52,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":73,"column":1,"nodeType":"Block","endLine":75,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":73,"column":1,"nodeType":"Block","endLine":75,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":80,"column":1,"nodeType":"Block","endLine":82,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":87,"column":1,"nodeType":"Block","endLine":89,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":94,"column":1,"nodeType":"Block","endLine":97,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":94,"column":1,"nodeType":"Block","endLine":97,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"storeCurrentPath\" description.","line":96,"column":1,"nodeType":"Block","endLine":96,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":123,"column":1,"nodeType":"Block","endLine":125,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":132,"column":1,"nodeType":"Block","endLine":134,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":132,"column":1,"nodeType":"Block","endLine":134,"endColumn":4}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Token management service - shared across all features\n// Handles authentication tokens without creating feature dependencies\n\nimport { sentryUtils } from '../utils/sentry.js';\nimport logger, { LOG_CATEGORIES } from '../utils/logger.js';\nimport { isDemoMode } from '../../../config/demoMode.js';\nimport { config } from '../../../config/env.js';\nimport { authHandler } from './authHandler.js';\n\n/**\n *\n */\nexport function getToken() {\n  if (isDemoMode()) {\n    return 'demo-mode-token';\n  }\n  \n  const tokenExpired = sessionStorage.getItem('token_expired') === 'true';\n  if (tokenExpired) {\n    return null;\n  }\n  \n  return sessionStorage.getItem('access_token');\n}\n\n/**\n *\n * @param token\n */\nexport function setToken(token) {\n  sessionStorage.setItem('access_token', token);\n  \n  // Reset auth error state when new token is set\n  authHandler.reset();\n  \n  try {\n    sentryUtils.setUser({\n      segment: 'mobile-app-users',\n    });\n  } catch (sentryError) {\n    logger.error('Failed to set Sentry user context', { \n      error: sentryError.message,\n      hasToken: !!token, \n    }, LOG_CATEGORIES.AUTH);\n  }\n    \n  logger.info('User authenticated successfully', {}, LOG_CATEGORIES.AUTH);\n}\n\n/**\n *\n */\nexport function clearToken() {\n  sessionStorage.removeItem('access_token');\n  sessionStorage.removeItem('token_invalid');\n  sessionStorage.removeItem('token_expired');\n  sessionStorage.removeItem('token_expires_at');\n  \n  // Reset auth handler state when token is cleared\n  authHandler.reset();\n  \n  try {\n    sentryUtils.setUser(null);\n  } catch (sentryError) {\n    logger.error('Failed to clear Sentry user context', {\n      error: sentryError.message,\n    }, LOG_CATEGORIES.AUTH);\n  }\n    \n  logger.info('User logged out - token cleared', {}, LOG_CATEGORIES.AUTH);\n}\n\n/**\n *\n */\nexport function isTokenExpired() {\n  return sessionStorage.getItem('token_expired') === 'true';\n}\n\n/**\n *\n */\nexport function markTokenAsExpired() {\n  sessionStorage.setItem('token_expired', 'true');\n}\n\n/**\n *\n */\nexport function markTokenAsValid() {\n  sessionStorage.removeItem('token_expired');\n}\n\n/**\n *\n * @param storeCurrentPath\n */\nexport function generateOAuthUrl(storeCurrentPath = false) {\n  if (storeCurrentPath) {\n    storeReturnPath();\n  }\n  const BACKEND_URL = config.apiUrl;\n  const frontendUrl = window.location.origin;\n    \n  // Determine environment based on hostname\n  const hostname = window.location.hostname;\n  const isDeployedServer = hostname.includes('.onrender.com') || hostname === 'vikingeventmgmt.onrender.com';\n    \n  // Embed frontend URL in query parameter for backend detection\n  const baseState = isDeployedServer ? 'prod' : 'dev';\n  const authUrl = `${BACKEND_URL}/oauth/login?state=${encodeURIComponent(baseState)}&frontend_url=${encodeURIComponent(frontendUrl)}`;\n    \n  logger.info('Generated OAuth redirect to backend', {\n    hostname,\n    isDeployedServer,\n    baseState,\n    frontendUrl,\n  }, LOG_CATEGORIES.AUTH);\n    \n  return authUrl;\n}\n\n/**\n *\n */\nexport function checkWritePermission() {\n  if (sessionStorage.getItem('token_expired') === 'true') {\n    throw new Error('Write operations are not allowed while in offline mode with expired token');\n  }\n}\n\n/**\n *\n */\nexport async function validateToken() {\n  try {\n    const token = getToken();\n    if (!token) {\n      logger.info('No token found - user needs to login', {}, LOG_CATEGORIES.AUTH);\n      return false;\n    }\n    // Check if OSM API access is blocked\n    if (sessionStorage.getItem('osm_blocked') === 'true') {\n      logger.error('Application is blocked - cannot validate token', { \n        blockedStatus: sessionStorage.getItem('osm_blocked'), \n      }, LOG_CATEGORIES.AUTH);\n      return false;\n    }\n    // Skip meaningless backend validation - just trust we have a token\n    // Real validation happens when actual API calls are made\n    logger.info('Token found - assuming valid until API calls prove otherwise', {}, LOG_CATEGORIES.AUTH);\n    \n    // Clear any invalid token flag since we're assuming the token is good\n    sessionStorage.removeItem('token_invalid');\n    return true;\n  } catch (error) {\n    logger.error('Token validation failed', { \n      error: error.message,\n    }, LOG_CATEGORIES.AUTH);\n    return false;\n  }\n}\n\nfunction storeReturnPath() {\n  try {\n    const currentPath = window.location.pathname + window.location.search;\n    sessionStorage.setItem('auth_return_path', currentPath);\n    logger.info('Stored return path for post-auth redirect', { \n      path: currentPath,\n    }, LOG_CATEGORIES.AUTH);\n  } catch (error) {\n    logger.error('Failed to store return path', { \n      error: error.message,\n    }, LOG_CATEGORIES.AUTH);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/storage/database.js","messages":[{"ruleId":"jsdoc/no-undefined-types","severity":2,"message":"The type 'SQLiteDBConnection' is undefined.","line":77,"column":1,"nodeType":"Block","endLine":77,"endColumn":1},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":364,"column":3,"nodeType":"Block","endLine":393,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":364,"column":3,"nodeType":"Block","endLine":393,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":513,"column":3,"nodeType":"Block","endLine":548,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":513,"column":3,"nodeType":"Block","endLine":548,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":659,"column":3,"nodeType":"Block","endLine":687,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":659,"column":3,"nodeType":"Block","endLine":687,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":912,"column":3,"nodeType":"Block","endLine":947,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":912,"column":3,"nodeType":"Block","endLine":947,"endColumn":6}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file SQLite Database Service for Vikings Event Management\n * \n * Provides comprehensive offline-first data persistence for Scout sections, events,\n * attendance records, and member information. Uses Capacitor SQLite on native\n * platforms with localStorage fallback for web browsers. Supports demo mode\n * data segregation and comprehensive member caching across multiple sections.\n * \n * Key features:\n * - Offline-first architecture with automatic fallback\n * - Cross-platform compatibility (iOS, Android, Web)\n * - Demo mode data isolation\n * - Comprehensive member caching to handle multi-section members\n * - Sync status tracking for data consistency\n * - Structured data schema with foreign key relationships\n * \n * @module DatabaseService\n * @requires @capacitor-community/sqlite\n * @requires @capacitor/core\n */\n\nimport { CapacitorSQLite, SQLiteConnection } from '@capacitor-community/sqlite';\nimport { Capacitor } from '@capacitor/core';\nimport { safeGetItem, safeSetItem } from '../../utils/storageUtils.js';\nimport { isDemoMode } from '../../../config/demoMode.js';\n\n/**\n * SQLite Database Service for offline data persistence\n * \n * Manages all local data storage for the Vikings Event Management application.\n * Automatically detects platform capabilities and falls back to localStorage\n * when SQLite is not available. Provides consistent API across all platforms\n * with support for Scout sections, events, attendance, and member data.\n * \n * @class\n * @example\n * // Initialize and save sections\n * import databaseService from './storage/database.js';\n * \n * await databaseService.initialize();\n * await databaseService.saveSections([\n *   { sectionid: 1, sectionname: 'Beavers', sectiontype: 'beavers' },\n *   { sectionid: 2, sectionname: 'Cubs', sectiontype: 'cubs' }\n * ]);\n * \n * // Retrieve sections\n * const sections = await databaseService.getSections();\n * console.log('Available sections:', sections);\n * \n * @example\n * // Save and retrieve events for a section\n * const events = [\n *   {\n *     eventid: 'event_1',\n *     name: 'Weekend Camp',\n *     startdate: '2024-06-15',\n *     enddate: '2024-06-16',\n *     location: 'Scout Camp'\n *   }\n * ];\n * \n * await databaseService.saveEvents(1, events);\n * const sectionEvents = await databaseService.getEvents(1);\n */\nclass DatabaseService {\n  /**\n   * Creates a new DatabaseService instance\n   * \n   * Initializes the service with platform detection and default state.\n   * Does not establish database connection - call initialize() for that.\n   * \n   * @class\n   */\n  constructor() {\n    /** @type {SQLiteConnection|null} SQLite connection instance */\n    this.sqlite = null;\n    /** @type {SQLiteDBConnection|null} Database connection instance */\n    this.db = null;\n    /** @type {boolean} Whether service has been initialized */\n    this.isInitialized = false;\n    /** @type {boolean} Whether running on native platform (iOS/Android) */\n    this.isNative = Capacitor.isNativePlatform();\n  }\n\n  /**\n   * Initializes the database service and creates necessary tables\n   * \n   * Detects platform capabilities and establishes appropriate storage mechanism.\n   * On native platforms, initializes SQLite with proper connections and creates\n   * database schema. On web platforms, validates localStorage availability and\n   * sets up fallback mode. Safe to call multiple times - subsequent calls are ignored.\n   * \n   * @async\n   * @returns {Promise<void>} Resolves when initialization is complete\n   * @throws {Error} Only logs errors, never throws - gracefully falls back to localStorage\n   * \n   * @example\n   * // Initialize before any database operations\n   * import databaseService from './storage/database.js';\n   * \n   * try {\n   *   await databaseService.initialize();\n   *   console.log('Database ready for use');\n   * } catch (error) {\n   *   // Service automatically falls back to localStorage\n   *   console.log('Using localStorage fallback');\n   * }\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      // Only initialize SQLite on native platforms\n      if (!this.isNative) {\n        console.log('Running in browser - SQLite not available, using localStorage fallback');\n        this.isInitialized = true;\n        return;\n      }\n\n      // Wait for platform to be ready\n      await Capacitor.getPlatform();\n      \n      this.sqlite = new SQLiteConnection(CapacitorSQLite);\n      \n      // Create database\n      const ret = await this.sqlite.checkConnectionsConsistency();\n      const isConn = (await this.sqlite.isConnection('vikings_db', false)).result;\n      \n      if (ret.result && isConn) {\n        this.db = await this.sqlite.retrieveConnection('vikings_db', false);\n      } else {\n        this.db = await this.sqlite.createConnection('vikings_db', false, 'no-encryption', 1, false);\n      }\n      \n      await this.db.open();\n      await this.createTables();\n      this.isInitialized = true;\n      console.log('Database initialized successfully');\n    } catch (error) {\n      console.error('Database initialization failed:', error);\n      // Don't throw error - fallback to localStorage\n      this.isInitialized = true;\n      this.isNative = false;\n    }\n  }\n\n  /**\n   * Creates database schema with all required tables\n   * \n   * Establishes the complete database structure including sections, events,\n   * attendance, members, and sync tracking tables. Uses proper foreign key\n   * relationships and indexes for optimal performance. Only executed on\n   * native platforms with SQLite support.\n   * \n   * Tables created:\n   * - sections: Scout sections (Beavers, Cubs, Scouts, etc.)\n   * - events: Section events with date ranges and locations\n   * - attendance: Event attendance records for individual scouts\n   * - members: Comprehensive scout member information\n   * - sync_status: Data synchronization tracking\n   * - event_dashboard: Aggregated event summary data\n   * - sync_metadata: Additional synchronization metadata\n   * \n   * @async\n   * @private\n   * @returns {Promise<void>} Resolves when all tables are created\n   * @throws {Error} If table creation fails\n   * \n   * @example\n   * // Called automatically during initialize()\n   * await this.createTables();\n   */\n  async createTables() {\n    const createSectionsTable = `\n      CREATE TABLE IF NOT EXISTS sections (\n        sectionid INTEGER PRIMARY KEY,\n        sectionname TEXT NOT NULL,\n        sectiontype TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n    `;\n\n    const createEventsTable = `\n      CREATE TABLE IF NOT EXISTS events (\n        eventid INTEGER PRIMARY KEY,\n        sectionid INTEGER,\n        termid TEXT,\n        name TEXT NOT NULL,\n        date TEXT,\n        startdate TEXT,\n        startdate_g TEXT,\n        enddate TEXT,\n        enddate_g TEXT,\n        location TEXT,\n        notes TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (sectionid) REFERENCES sections (sectionid)\n      );\n    `;\n\n    const createAttendanceTable = `\n      CREATE TABLE IF NOT EXISTS attendance (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        eventid INTEGER,\n        scoutid INTEGER,\n        firstname TEXT,\n        lastname TEXT,\n        attending TEXT,\n        patrol TEXT,\n        notes TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (eventid) REFERENCES events (eventid)\n      );\n    `;\n\n    const createMembersTable = `\n      CREATE TABLE IF NOT EXISTS members (\n        scoutid INTEGER PRIMARY KEY,\n        -- Basic info\n        firstname TEXT,\n        lastname TEXT,\n        date_of_birth TEXT,\n        age TEXT,\n        age_years INTEGER,\n        age_months INTEGER,\n        \n        -- Section info\n        sectionid INTEGER,\n        sectionname TEXT,\n        section TEXT,\n        sections TEXT, -- JSON array of all sections this member belongs to\n        patrol TEXT,\n        patrol_id INTEGER,\n        person_type TEXT, -- Young People, Young Leaders, Leaders\n        \n        -- Membership dates\n        started TEXT,\n        joined TEXT,\n        end_date TEXT,\n        active BOOLEAN,\n        \n        -- Photo info\n        photo_guid TEXT,\n        has_photo BOOLEAN,\n        pic BOOLEAN,\n        \n        -- Role info\n        patrol_role_level INTEGER,\n        patrol_role_level_label TEXT,\n        \n        -- Contact info (basic)\n        email TEXT,\n        \n        -- Complex data stored as JSON\n        contact_groups TEXT, -- JSON blob of all contact groups\n        custom_data TEXT,    -- JSON blob of raw custom_data from OSM\n        flattened_fields TEXT, -- JSON blob of all flattened custom fields\n        \n        -- Metadata\n        read_only TEXT, -- JSON array\n        filter_string TEXT,\n        \n        -- Timestamps\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n    `;\n\n    const createSyncStatusTable = `\n      CREATE TABLE IF NOT EXISTS sync_status (\n        table_name TEXT PRIMARY KEY,\n        last_sync DATETIME,\n        needs_sync INTEGER DEFAULT 0\n      );\n    `;\n\n    const createEventDashboardTable = `\n      CREATE TABLE IF NOT EXISTS event_dashboard (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        event_id TEXT NOT NULL,\n        event_name TEXT NOT NULL,\n        section_id INTEGER NOT NULL,\n        section_name TEXT NOT NULL,\n        start_date TEXT NOT NULL,\n        end_date TEXT,\n        attendance_summary TEXT,\n        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,\n        UNIQUE(event_id, section_id)\n      );\n    `;\n\n    const createSyncMetadataTable = `\n      CREATE TABLE IF NOT EXISTS sync_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n    `;\n\n    await this.db.execute(createSectionsTable);\n    await this.db.execute(createEventsTable);\n    await this.db.execute(createAttendanceTable);\n    await this.db.execute(createMembersTable);\n    await this.db.execute(createSyncStatusTable);\n    await this.db.execute(createEventDashboardTable);\n    await this.db.execute(createSyncMetadataTable);\n  }\n\n  /**\n   * Saves Scout sections to local storage\n   * \n   * Stores section information with complete replacement of existing data.\n   * On native platforms, uses SQLite with proper transaction handling.\n   * On web platforms, uses localStorage with demo mode data segregation.\n   * Automatically updates sync status after successful save.\n   * \n   * @async\n   * @param {Array<object>} sections - Array of section objects to save\n   * @param {number} sections[].sectionid - Unique section identifier\n   * @param {string} sections[].sectionname - Display name (e.g., \"1st Walton Beavers\")\n   * @param {string} [sections[].sectiontype] - Section type (e.g., \"beavers\", \"cubs\")\n   * @returns {Promise<void>} Resolves when sections are saved\n   * \n   * @example\n   * // Save sections for a Scout group\n   * const sections = [\n   *   { sectionid: 1, sectionname: '1st Walton Beavers', sectiontype: 'beavers' },\n   *   { sectionid: 2, sectionname: '1st Walton Cubs', sectiontype: 'cubs' },\n   *   { sectionid: 3, sectionname: '1st Walton Scouts', sectiontype: 'scouts' }\n   * ];\n   * \n   * await databaseService.saveSections(sections);\n   * console.log('Sections saved successfully');\n   */\n  async saveSections(sections) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use demo prefix if in demo mode\n      const { isDemoMode } = await import('../../../config/demoMode.js');\n      const prefix = isDemoMode() ? 'demo_' : '';\n      const key = `${prefix}viking_sections_offline`;\n      safeSetItem(key, sections);\n      return;\n    }\n    \n    const deleteOld = 'DELETE FROM sections';\n    await this.db.execute(deleteOld);\n\n    for (const section of sections) {\n      const insert = `\n        INSERT INTO sections (sectionid, sectionname, sectiontype)\n        VALUES (?, ?, ?)\n      `;\n      await this.db.run(insert, [section.sectionid, section.sectionname, section.sectiontype]);\n    }\n\n    await this.updateSyncStatus('sections');\n  }\n\n  /**\n   * Retrieves all Scout sections from local storage\n   * \n   * Loads section information with automatic demo mode filtering.\n   * On native platforms, queries SQLite database with proper ordering.\n   * On web platforms, retrieves from localStorage with data validation.\n   * Automatically filters out demo sections when not in demo mode.\n   * \n   * @async\n   * @returns {Promise<Array<object>>} Array of section objects\n   * @returns {number} returns[].sectionid - Unique section identifier\n   * @returns {string} returns[].sectionname - Display name\n   * @returns {string} [returns[].sectiontype] - Section type\n   * \n   * @example\n   * // Get all available sections\n   * const sections = await databaseService.getSections();\n   * \n   * sections.forEach(section => {\n   *   console.log(`Section: ${section.sectionname} (ID: ${section.sectionid})`);\n   * });\n   * \n   * @example\n   * // Use sections to populate dropdown\n   * const sections = await databaseService.getSections();\n   * const sectionOptions = sections.map(section => ({\n   *   value: section.sectionid,\n   *   label: section.sectionname\n   * }));\n   */\n  async getSections() {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use demo prefix if in demo mode\n      const { isDemoMode } = await import('../../../config/demoMode.js');\n      const prefix = isDemoMode() ? 'demo_' : '';\n      const key = `${prefix}viking_sections_offline`;\n      const sectionsData = safeGetItem(key, []);\n      \n      // In demo mode, sections are stored as flat array (already parsed by safeGetItem)\n      // In production, they might be timestamped format with {items: [...]}\n      let sections = [];\n      if (Array.isArray(sectionsData)) {\n        sections = sectionsData;\n      } else if (sectionsData && typeof sectionsData === 'object' && sectionsData.items) {\n        sections = sectionsData.items;\n      }\n      \n      // Filter out demo sections if not in demo mode\n      if (!isDemoMode()) {\n        sections = sections.filter((section) => {\n          const name = section?.sectionname;\n          return !(typeof name === 'string' && name.startsWith('Demo '));\n        });\n      }\n      \n      return sections;\n    }\n    \n    const query = 'SELECT * FROM sections ORDER BY sectionname';\n    const result = await this.db.query(query);\n    return result.values || [];\n  }\n\n  /**\n   * Saves Scout events for a specific section\n   * \n   * Stores event information with section-specific data isolation.\n   * Replaces all existing events for the specified section. On native\n   * platforms, uses SQLite with foreign key relationships. On web platforms,\n   * uses localStorage with section-specific keys and demo mode support.\n   * \n   * @async\n   * @param {number} sectionId - Section identifier to save events for\n   * @param {Array<object>} events - Array of event objects to save\n   * @param {string|number} events[].eventid - Unique event identifier\n   * @param {string} events[].name - Event name/title\n   * @param {string} [events[].date] - Legacy date field\n   * @param {string} events[].startdate - Event start date (YYYY-MM-DD)\n   * @param {string} [events[].startdate_g] - Start date in different format\n   * @param {string} [events[].enddate] - Event end date (YYYY-MM-DD)\n   * @param {string} [events[].enddate_g] - End date in different format\n   * @param {string} [events[].location] - Event location/venue\n   * @param {string} [events[].notes] - Additional event notes\n   * @param {string} [events[].termid] - Associated term identifier\n   * @returns {Promise<void>} Resolves when events are saved\n   * \n   * @example\n   * // Save events for Beavers section\n   * const beaverEvents = [\n   *   {\n   *     eventid: 'event_123',\n   *     name: 'Beaver Colony Meeting',\n   *     startdate: '2024-06-15',\n   *     enddate: '2024-06-15',\n   *     location: 'Scout Hut',\n   *     notes: 'Weekly meeting with badge work'\n   *   },\n   *   {\n   *     eventid: 'camp_456',\n   *     name: 'Weekend Camp',\n   *     startdate: '2024-07-20',\n   *     enddate: '2024-07-21',\n   *     location: 'Phasels Wood Scout Camp'\n   *   }\n   * ];\n   * \n   * await databaseService.saveEvents(1, beaverEvents);\n   */\n  async saveEvents(sectionId, events) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use demo prefix if in demo mode\n      const { isDemoMode } = await import('../../../config/demoMode.js');\n      const prefix = isDemoMode() ? 'demo_' : '';\n      const key = `${prefix}viking_events_${sectionId}_offline`;\n      safeSetItem(key, events);\n      return;\n    }\n    \n    // Delete existing events for this section\n    const deleteOld = 'DELETE FROM events WHERE sectionid = ?';\n    await this.db.run(deleteOld, [sectionId]);\n\n    for (const event of events) {\n      const insert = `\n        INSERT INTO events (eventid, sectionid, termid, name, date, startdate, startdate_g, enddate, enddate_g, location, notes)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      await this.db.run(insert, [\n        event.eventid, \n        sectionId, \n        event.termid || null,\n        event.name, \n        event.date,\n        event.startdate, \n        event.startdate_g,\n        event.enddate, \n        event.enddate_g,\n        event.location, \n        event.notes,\n      ]);\n    }\n\n    await this.updateSyncStatus('events');\n  }\n\n  /**\n   * Retrieves Scout events for a specific section\n   * \n   * Loads event information with automatic demo mode filtering and proper\n   * date ordering. On native platforms, queries SQLite with section filtering.\n   * On web platforms, retrieves from localStorage with data validation.\n   * Returns events sorted by start date (most recent first).\n   * \n   * @async\n   * @param {number} sectionId - Section identifier to get events for\n   * @returns {Promise<Array<object>>} Array of event objects for the section\n   * @returns {string|number} returns[].eventid - Unique event identifier\n   * @returns {string} returns[].name - Event name/title\n   * @returns {string} returns[].startdate - Event start date\n   * @returns {string} [returns[].enddate] - Event end date\n   * @returns {string} [returns[].location] - Event location\n   * @returns {string} [returns[].notes] - Event notes\n   * \n   * @example\n   * // Get events for Beavers section\n   * const beaverEvents = await databaseService.getEvents(1);\n   * \n   * console.log(`Found ${beaverEvents.length} events for Beavers:`);\n   * beaverEvents.forEach(event => {\n   *   console.log(`- ${event.name} on ${event.startdate}`);\n   * });\n   * \n   * @example\n   * // Display upcoming events\n   * const events = await databaseService.getEvents(sectionId);\n   * const today = new Date().toISOString().split('T')[0];\n   * \n   * const upcomingEvents = events.filter(event => \n   *   event.startdate >= today\n   * );\n   */\n  async getEvents(sectionId) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use demo prefix if in demo mode\n      const { isDemoMode } = await import('../../../config/demoMode.js');\n      const prefix = isDemoMode() ? 'demo_' : '';\n      const key = `${prefix}viking_events_${sectionId}_offline`;\n      const eventsData = safeGetItem(key, []);\n      \n      // In demo mode, events are stored as flat array (already parsed by safeGetItem)\n      // In production, they might be timestamped format with {items: [...]}\n      let events = [];\n      if (Array.isArray(eventsData)) {\n        events = eventsData;\n      } else if (eventsData && typeof eventsData === 'object' && eventsData.items) {\n        events = eventsData.items;\n      }\n      \n      // Filter out demo events if not in demo mode\n      if (!isDemoMode()) {\n        events = events.filter((event) => {\n          const eid = event?.eventid;\n          return !(typeof eid === 'string' && eid.startsWith('demo_event_'));\n        });\n      }\n      \n      return events;\n    }\n    \n    const query = 'SELECT * FROM events WHERE sectionid = ? ORDER BY startdate DESC';\n    const result = await this.db.query(query, [sectionId]);\n    return result.values || [];\n  }\n\n  /**\n   * Saves attendance records for a specific event\n   * \n   * Stores individual scout attendance information for event tracking.\n   * Replaces all existing attendance records for the specified event.\n   * Critical for offline functionality during events when internet may\n   * be unreliable but attendance needs to be recorded.\n   * \n   * @async\n   * @param {string|number} eventId - Event identifier to save attendance for\n   * @param {Array<object>} attendanceData - Array of attendance records\n   * @param {number} attendanceData[].scoutid - Scout member identifier\n   * @param {string} attendanceData[].firstname - Scout's first name\n   * @param {string} attendanceData[].lastname - Scout's last name\n   * @param {string} attendanceData[].attending - Attendance status (\"Yes\"/\"No\"/\"Maybe\")\n   * @param {string} [attendanceData[].patrol] - Scout's patrol name\n   * @param {string} [attendanceData[].notes] - Additional attendance notes\n   * @returns {Promise<void>} Resolves when attendance is saved\n   * \n   * @example\n   * // Record attendance for weekend camp\n   * const campAttendance = [\n   *   {\n   *     scoutid: 12345,\n   *     firstname: 'Alice',\n   *     lastname: 'Smith',\n   *     attending: 'Yes',\n   *     patrol: 'Red Patrol',\n   *     notes: 'Dietary requirements: vegetarian'\n   *   },\n   *   {\n   *     scoutid: 67890,\n   *     firstname: 'Bob',\n   *     lastname: 'Jones',\n   *     attending: 'No',\n   *     patrol: 'Blue Patrol',\n   *     notes: 'Family holiday'\n   *   }\n   * ];\n   * \n   * await databaseService.saveAttendance('camp_456', campAttendance);\n   */\n  async saveAttendance(eventId, attendanceData) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback\n      const key = `viking_attendance_${eventId}_offline`;\n      safeSetItem(key, attendanceData);\n      return;\n    }\n    \n    // Delete existing attendance for this event\n    const deleteOld = 'DELETE FROM attendance WHERE eventid = ?';\n    await this.db.run(deleteOld, [eventId]);\n\n    for (const person of attendanceData) {\n      const insert = `\n        INSERT INTO attendance (eventid, scoutid, firstname, lastname, attending, patrol, notes)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n      `;\n      await this.db.run(insert, [\n        eventId,\n        person.scoutid,\n        person.firstname,\n        person.lastname,\n        person.attending,\n        person.patrol,\n        person.notes,\n      ]);\n    }\n\n    await this.updateSyncStatus('attendance');\n  }\n\n  /**\n   * Retrieves attendance records for a specific event\n   * \n   * Loads attendance information with proper name ordering for easy review.\n   * Returns all scouts registered for the event with their attendance status.\n   * Critical for event check-in/check-out and attendance reporting.\n   * \n   * @async\n   * @param {string|number} eventId - Event identifier to get attendance for\n   * @returns {Promise<Array<object>>} Array of attendance records\n   * @returns {number} returns[].scoutid - Scout member identifier\n   * @returns {string} returns[].firstname - Scout's first name\n   * @returns {string} returns[].lastname - Scout's last name\n   * @returns {string} returns[].attending - Attendance status\n   * @returns {string} [returns[].patrol] - Scout's patrol name\n   * @returns {string} [returns[].notes] - Attendance notes\n   * \n   * @example\n   * // Get attendance for event check-in\n   * const attendance = await databaseService.getAttendance('camp_456');\n   * \n   * const attending = attendance.filter(scout => scout.attending === 'Yes');\n   * console.log(`${attending.length} scouts attending the camp`);\n   * \n   * // Display attendance list\n   * attendance.forEach(scout => {\n   *   console.log(`${scout.firstname} ${scout.lastname}: ${scout.attending}`);\n   * });\n   */\n  async getAttendance(eventId) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback\n      const key = `viking_attendance_${eventId}_offline`;\n      return safeGetItem(key, []);\n    }\n    \n    const query = 'SELECT * FROM attendance WHERE eventid = ? ORDER BY lastname, firstname';\n    const result = await this.db.query(query, [eventId]);\n    return result.values || [];\n  }\n\n  /**\n   * Updates synchronization status for a data table\n   * \n   * Records when data was last synchronized and marks table as current.\n   * Used for offline-first architecture to track which data needs\n   * synchronization when connection is restored. Only operates on\n   * native platforms with SQLite support.\n   * \n   * @async\n   * @private\n   * @param {string} tableName - Name of table to update sync status for\n   * @returns {Promise<void>} Resolves when sync status is updated\n   * \n   * @example\n   * // Called automatically after successful data saves\n   * await this.updateSyncStatus('sections');\n   * await this.updateSyncStatus('events');\n   */\n  async updateSyncStatus(tableName) {\n    if (!this.isNative || !this.db) return; // Skip for localStorage fallback\n    \n    const update = `\n      INSERT OR REPLACE INTO sync_status (table_name, last_sync, needs_sync)\n      VALUES (?, CURRENT_TIMESTAMP, 0)\n    `;\n    await this.db.run(update, [tableName]);\n  }\n\n  /**\n   * Checks if a data table needs synchronization\n   * \n   * Determines whether data has been modified locally and requires\n   * synchronization with the server. Used to optimize sync operations\n   * and avoid unnecessary network requests.\n   * \n   * @async\n   * @param {string} tableName - Name of table to check sync status for\n   * @returns {Promise<boolean>} True if table needs synchronization\n   * \n   * @example\n   * // Check if sections need syncing before API call\n   * if (await databaseService.needsSync('sections')) {\n   *   console.log('Sections data needs synchronization');\n   *   // Perform sync operation\n   * }\n   */\n  async needsSync(tableName) {\n    if (!this.isNative || !this.db) return false; // Skip for localStorage fallback\n    \n    const query = 'SELECT needs_sync FROM sync_status WHERE table_name = ?';\n    const result = await this.db.query(query, [tableName]);\n    return result.values?.[0]?.needs_sync === 1;\n  }\n\n  /**\n   * Saves Scout member information with comprehensive caching\n   * \n   * Stores member data using a single comprehensive cache that handles\n   * multi-section members efficiently. Deduplicates members by scout ID\n   * while preserving section associations. Critical for offline member\n   * lookup during events and meetings.\n   * \n   * @async\n   * @param {Array<number>} sectionIds - Section identifiers members belong to\n   * @param {Array<object>} members - Array of member objects to save\n   * @param {number} members[].scoutid - Unique scout identifier\n   * @param {string} members[].firstname - Scout's first name\n   * @param {string} members[].lastname - Scout's last name\n   * @param {string} [members[].date_of_birth] - Date of birth (YYYY-MM-DD)\n   * @param {number} [members[].age_years] - Age in years\n   * @param {number} members[].sectionid - Primary section ID\n   * @param {string} members[].sectionname - Primary section name\n   * @param {Array<string>} [members[].sections] - All sections member belongs to\n   * @param {string} [members[].patrol] - Patrol/lodge name\n   * @param {string} [members[].person_type] - Member type (Young People/Leaders)\n   * @param {boolean} [members[].active] - Whether member is currently active\n   * @param {object} [members[].custom_data] - Additional OSM custom field data\n   * @returns {Promise<void>} Resolves when members are saved\n   * \n   * @example\n   * // Save members for multiple sections\n   * const members = [\n   *   {\n   *     scoutid: 12345,\n   *     firstname: 'Alice',\n   *     lastname: 'Smith',\n   *     age_years: 8,\n   *     sectionid: 1,\n   *     sectionname: 'Beavers',\n   *     patrol: 'Red Lodge',\n   *     active: true\n   *   }\n   * ];\n   * \n   * await databaseService.saveMembers([1, 2], members);\n   */\n  async saveMembers(sectionIds, members) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use single comprehensive key with demo mode awareness\n      const demoMode = isDemoMode();\n      const key = demoMode ? 'demo_viking_members_comprehensive_offline' : 'viking_members_comprehensive_offline';\n      \n      // Get existing members\n      let existingMembers = [];\n      try {\n        existingMembers = safeGetItem(key, []);\n      } catch (error) {\n        console.warn('Failed to parse existing members cache:', error);\n        existingMembers = [];\n      }\n      \n      // Create member map for deduplication\n      const memberMap = new Map();\n      \n      // Add existing members first\n      existingMembers.forEach(member => {\n        if (member.scoutid) {\n          memberMap.set(member.scoutid, member);\n        }\n      });\n      \n      // Add/update new members (overwrites existing with same scoutid)\n      members.forEach(member => {\n        if (member.scoutid) {\n          // Ensure sections array is properly maintained for multi-section members\n          if (memberMap.has(member.scoutid)) {\n            const existing = memberMap.get(member.scoutid);\n            const combinedSections = [...new Set([\n              ...(existing.sections || [existing.sectionname].filter(Boolean)),\n              ...(member.sections || [member.sectionname].filter(Boolean)),\n            ])];\n            member.sections = combinedSections;\n          }\n          memberMap.set(member.scoutid, member);\n        }\n      });\n      \n      // Save comprehensive member list\n      const allMembers = Array.from(memberMap.values());\n      safeSetItem(key, allMembers);\n      return;\n    }\n    \n    // Use REPLACE INTO to handle updates for existing members across sections\n    for (const member of members) {\n      // Separate flattened fields from known structured fields\n      const knownFields = new Set([\n        'scoutid', 'member_id', 'firstname', 'lastname', 'date_of_birth', 'age', 'age_years', 'age_months',\n        'sectionid', 'sectionname', 'section', 'sections', 'patrol', 'patrol_id', 'person_type',\n        'started', 'joined', 'end_date', 'active', 'photo_guid', 'has_photo', 'pic',\n        'patrol_role_level', 'patrol_role_level_label', 'email', 'contact_groups', 'custom_data',\n        'read_only', 'filter_string', '_filterString',\n      ]);\n      \n      const flattenedFields = {};\n      Object.keys(member).forEach(key => {\n        if (!knownFields.has(key)) {\n          flattenedFields[key] = member[key];\n        }\n      });\n      \n      const insert = `\n        REPLACE INTO members (\n          scoutid, firstname, lastname, date_of_birth, age, age_years, age_months,\n          sectionid, sectionname, section, sections, patrol, patrol_id, person_type,\n          started, joined, end_date, active, photo_guid, has_photo, pic,\n          patrol_role_level, patrol_role_level_label, email,\n          contact_groups, custom_data, flattened_fields, read_only, filter_string\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `;\n      \n      await this.db.run(insert, [\n        member.scoutid || member.member_id,\n        member.firstname,\n        member.lastname,\n        member.date_of_birth,\n        member.age,\n        member.age_years,\n        member.age_months,\n        member.sectionid,\n        member.sectionname,\n        member.section,\n        JSON.stringify(member.sections || []),\n        member.patrol,\n        member.patrol_id,\n        member.person_type,\n        member.started,\n        member.joined,\n        member.end_date,\n        member.active,\n        member.photo_guid,\n        member.has_photo,\n        member.pic,\n        member.patrol_role_level,\n        member.patrol_role_level_label,\n        member.email,\n        JSON.stringify(member.contact_groups || {}),\n        JSON.stringify(member.custom_data || {}),\n        JSON.stringify(flattenedFields),\n        JSON.stringify(member.read_only || []),\n        member._filterString || member.filter_string,\n      ]);\n    }\n\n    await this.updateSyncStatus('members');\n  }\n\n  /**\n   * Retrieves Scout members for specified sections\n   * \n   * Loads member information with section filtering and proper data\n   * reconstruction. Handles comprehensive member cache and ensures\n   * backward compatibility. Returns members with all custom fields\n   * and section associations intact.\n   * \n   * @async\n   * @param {Array<number>} sectionIds - Section identifiers to get members for\n   * @returns {Promise<Array<object>>} Array of member objects\n   * @returns {number} returns[].scoutid - Scout identifier\n   * @returns {string} returns[].firstname - Scout's first name\n   * @returns {string} returns[].lastname - Scout's last name\n   * @returns {number} [returns[].age_years] - Age in years\n   * @returns {string} returns[].sectionname - Section name\n   * @returns {string} [returns[].patrol] - Patrol/lodge name\n   * @returns {Array<string>} [returns[].sections] - All sections member belongs to\n   * @returns {object} [returns[].custom_data] - Custom field data from OSM\n   * \n   * @example\n   * // Get all Beaver members\n   * const beaverMembers = await databaseService.getMembers([1]);\n   * \n   * console.log(`Found ${beaverMembers.length} Beaver scouts:`);\n   * beaverMembers.forEach(member => {\n   *   console.log(`- ${member.firstname} ${member.lastname} (${member.age_years} years)`);\n   * });\n   * \n   * @example\n   * // Get members for multiple sections\n   * const allMembers = await databaseService.getMembers([1, 2, 3]);\n   * const leaders = allMembers.filter(member => \n   *   member.person_type === 'Leaders'\n   * );\n   */\n  async getMembers(sectionIds) {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use single comprehensive cache with demo mode awareness\n      const demoMode = isDemoMode();\n      const key = demoMode ? 'demo_viking_members_comprehensive_offline' : 'viking_members_comprehensive_offline';\n      \n      try {\n        const members = safeGetItem(key, []);\n        if (!members.length) {\n          return [];\n        }\n        \n        // Filter members by requested sections\n        // Now that section IDs are standardized as numbers, filtering is simple\n        const filteredMembers = members.filter(member => {\n          const memberSectionId = member.section_id || member.sectionid;\n          return memberSectionId && sectionIds.includes(memberSectionId);\n        });\n        \n        return filteredMembers;\n        \n      } catch (error) {\n        console.warn('Failed to parse comprehensive members cache:', error);\n        return [];\n      }\n    }\n    \n    const placeholders = sectionIds.map(() => '?').join(',');\n    const query = `SELECT * FROM members WHERE sectionid IN (${placeholders}) ORDER BY lastname, firstname`;\n    const result = await this.db.query(query, sectionIds);\n    \n    // Reconstruct full member objects from database\n    return (result.values || []).map(dbMember => {\n      // Parse JSON fields back to objects/arrays\n      const member = {\n        ...dbMember,\n        sections: dbMember.sections ? JSON.parse(dbMember.sections) : [],\n        contact_groups: dbMember.contact_groups ? JSON.parse(dbMember.contact_groups) : {},\n        custom_data: dbMember.custom_data ? JSON.parse(dbMember.custom_data) : {},\n        read_only: dbMember.read_only ? JSON.parse(dbMember.read_only) : [],\n      };\n      \n      // Restore flattened fields to the member object\n      if (dbMember.flattened_fields) {\n        try {\n          const flattenedFields = JSON.parse(dbMember.flattened_fields);\n          Object.assign(member, flattenedFields);\n        } catch (error) {\n          console.warn('Failed to parse flattened_fields for member:', dbMember.scoutid, error);\n        }\n      }\n      \n      // Ensure backward compatibility field mappings\n      if (!member.member_id && member.scoutid) {\n        member.member_id = member.scoutid;\n      }\n      if (!member.dateofbirth && member.date_of_birth) {\n        member.dateofbirth = member.date_of_birth;\n      }\n      \n      return member;\n    });\n  }\n\n  /**\n   * Checks if offline data is available\n   * \n   * Determines whether the application has any cached data available\n   * for offline operation. Used to decide whether to show cached\n   * content or force an online data fetch.\n   * \n   * @async\n   * @returns {Promise<boolean>} True if offline data is available\n   * \n   * @example\n   * // Check data availability before rendering\n   * const hasData = await databaseService.hasOfflineData();\n   * \n   * if (hasData) {\n   *   console.log('Offline data available - can work offline');\n   *   // Load cached sections and events\n   * } else {\n   *   console.log('No offline data - need internet connection');\n   *   // Force online data fetch\n   * }\n   */\n  async hasOfflineData() {\n    await this.initialize();\n    \n    if (!this.isNative || !this.db) {\n      // localStorage fallback - use demo prefix if in demo mode\n      const { isDemoMode } = await import('../../../config/demoMode.js');\n      const prefix = isDemoMode() ? 'demo_' : '';\n      const key = `${prefix}viking_sections_offline`;\n      const sections = safeGetItem(key, []);\n      return sections.length > 0;\n    }\n    \n    const sectionsQuery = 'SELECT COUNT(*) as count FROM sections';\n    const result = await this.db.query(sectionsQuery);\n    return result.values?.[0]?.count > 0;\n  }\n\n  /**\n   * Closes database connections and cleans up resources\n   * \n   * Properly closes SQLite connections and resets service state.\n   * Should be called when the application is shutting down or\n   * when database access is no longer needed. Safe to call\n   * multiple times or when no connection exists.\n   * \n   * @async\n   * @returns {Promise<void>} Resolves when cleanup is complete\n   * \n   * @example\n   * // Clean shutdown\n   * await databaseService.close();\n   * console.log('Database connections closed');\n   * \n   * @example\n   * // In component cleanup\n   * useEffect(() => {\n   *   return async () => {\n   *     await databaseService.close();\n   *   };\n   * }, []);\n   */\n  async close() {\n    if (this.db) {\n      await this.db.close();\n      await this.sqlite.closeConnection('vikings_db', false);\n      this.db = null;\n      this.isInitialized = false;\n    }\n  }\n}\n\n/**\n * Singleton instance of DatabaseService for global application use\n * \n * Pre-instantiated service ready for immediate use across the application.\n * Provides consistent data access patterns and maintains single connection\n * state. Import and use directly without instantiation.\n * \n * @type {DatabaseService}\n * @example\n * // Import and use immediately\n * import databaseService from './storage/database.js';\n * \n * // Initialize and start using\n * await databaseService.initialize();\n * const sections = await databaseService.getSections();\n */\nexport default new DatabaseService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/storage/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/storage/sync.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":9,"column":1,"nodeType":"Block","endLine":11,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":20,"column":3,"nodeType":"Block","endLine":23,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"callback\" description.","line":22,"column":1,"nodeType":"Block","endLine":22,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":29,"column":3,"nodeType":"Block","endLine":32,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"callback\" description.","line":31,"column":1,"nodeType":"Block","endLine":31,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":38,"column":3,"nodeType":"Block","endLine":41,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"callback\" description.","line":40,"column":1,"nodeType":"Block","endLine":40,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":47,"column":3,"nodeType":"Block","endLine":50,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"callback\" description.","line":49,"column":1,"nodeType":"Block","endLine":49,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":56,"column":3,"nodeType":"Block","endLine":59,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"status\" description.","line":58,"column":1,"nodeType":"Block","endLine":58,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":65,"column":3,"nodeType":"Block","endLine":67,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":65,"column":3,"nodeType":"Block","endLine":67,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":65,"column":3,"nodeType":"Block","endLine":67,"endColumn":6},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":88,"column":3,"nodeType":"Block","endLine":90,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":88,"column":3,"nodeType":"Block","endLine":90,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":88,"column":3,"nodeType":"Block","endLine":90,"endColumn":6},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":101,"column":3,"nodeType":"Block","endLine":103,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":101,"column":3,"nodeType":"Block","endLine":103,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":101,"column":3,"nodeType":"Block","endLine":103,"endColumn":6},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":134,"column":3,"nodeType":"Block","endLine":137,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":134,"column":3,"nodeType":"Block","endLine":137,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":134,"column":3,"nodeType":"Block","endLine":137,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"error\" description.","line":136,"column":1,"nodeType":"Block","endLine":136,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":154,"column":3,"nodeType":"Block","endLine":158,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":154,"column":3,"nodeType":"Block","endLine":158,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":154,"column":3,"nodeType":"Block","endLine":158,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"operation\" description.","line":156,"column":1,"nodeType":"Block","endLine":156,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"options\" description.","line":157,"column":1,"nodeType":"Block","endLine":157,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":189,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":189,"endColumn":15},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":308,"column":3,"nodeType":"Block","endLine":311,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":310,"column":1,"nodeType":"Block","endLine":310,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":331,"column":3,"nodeType":"Block","endLine":334,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":333,"column":1,"nodeType":"Block","endLine":333,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":353,"column":3,"nodeType":"Block","endLine":357,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionId\" description.","line":355,"column":1,"nodeType":"Block","endLine":355,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":356,"column":1,"nodeType":"Block","endLine":356,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":380,"column":3,"nodeType":"Block","endLine":386,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionId\" description.","line":382,"column":1,"nodeType":"Block","endLine":382,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"eventId\" description.","line":383,"column":1,"nodeType":"Block","endLine":383,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"termId\" description.","line":384,"column":1,"nodeType":"Block","endLine":384,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":385,"column":1,"nodeType":"Block","endLine":385,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":413,"column":3,"nodeType":"Block","endLine":417,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionId\" description.","line":415,"column":1,"nodeType":"Block","endLine":415,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":416,"column":1,"nodeType":"Block","endLine":416,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":446,"column":3,"nodeType":"Block","endLine":448,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":446,"column":3,"nodeType":"Block","endLine":448,"endColumn":6},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":446,"column":3,"nodeType":"Block","endLine":448,"endColumn":6},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":470,"column":3,"nodeType":"Block","endLine":474,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sections\" description.","line":472,"column":1,"nodeType":"Block","endLine":472,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":473,"column":1,"nodeType":"Block","endLine":473,"endColumn":1}],"suppressedMessages":[],"errorCount":51,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import databaseService from './database.js';\nimport { getUserRoles, getEvents, getEventAttendance, fetchMostRecentTermId, getTerms, getMembersGrid } from '../api/api.js';\nimport { getToken, generateOAuthUrl, validateToken } from '../auth/tokenService.js';\nimport logger, { LOG_CATEGORIES } from '../utils/logger.js';\nimport { Capacitor } from '@capacitor/core';\nimport { Network } from '@capacitor/network';\nimport { checkNetworkStatus } from '../../utils/networkUtils.js';\n\n/**\n *\n */\nclass SyncService {\n  constructor() {\n    this.isSyncing = false;\n    this.syncListeners = [];\n    this.loginPromptCallbacks = [];\n  }\n\n  // Add listener for sync status changes\n  /**\n   *\n   * @param callback\n   */\n  addSyncListener(callback) {\n    this.syncListeners.push(callback);\n  }\n\n  // Remove sync listener\n  /**\n   *\n   * @param callback\n   */\n  removeSyncListener(callback) {\n    this.syncListeners = this.syncListeners.filter(cb => cb !== callback);\n  }\n\n  // Add listener for login prompt requests\n  /**\n   *\n   * @param callback\n   */\n  addLoginPromptListener(callback) {\n    this.loginPromptCallbacks.push(callback);\n  }\n\n  // Remove login prompt listener\n  /**\n   *\n   * @param callback\n   */\n  removeLoginPromptListener(callback) {\n    this.loginPromptCallbacks = this.loginPromptCallbacks.filter(cb => cb !== callback);\n  }\n\n  // Notify listeners of sync status\n  /**\n   *\n   * @param status\n   */\n  notifyListeners(status) {\n    this.syncListeners.forEach(callback => callback(status));\n  }\n\n  // Notify listeners to show login prompt\n  /**\n   *\n   */\n  showLoginPrompt() {\n    return new Promise((resolve) => {\n      this.loginPromptCallbacks.forEach(callback => {\n        callback({\n          message: 'Authentication required to sync data. Would you like to login?',\n          onConfirm: () => {\n            // Redirect to OSM OAuth\n            const oauthUrl = generateOAuthUrl();\n            window.location.href = oauthUrl;\n            resolve(true);\n          },\n          onCancel: () => {\n            resolve(false);\n          },\n        });\n      });\n    });\n  }\n\n  // Check if we're online\n  /**\n   *\n   */\n  async isOnline() {\n    if (Capacitor.isNativePlatform()) {\n      const status = await Network.getStatus();\n      return status.connected;\n    } else {\n      return navigator.onLine;\n    }\n  }\n\n  // Check if we have a valid token before syncing\n  /**\n   *\n   */\n  async checkTokenAndPromptLogin() {\n    // Check network status first - no point prompting for login if offline\n    const isOnline = await checkNetworkStatus();\n    if (!isOnline) {\n      throw new Error('Cannot sync while offline. Connect to the internet and try again.');\n    }\n\n    const token = getToken();\n    if (!token) {\n      const shouldLogin = await this.showLoginPrompt();\n      if (!shouldLogin) {\n        throw new Error('Authentication required but user declined to login');\n      }\n      return false; // Login initiated, don't continue sync\n    }\n    \n    // Actually validate the token against the server\n    const isValid = await validateToken();\n    if (!isValid) {\n      const shouldLogin = await this.showLoginPrompt();\n      if (!shouldLogin) {\n        throw new Error('Authentication required but user declined to login');\n      }\n      return false; // Login initiated, don't continue sync\n    }\n    \n    return true; // Token is valid, continue sync\n  }\n\n  // Handle 401/403 errors by prompting for login\n  /**\n   *\n   * @param error\n   */\n  async handleAuthError(error) {\n    if (error.status === 401 || error.status === 403 || \n        error.message.includes('Invalid access token') || \n        error.message.includes('Token expired') ||\n        error.message.includes('Unauthorized')) {\n      \n      const shouldLogin = await this.showLoginPrompt();\n      if (!shouldLogin) {\n        throw new Error('Authentication failed and user declined to login');\n      }\n      return false; // Login initiated, don't continue sync\n    }\n    throw error; // Re-throw other errors\n  }\n\n  // Wrapper method to handle auth errors consistently\n  /**\n   *\n   * @param operation\n   * @param options\n   */\n  async withAuthErrorHandling(operation, options = {}) {\n    const { continueOnError = false, contextMessage = '' } = options;\n    \n    try {\n      return await operation();\n    } catch (error) {\n      console.error(`${contextMessage}:`, error);\n      \n      try {\n        const handled = await this.handleAuthError(error);\n        if (!handled) {\n          return; // Login was initiated\n        }\n      } catch (authError) {\n        if (continueOnError) {\n          console.warn(`Auth error${contextMessage ? ` for ${contextMessage}` : ''}, continuing: ${authError.message}`);\n          return;\n        }\n        throw authError;\n      }\n      \n      // Re-throw the original error for non-auth errors\n      throw error;\n    }\n  }\n\n  // Sync all data (legacy method - calls new three-stage approach)\n  async syncAll() {\n    await this.syncDashboardData();\n    // Start background sync after dashboard data is complete\n    setTimeout(() => this.syncBackgroundData(), 100);\n  }\n\n  // Stage 1: Sync core data only (fast)\n  async syncDashboardData() {\n    if (this.isSyncing) {\n      return;\n    }\n\n    try {\n      this.isSyncing = true;\n      this.notifyListeners({ status: 'syncing', message: 'Loading core data...' });\n\n      const online = await this.isOnline();\n      if (!online) {\n        throw new Error('No internet connection available');\n      }\n\n      // Check token and prompt for login if needed\n      const hasValidToken = await this.checkTokenAndPromptLogin();\n      if (!hasValidToken) {\n        this.notifyListeners({ \n          status: 'error', \n          message: 'Login required - redirecting to authentication',\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      const token = getToken();\n\n      // Load core static data - events will be loaded by buildEventCards\n      await this.syncTerms(token);\n      await this.syncSections(token);\n      \n      // Get sections for FlexiRecord preloading\n      const sections = await databaseService.getSections();\n      \n      // Preload static FlexiRecord data (lists and structures) - static like terms\n      try {\n        await this.withAuthErrorHandling(async () => {\n          this.notifyListeners({ status: 'syncing', message: 'Loading FlexiRecord structures...' });\n          await this.preloadStaticFlexiRecordData(sections, token);\n        }, { \n          continueOnError: true,\n          contextMessage: 'Failed to preload FlexiRecord static data',\n        });\n      } catch (error) {\n        logger.warn('FlexiRecord static preloading failed', { error: error.message }, LOG_CATEGORIES.SYNC);\n      }\n\n      const completionTimestamp = Date.now();\n      localStorage.setItem('viking_last_sync', completionTimestamp.toString());\n      \n      // Notify dashboard data is complete\n      this.notifyListeners({ \n        status: 'dashboard_complete', \n        message: 'Core data loaded - events loading...',\n        timestamp: completionTimestamp,\n      });\n\n    } catch (error) {\n      logger.error('Core data sync failed', { error: error.message }, LOG_CATEGORIES.SYNC);\n      \n      try {\n        const handled = await this.handleAuthError(error);\n        if (!handled) return;\n      } catch (authError) {\n        this.notifyListeners({ \n          status: 'error', \n          message: authError.message,\n          timestamp: new Date().toISOString(),\n        });\n        return;\n      }\n\n      this.notifyListeners({ \n        status: 'error', \n        message: error.message,\n        timestamp: new Date().toISOString(),\n      });\n      throw error;\n    } finally {\n      this.isSyncing = false;\n    }\n  }\n\n  // Stage 2: Sync background data (members only) - non-blocking\n  async syncBackgroundData() {\n    try {\n      this.notifyListeners({ status: 'syncing', message: 'Loading member data...' });\n\n      const token = getToken();\n      if (!token) return;\n\n      const sections = await databaseService.getSections();\n      \n      // Sync members for all sections\n      for (const section of sections) {\n        await this.syncMembers(section.sectionid, token);\n      }\n\n      this.notifyListeners({ \n        status: 'background_complete', \n        message: 'Member data loaded',\n        timestamp: Date.now(),\n      });\n\n    } catch (error) {\n      logger.warn('Background sync failed', { error: error.message }, LOG_CATEGORIES.SYNC);\n      this.notifyListeners({ \n        status: 'background_error', \n        message: `Background sync failed: ${error.message}`,\n        timestamp: Date.now(),\n      });\n    }\n  }\n\n  // Sync terms (core data needed for all section operations)\n  /**\n   *\n   * @param token\n   */\n  async syncTerms(token) {\n    try {\n      await this.withAuthErrorHandling(async () => {\n        this.notifyListeners({ status: 'syncing', message: 'Loading terms...' });\n        \n        // Load terms once for all sections - major optimization!\n        await getTerms(token);\n        // Terms loaded and cached successfully\n      }, { \n        continueOnError: false,\n        contextMessage: 'Failed to sync terms',\n      });\n    } catch (error) {\n      // Only non-auth errors reach here (auth errors are handled in wrapper)\n      throw new Error(`Failed to sync terms: ${error.message}`);\n    }\n  }\n\n  // Sync sections\n  /**\n   *\n   * @param token\n   */\n  async syncSections(token) {\n    try {\n      await this.withAuthErrorHandling(async () => {\n        this.notifyListeners({ status: 'syncing', message: 'Syncing sections...' });\n        \n        // This will fetch from server and save to database\n        await getUserRoles(token);\n      }, { \n        continueOnError: false,\n        contextMessage: 'Failed to sync sections',\n      });\n    } catch (error) {\n      // Only non-auth errors reach here (auth errors are handled in wrapper)\n      throw new Error(`Failed to sync sections: ${error.message}`);\n    }\n  }\n\n  // Sync events for a section\n  /**\n   *\n   * @param sectionId\n   * @param token\n   */\n  async syncEvents(sectionId, token) {\n    await this.withAuthErrorHandling(async () => {\n      this.notifyListeners({ status: 'syncing', message: `Syncing events for section ${sectionId}...` });\n      \n      // Get the most recent term\n      const termId = await fetchMostRecentTermId(sectionId, token);\n      if (!termId) {\n        logger.info(`No term found for section ${sectionId} - skipping events sync (this is normal for waiting lists)`, {\n          sectionId,\n        }, LOG_CATEGORIES.SYNC);\n        return;\n      }\n\n      // This will fetch from server and save to database\n      await getEvents(sectionId, termId, token);\n    }, { \n      continueOnError: true,\n      contextMessage: `Failed to sync events for section ${sectionId}`,\n    });\n  }\n\n  // Sync attendance for an event\n  /**\n   *\n   * @param sectionId\n   * @param eventId\n   * @param termId\n   * @param token\n   */\n  async syncAttendance(sectionId, eventId, termId, token) {\n    await this.withAuthErrorHandling(async () => {\n      this.notifyListeners({ status: 'syncing', message: `Syncing attendance for event ${eventId}...` });\n      \n      if (!termId) {\n        // Try to get term ID if not provided\n        termId = await fetchMostRecentTermId(sectionId, token);\n      }\n\n      if (!termId) {\n        logger.info(`No term ID available for event ${eventId} in section ${sectionId} - skipping attendance sync (this is normal for waiting lists)`, {\n          sectionId,\n          eventId,\n        }, LOG_CATEGORIES.SYNC);\n        return;\n      }\n\n      // This will fetch from server and save to database\n      await getEventAttendance(sectionId, eventId, termId, token);\n    }, { \n      continueOnError: true,\n      contextMessage: `Failed to sync attendance for event ${eventId}`,\n    });\n  }\n\n  // Sync members data for a section (includes medical information)\n  /**\n   *\n   * @param sectionId\n   * @param token\n   */\n  async syncMembers(sectionId, token) {\n    await this.withAuthErrorHandling(async () => {\n      this.notifyListeners({ status: 'syncing', message: `Syncing members for section ${sectionId}...` });\n      \n      // Get the most recent term for this section\n      const termId = await fetchMostRecentTermId(sectionId, token);\n      if (!termId) {\n        logger.info(`No term found for section ${sectionId} - skipping members sync (this is normal for waiting lists)`, {\n          sectionId,\n        }, LOG_CATEGORIES.SYNC);\n        return;\n      }\n\n      // This will fetch from server and save to database (includes medical info)\n      await getMembersGrid(sectionId, termId, token);\n      \n      logger.info('Members data synced successfully', {\n        sectionId,\n        termId,\n      }, LOG_CATEGORIES.SYNC);\n    }, { \n      continueOnError: true,\n      contextMessage: `Failed to sync members for section ${sectionId}`,\n    });\n  }\n\n\n  // Get sync status\n  /**\n   *\n   */\n  async getSyncStatus() {\n    try {\n      const hasOfflineData = await databaseService.hasOfflineData();\n      const online = await this.isOnline();\n      \n      return {\n        hasOfflineData,\n        online,\n        syncing: this.isSyncing,\n      };\n    } catch (error) {\n      console.error('Error getting sync status:', error);\n      return {\n        hasOfflineData: false,\n        online: false,\n        syncing: false,\n      };\n    }\n  }\n\n  // Preload static flexirecord data (lists and structures) for faster access later\n  /**\n   *\n   * @param sections\n   * @param token\n   */\n  async preloadStaticFlexiRecordData(sections, token) {\n    try {\n      if (!sections || !Array.isArray(sections) || sections.length === 0) {\n        logger.info('No sections provided for flexirecord preloading', {}, LOG_CATEGORIES.SYNC);\n        return;\n      }\n\n      logger.info('Preloading flexirecord structures', {\n        sectionCount: sections.length,\n      }, LOG_CATEGORIES.SYNC);\n      \n      // Import the API function here to avoid circular dependency\n      const { getFlexiRecords, getFlexiStructure } = await import('../api/api.js');\n      \n      // Load flexirecord lists for all sections first\n      const flexiRecordPromises = sections.map(async (section) => {\n        try {\n          const flexiRecords = await getFlexiRecords(section.sectionid, token, 'n', false);\n          return { sectionId: section.sectionid, flexiRecords, success: true };\n        } catch (error) {\n          logger.warn('Failed to preload flexirecords for section', {\n            sectionId: section.sectionid,\n            error: error.message,\n          }, LOG_CATEGORIES.SYNC);\n          return { sectionId: section.sectionid, flexiRecords: null, success: false };\n        }\n      });\n\n      const flexiRecordResults = await Promise.all(flexiRecordPromises);\n      const successfulSections = flexiRecordResults.filter(r => r.success);\n      \n      logger.info('Loaded flexirecord lists', {\n        successful: successfulSections.length,\n        total: sections.length,\n      }, LOG_CATEGORIES.SYNC);\n\n\n      // Now load structures for all unique flexirecords found\n      const allFlexiRecords = new Map();\n      \n      successfulSections.forEach(({ sectionId, flexiRecords }) => {\n        if (flexiRecords && flexiRecords.items) {\n          flexiRecords.items.forEach(record => {\n            if (record.extraid && record.name && record.archived !== '1' && record.soft_deleted !== '1') {\n              if (!allFlexiRecords.has(record.extraid)) {\n                allFlexiRecords.set(record.extraid, {\n                  extraid: record.extraid,\n                  name: record.name,\n                  sectionIds: [],\n                });\n              }\n              allFlexiRecords.get(record.extraid).sectionIds.push(sectionId);\n            }\n          });\n        }\n      });\n\n      if (allFlexiRecords.size === 0) {\n        logger.info('No flexirecords found to preload structures for', {}, LOG_CATEGORIES.SYNC);\n        return;\n      }\n\n      logger.info('Preloading structures for unique flexirecords', {\n        count: allFlexiRecords.size,\n      }, LOG_CATEGORIES.SYNC);\n\n      // Load structures in parallel - only for \"Viking Event Mgmt\" and \"Viking Section Movers\" records\n      const vikingRecords = Array.from(allFlexiRecords.values()).filter(record => \n        record.name === 'Viking Event Mgmt' || record.name === 'Viking Section Movers',\n      );\n      \n      logger.info('Loading structures for Viking flexirecords', {\n        totalRecords: allFlexiRecords.size,\n        vikingEventMgmt: vikingRecords.filter(r => r.name === 'Viking Event Mgmt').length,\n        vikingSectionMovers: vikingRecords.filter(r => r.name === 'Viking Section Movers').length,\n      }, LOG_CATEGORIES.SYNC);\n      \n      const structurePromises = vikingRecords.map(async (record) => {\n        try {\n          // Use first section ID for the request\n          const sectionId = record.sectionIds[0];\n          await getFlexiStructure(record.extraid, sectionId, null, token);\n          return { success: true, record };\n        } catch (error) {\n          logger.warn('Failed to preload structure for Viking flexirecord', {\n            recordName: record.name,\n            extraid: record.extraid,\n            error: error.message,\n          }, LOG_CATEGORIES.SYNC);\n          return { success: false, record };\n        }\n      });\n\n      const structureResults = await Promise.all(structurePromises);\n      const successfulStructures = structureResults.filter(r => r.success);\n\n      logger.info('Preloaded flexirecord structures', {\n        successful: successfulStructures.length,\n        total: allFlexiRecords.size,\n      }, LOG_CATEGORIES.SYNC);\n\n    } catch (error) {\n      logger.error('Error preloading flexirecord structures', {\n        error: error.message,\n        stack: error.stack,\n      }, LOG_CATEGORIES.SYNC);\n      throw error;\n    }\n  }\n\n  // Auto-sync disabled - user must manually sync via dashboard\n  async setupAutoSync() {\n    // Auto-sync functionality disabled to prevent unwanted OSM API calls\n    // User must manually trigger sync via dashboard sync button\n  }\n}\n\nexport default new SyncService();\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/utils/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/utils/logger.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":96,"column":1,"nodeType":"Block","endLine":102,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":96,"column":1,"nodeType":"Block","endLine":102,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"level\" description.","line":98,"column":1,"nodeType":"Block","endLine":98,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":99,"column":1,"nodeType":"Block","endLine":99,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"data\" description.","line":100,"column":1,"nodeType":"Block","endLine":100,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"category\" description.","line":101,"column":1,"nodeType":"Block","endLine":101,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":119,"column":1,"nodeType":"Block","endLine":121,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":119,"column":1,"nodeType":"Block","endLine":121,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":132,"column":1,"nodeType":"Block","endLine":134,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":132,"column":1,"nodeType":"Block","endLine":134,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":141,"column":1,"nodeType":"Block","endLine":143,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":141,"column":1,"nodeType":"Block","endLine":143,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":157,"column":1,"nodeType":"Block","endLine":161,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":157,"column":1,"nodeType":"Block","endLine":161,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"template\" description.","line":159,"column":1,"nodeType":"Block","endLine":159,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"args\" description.","line":160,"column":1,"nodeType":"Block","endLine":160,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":178,"column":1,"nodeType":"Block","endLine":181,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"entry\" description.","line":180,"column":1,"nodeType":"Block","endLine":180,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":216,"column":1,"nodeType":"Block","endLine":219,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"entry\" description.","line":218,"column":1,"nodeType":"Block","endLine":218,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":254,"column":1,"nodeType":"Block","endLine":261,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":254,"column":1,"nodeType":"Block","endLine":261,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"level\" description.","line":256,"column":1,"nodeType":"Block","endLine":256,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"messageTemplate\" description.","line":257,"column":1,"nodeType":"Block","endLine":257,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"data\" description.","line":258,"column":1,"nodeType":"Block","endLine":258,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"category\" description.","line":259,"column":1,"nodeType":"Block","endLine":259,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"args\" description.","line":260,"column":1,"nodeType":"Block","endLine":260,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":313,"column":14,"nodeType":"Block","endLine":315,"endColumn":4}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Centralized logging service for Vikings Event Management Mobile\n * \n * Provides structured logging with automatic Sentry integration, category-based\n * organization, and development console output. Supports template literals,\n * session tracking, and contextual metadata for comprehensive debugging.\n * \n * Features:\n * - Multi-level logging (trace, debug, info, warn, error, fatal)\n * - Category-based log organization for filtering\n * - Automatic Sentry integration for production monitoring\n * - Session tracking and user context\n * - Platform detection (mobile, Capacitor, viewport)\n * - Template literal support for dynamic messages\n * - Development console output with emoji indicators\n * \n * @module logger\n * @version 2.3.7\n * @since 2.3.7 - Created for centralized logging across the application\n * @author Vikings Event Management Team\n */\n\nimport * as Sentry from '@sentry/react';\n\n// Environment configuration - Direct environment detection to avoid circular dependencies\nconst isDevelopment = import.meta.env.DEV;\nconst isProduction = import.meta.env.PROD;\n\n/**\n * Available logging levels in order of severity\n * \n * @constant {object} LOG_LEVELS\n * @property {string} TRACE - Detailed tracing information for debugging\n * @property {string} DEBUG - Debug information for development\n * @property {string} INFO - General informational messages\n * @property {string} WARN - Warning messages for potential issues\n * @property {string} ERROR - Error conditions that need attention\n * @property {string} FATAL - Critical errors that may cause application failure\n * \n * @example\n * // Using log levels\n * logger.trace('Detailed execution flow', data, LOG_CATEGORIES.API);\n * logger.info('User logged in', { userId }, LOG_CATEGORIES.AUTH);\n * logger.error('API call failed', { error }, LOG_CATEGORIES.API);\n * \n * @since 2.3.7\n */\nexport const LOG_LEVELS = {\n  TRACE: 'trace',\n  DEBUG: 'debug', \n  INFO: 'info',\n  WARN: 'warn',\n  ERROR: 'error',\n  FATAL: 'fatal',\n};\n\n/**\n * Log categories for organizing and filtering log entries\n * \n * @constant {object} LOG_CATEGORIES\n * @property {string} APP - General application events and lifecycle\n * @property {string} API - API calls, responses, and network operations\n * @property {string} AUTH - Authentication and authorization events\n * @property {string} NAVIGATION - Route changes and navigation events\n * @property {string} USER_ACTION - User interactions and UI events\n * @property {string} PERFORMANCE - Performance metrics and timing\n * @property {string} OFFLINE - Offline mode and cached data operations\n * @property {string} SYNC - Data synchronization between local and remote\n * @property {string} COMPONENT - React component lifecycle and rendering\n * @property {string} HOOK - Custom hook operations and state changes\n * @property {string} ERROR - Error conditions and exception handling\n * \n * @example\n * // Using categories for organized logging\n * logger.info('Member data synced', { count: 25 }, LOG_CATEGORIES.SYNC);\n * logger.warn('Network unavailable, using cache', {}, LOG_CATEGORIES.OFFLINE);\n * logger.error('Authentication failed', { error }, LOG_CATEGORIES.AUTH);\n * \n * @since 2.3.7\n */\nexport const LOG_CATEGORIES = {\n  APP: 'app',\n  API: 'api',\n  AUTH: 'auth',\n  NAVIGATION: 'navigation',\n  USER_ACTION: 'user-action',\n  PERFORMANCE: 'performance',\n  OFFLINE: 'offline',\n  SYNC: 'sync',\n  COMPONENT: 'component',\n  HOOK: 'hook',\n  ERROR: 'error',\n};\n\n// Create structured log entry\n/**\n *\n * @param level\n * @param message\n * @param data\n * @param category\n */\nfunction createLogEntry(level, message, data = {}, category = LOG_CATEGORIES.APP) {\n  return {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    category,\n    sessionId: getSessionId(),\n    userId: getCurrentUserId(),\n    url: window.location.href,\n    userAgent: navigator.userAgent,\n    platform: getPlatformInfo(),\n    ...data,\n  };\n}\n\n// Get or create session ID\n/**\n *\n */\nfunction getSessionId() {\n  let sessionId = sessionStorage.getItem('logging_session_id');\n  if (!sessionId) {\n    sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    sessionStorage.setItem('logging_session_id', sessionId);\n  }\n  return sessionId;\n}\n\n// Get current user ID if available\n/**\n *\n */\nfunction getCurrentUserId() {\n  const token = sessionStorage.getItem('access_token');\n  return token ? 'authenticated' : 'anonymous';\n}\n\n// Get platform information\n/**\n *\n */\nfunction getPlatformInfo() {\n  return {\n    isMobile: /Mobi|Android/i.test(navigator.userAgent),\n    isCapacitor: window.Capacitor !== undefined,\n    platform: navigator.platform,\n    viewport: {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    },\n  };\n}\n\n// Format message with template literal support\n/**\n *\n * @param template\n * @param {...any} args\n */\nfunction formatMessage(template, ...args) {\n  if (typeof template === 'string' && args.length === 0) {\n    return template;\n  }\n  \n  if (Array.isArray(template)) {\n    // Template literal usage: logger.info`User ${userId} performed action`\n    return template.reduce((result, string, i) => {\n      return result + string + (args[i] || '');\n    }, '');\n  }\n  \n  return template;\n}\n\n// Console output with styling for development\n/**\n *\n * @param entry\n */\nfunction outputToConsole(entry) {\n  if (!isDevelopment) return;\n  \n  const styles = {\n    [LOG_LEVELS.TRACE]: 'color: #gray',\n    [LOG_LEVELS.DEBUG]: 'color: #blue', \n    [LOG_LEVELS.INFO]: 'color: #green',\n    [LOG_LEVELS.WARN]: 'color: #orange',\n    [LOG_LEVELS.ERROR]: 'color: #red',\n    [LOG_LEVELS.FATAL]: 'color: #red; font-weight: bold',\n  };\n  \n  const categoryEmojis = {\n    [LOG_CATEGORIES.APP]: '🏠',\n    [LOG_CATEGORIES.API]: '🌐',\n    [LOG_CATEGORIES.AUTH]: '🔐',\n    [LOG_CATEGORIES.NAVIGATION]: '🧭',\n    [LOG_CATEGORIES.USER_ACTION]: '👆',\n    [LOG_CATEGORIES.PERFORMANCE]: '⚡',\n    [LOG_CATEGORIES.OFFLINE]: '📴',\n    [LOG_CATEGORIES.SYNC]: '🔄',\n    [LOG_CATEGORIES.COMPONENT]: '🧩',\n    [LOG_CATEGORIES.HOOK]: '🪝',\n    [LOG_CATEGORIES.ERROR]: '❌',\n  };\n  \n  const emoji = categoryEmojis[entry.category] || '📝';\n  const style = styles[entry.level] || '';\n  \n  // Simple console log - no detailed object logging to prevent data leakage\n  console.log(`%c${emoji} [${entry.level.toUpperCase()}] ${entry.message}`, style);\n}\n\n// Send to Sentry with appropriate method\n/**\n *\n * @param entry\n */\nfunction sendToSentry(entry) {\n  const { level, message, category, ...context } = entry;\n  \n  // Add category as tag for filtering\n  Sentry.withScope((scope) => {\n    scope.setTag('category', category);\n    scope.setLevel(level);\n    scope.setContext('log_entry', context);\n    \n    // Use appropriate Sentry method based on level\n    if (level === LOG_LEVELS.ERROR || level === LOG_LEVELS.FATAL) {\n      if (context.error) {\n        scope.setContext('error_details', {\n          message: context.error.message,\n          stack: context.error.stack,\n          name: context.error.name,\n        });\n        Sentry.captureException(context.error);\n      } else {\n        Sentry.captureMessage(message, level);\n      }\n    } else {\n      // Use Sentry's structured logger for other levels\n      if (Sentry.logger) {\n        Sentry.logger[level](message, context);\n      } else {\n        // Fallback to captureMessage\n        Sentry.captureMessage(message, level);\n      }\n    }\n  });\n}\n\n// Core logging function\n/**\n *\n * @param level\n * @param messageTemplate\n * @param data\n * @param category\n * @param {...any} args\n */\nfunction log(level, messageTemplate, data = {}, category = LOG_CATEGORIES.APP, ...args) {\n  const message = formatMessage(messageTemplate, ...args);\n  const entry = createLogEntry(level, message, data, category);\n  \n  // Always output to console in development\n  outputToConsole(entry);\n  \n  // Send to Sentry based on level and environment\n  if (isProduction || level === LOG_LEVELS.ERROR || level === LOG_LEVELS.FATAL) {\n    sendToSentry(entry);\n  }\n  \n  return entry;\n}\n\n/**\n * Main logger interface with structured logging and Sentry integration\n * \n * Provides logging methods for all severity levels with automatic Sentry\n * integration, session tracking, and development console output. Supports\n * template literals and contextual data for comprehensive debugging.\n * \n * @namespace logger\n * @example\n * // Basic logging with categories\n * import logger, { LOG_CATEGORIES } from '@/shared/services/utils/logger.js';\n * \n * logger.info('User logged in successfully', { userId: '123' }, LOG_CATEGORIES.AUTH);\n * logger.error('API call failed', { error, endpoint }, LOG_CATEGORIES.API);\n * logger.warn('Using cached data', { reason: 'offline' }, LOG_CATEGORIES.OFFLINE);\n * \n * @example\n * // Template literal support\n * const userId = '123';\n * const action = 'login';\n * logger.info`User ${userId} performed ${action}`;\n * \n * @example\n * // Error logging with context\n * try {\n *   await api.saveEvent(eventData);\n *   logger.info('Event saved successfully', { eventId: event.id }, LOG_CATEGORIES.API);\n * } catch (error) {\n *   logger.error('Failed to save event', { \n *     error, \n *     eventData: { id: event.id, title: event.title }\n *   }, LOG_CATEGORIES.ERROR);\n * }\n * \n * @since 2.3.7\n */\nexport const /**\n *\n */\n  logger = {\n  /**\n   * Log trace-level messages for detailed debugging\n   * \n   * @param {string|Array} messageTemplate - Log message or template literal\n   * @param {object} [data={}] - Additional context data\n   * @param {string} [category=LOG_CATEGORIES.APP] - Log category for filtering\n   * @param {...*} args - Template literal arguments\n   * @returns {object} Created log entry\n   * \n   * @example\n   * logger.trace('Function entry', { params }, LOG_CATEGORIES.COMPONENT);\n   */\n    trace: (messageTemplate, data, category, ...args) => \n      log(LOG_LEVELS.TRACE, messageTemplate, data, category, ...args),\n    \n    /**\n   * Log debug-level messages for development\n   * \n   * @param {string|Array} messageTemplate - Log message or template literal\n   * @param {object} [data={}] - Additional context data\n   * @param {string} [category=LOG_CATEGORIES.APP] - Log category for filtering\n   * @param {...*} args - Template literal arguments\n   * @returns {object} Created log entry\n   * \n   * @example\n   * logger.debug('State updated', { newState }, LOG_CATEGORIES.HOOK);\n   */\n    debug: (messageTemplate, data, category, ...args) => \n      log(LOG_LEVELS.DEBUG, messageTemplate, data, category, ...args),\n    \n    /**\n   * Log informational messages for general events\n   * \n   * @param {string|Array} messageTemplate - Log message or template literal\n   * @param {object} [data={}] - Additional context data\n   * @param {string} [category=LOG_CATEGORIES.APP] - Log category for filtering\n   * @param {...*} args - Template literal arguments\n   * @returns {object} Created log entry\n   * \n   * @example\n   * logger.info('Data synced successfully', { recordCount: 25 }, LOG_CATEGORIES.SYNC);\n   */\n    info: (messageTemplate, data, category, ...args) => \n      log(LOG_LEVELS.INFO, messageTemplate, data, category, ...args),\n    \n    /**\n   * Log warning messages for potential issues\n   * \n   * @param {string|Array} messageTemplate - Log message or template literal\n   * @param {object} [data={}] - Additional context data\n   * @param {string} [category=LOG_CATEGORIES.APP] - Log category for filtering\n   * @param {...*} args - Template literal arguments\n   * @returns {object} Created log entry\n   * \n   * @example\n   * logger.warn('API response slow', { duration: 5000 }, LOG_CATEGORIES.PERFORMANCE);\n   */\n    warn: (messageTemplate, data, category, ...args) => \n      log(LOG_LEVELS.WARN, messageTemplate, data, category, ...args),\n    \n    /**\n   * Log error messages that need attention\n   * \n   * @param {string|Array} messageTemplate - Log message or template literal\n   * @param {object} [data={}] - Additional context data including error object\n   * @param {string} [category=LOG_CATEGORIES.ERROR] - Log category for filtering\n   * @param {...*} args - Template literal arguments\n   * @returns {object} Created log entry\n   * \n   * @example\n   * logger.error('Network request failed', { error, url }, LOG_CATEGORIES.API);\n   */\n    error: (messageTemplate, data, category, ...args) => \n      log(LOG_LEVELS.ERROR, messageTemplate, data, category, ...args),\n    \n    /**\n   * Log fatal errors that may cause application failure\n   * \n   * @param {string|Array} messageTemplate - Log message or template literal\n   * @param {object} [data={}] - Additional context data including error object\n   * @param {string} [category=LOG_CATEGORIES.ERROR] - Log category for filtering\n   * @param {...*} args - Template literal arguments\n   * @returns {object} Created log entry\n   * \n   * @example\n   * logger.fatal('Application crash', { error, stack }, LOG_CATEGORIES.ERROR);\n   */\n    fatal: (messageTemplate, data, category, ...args) => \n      log(LOG_LEVELS.FATAL, messageTemplate, data, category, ...args),\n    \n    /**\n   * Format message template with arguments\n   * \n   * @param {string|Array} template - Message template\n   * @param {...*} args - Template arguments\n   * @returns {string} Formatted message\n   * \n   * @example\n   * const msg = logger.fmt`User ${userId} saved event ${eventId}`;\n   */\n    fmt: (template, ...args) => formatMessage(template, ...args),\n  };\n\nexport default logger;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/services/utils/sentry.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":12,"column":1,"nodeType":"Block","endLine":14,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":111,"column":14,"nodeType":"Block","endLine":113,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Sentry configuration for Vikings Event Management Mobile\nimport * as Sentry from '@sentry/react';\nimport packageJson from '../../../../package.json';\nimport { config } from '../../../config/env.js';\n\n// Environment configuration - Use robust detection from config\nconst environment = config.actualEnvironment;\nconst release = packageJson.version;\nconst sentryDsn = config.sentryDsn;\n\n// Initialize Sentry\n/**\n *\n */\nexport function initSentry() {\n  // Don't initialize Sentry if DSN is not provided\n  if (!sentryDsn) {\n    console.warn('Sentry DSN not provided, skipping initialization');\n    return;\n  }\n\n  console.log('🔧 Initializing Sentry with DSN:', sentryDsn ? 'Present' : 'Missing');\n  console.log('🔧 Environment:', environment);\n\n  Sentry.init({\n    dsn: sentryDsn,\n    environment: environment,\n    release: `vikings-eventmgmt-mobile@${release}`,\n    \n    // Performance monitoring\n    tracesSampleRate: environment === 'production' ? 0.1 : 1.0,\n    \n    // Enable experimental features\n    _experiments: {\n      enableLogs: true,\n    },\n    \n    // Integrations\n    integrations: [\n      // Browser tracing for performance monitoring\n      Sentry.browserTracingIntegration(),\n      \n      // Console logging integration\n      Sentry.consoleLoggingIntegration({ \n        levels: ['log', 'error', 'warn', 'info'], \n      }),\n      \n      // Replay integration for debugging (only in production)\n      ...(environment === 'production' ? [\n        Sentry.replayIntegration({\n          maskAllText: true,\n          blockAllMedia: true,\n        }),\n      ] : []),\n    ],\n    \n    // Session replay sample rate\n    replaysSessionSampleRate: environment === 'production' ? 0.1 : 0.0,\n    replaysOnErrorSampleRate: 1.0,\n    \n    // Custom error filtering\n    beforeSend(event, hint) {\n      // Filter out development errors\n      if (environment === 'development') {\n        console.group('🔍 Sentry Event');\n        console.log('Event:', event);\n        console.log('Hint:', hint);\n        console.log('📤 Sending to Sentry...');\n        console.groupEnd();\n      }\n      \n      // Filter out network errors during offline mode\n      if (event.exception) {\n        const originalException = hint.originalException;\n        if (originalException && originalException.message && \n            (originalException.message.includes('NetworkError') || \n             originalException.message.includes('Failed to fetch'))) {\n          return null; // Don't send to Sentry\n        }\n      }\n      \n      return event;\n    },\n    \n    // Initial scope configuration\n    initialScope: {\n      tags: {\n        component: 'mobile-app',\n        platform: 'react-capacitor',\n      },\n      context: {\n        app: {\n          name: 'Vikings Event Management Mobile',\n          version: release,\n        },\n      },\n    },\n  });\n  \n  console.log('✅ Sentry initialized successfully');\n  \n  // NOTE: Do not set user context during initialization as it can cause \n  // \"t is not a function\" errors in mobile/Capacitor environments.\n  // User context is set in auth.js when login is successful.\n}\n\n// Get the logger instance\nexport const logger = Sentry.logger;\n\n// Utility functions for common Sentry operations\nexport const /**\n *\n */\n  sentryUtils = {\n  // Capture exceptions with rich context\n    captureException: (error, { tags, contexts, extra, user, level } = {}) => {\n      try {\n        Sentry.withScope((scope) => {\n          if (level) scope.setLevel(level);\n          if (user) scope.setUser(user);\n          if (tags) scope.setTags(tags);\n          if (extra) scope.setExtras(extra);\n          if (contexts) {\n            Object.entries(contexts).forEach(([name, ctx]) => scope.setContext(name, ctx));\n          }\n          Sentry.captureException(error);\n        });\n      } catch (sentryError) {\n        console.error('Failed to capture exception to Sentry:', sentryError);\n      }\n    },\n  \n    // Capture messages with level and optional context\n    captureMessage: (message, level = 'info', { tags, contexts, extra, user } = {}) => {\n      try {\n        Sentry.withScope((scope) => {\n          scope.setLevel(level);\n          if (user) scope.setUser(user);\n          if (tags) scope.setTags(tags);\n          if (extra) scope.setExtras(extra);\n          if (contexts) {\n            Object.entries(contexts).forEach(([name, ctx]) => scope.setContext(name, ctx));\n          }\n          Sentry.captureMessage(message);\n        });\n      } catch (sentryError) {\n        console.error('Failed to capture message to Sentry:', sentryError);\n      }\n    },\n  \n    // Set user context\n    setUser: (user) => {\n      Sentry.setUser(user);\n    },\n  \n    // Clear Sentry scope to avoid cross-user leakage\n    clearScope: () => {\n      Sentry.setUser(null);\n      Sentry.setTags({});\n      Sentry.setExtras({});\n      Sentry.setContext('user', null);\n    // Note: clearBreadcrumbs and setFingerprint are not available as global functions in v8\n    // These were scope-specific methods that are no longer needed with the new API\n    },\n  \n    // Add breadcrumb\n    addBreadcrumb: (breadcrumb) => {\n      Sentry.addBreadcrumb(breadcrumb);\n    },\n  \n    // Performance monitoring utilities\n    startSpan: Sentry.startSpan,\n  \n    // Create transaction for long-running operations\n    createTransaction: (name, operation = 'custom') => {\n      return Sentry.startSpan({\n        op: operation,\n        name: name,\n      });\n    },\n  };\n\nexport default Sentry;\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/ageUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/asyncUtils.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":27,"column":14,"nodeType":"Block","endLine":30,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":27,"column":14,"nodeType":"Block","endLine":30,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"ms\" description.","line":29,"column":1,"nodeType":"Block","endLine":29,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":60,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":17},{"ruleId":"jsdoc/no-undefined-types","severity":2,"message":"The type 'AbortSignal' is undefined.","line":69,"column":1,"nodeType":"Block","endLine":69,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":85,"column":14,"nodeType":"Block","endLine":89,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"ms\" description.","line":87,"column":1,"nodeType":"Block","endLine":87,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"signal\" description.","line":88,"column":1,"nodeType":"Block","endLine":88,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":119,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":119,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":126,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":126,"endColumn":21},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":166,"column":14,"nodeType":"Block","endLine":169,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":166,"column":14,"nodeType":"Block","endLine":169,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"timestamp\" description.","line":168,"column":1,"nodeType":"Block","endLine":168,"endColumn":1}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Async utility functions for Vikings Event Management Mobile\nimport { sentryUtils } from '../services/utils/sentry.js';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\n\n/**\n * Sleep for a specified number of milliseconds\n * Provides a simple delay mechanism commonly used for rate limiting and timing control\n * \n * @param {number} ms - Milliseconds to sleep (must be positive number)\n * @returns {Promise<void>} Promise that resolves after the delay\n * @throws {Error} If ms is not a valid positive number\n * \n * @example\n * // Simple delay for rate limiting\n * await sleep(1000); // Wait 1 second\n * \n * // Progressive delays in retry logic\n * for (let i = 0; i < 3; i++) {\n *   try {\n *     await apiCall();\n *     break;\n *   } catch (error) {\n *     await sleep(1000 * Math.pow(2, i)); // Exponential backoff\n *   }\n * }\n */\nexport const /**\n *\n * @param ms\n */\n  sleep = (ms) => {\n  // Input validation\n    if (typeof ms !== 'number' || ms < 0 || !isFinite(ms)) {\n      const error = new Error(`Invalid sleep duration: ${ms}. Must be a positive finite number.`);\n    \n      logger.error('Invalid sleep duration', {\n        providedValue: ms,\n        providedType: typeof ms,\n        isFinite: isFinite(ms),\n      }, LOG_CATEGORIES.ERROR);\n    \n      sentryUtils.captureException(error, {\n        tags: {\n          operation: 'async_utils_sleep',\n          validation_error: true,\n        },\n        contexts: {\n          input: {\n            value: ms,\n            type: typeof ms,\n            isFinite: isFinite(ms),\n          },\n        },\n      });\n    \n      throw error;\n    }\n\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  };\n\n/**\n * Sleep with timeout abort capability for cancellable operations\n * Useful for operations that need to be cancelled mid-flight\n * \n * @param {number} ms - Milliseconds to sleep (must be positive number)\n * @param {AbortSignal} [signal] - Optional abort signal to cancel the sleep\n * @returns {Promise<void>} Promise that resolves after delay or rejects if aborted\n * @throws {Error} If ms is invalid or if operation is aborted\n * \n * @example\n * // Cancellable delay with timeout\n * const controller = new AbortController();\n * \n * try {\n *   // Cancel after 5 seconds\n *   setTimeout(() => controller.abort(), 5000);\n *   await sleepWithAbort(10000, controller.signal); // Will be cancelled\n * } catch (error) {\n *   console.log('Sleep was cancelled');\n * }\n */\nexport const /**\n *\n * @param ms\n * @param signal\n */\n  sleepWithAbort = (ms, signal) => {\n  // Input validation\n    if (typeof ms !== 'number' || ms < 0 || !isFinite(ms)) {\n      const error = new Error(`Invalid sleep duration: ${ms}. Must be a positive finite number.`);\n    \n      logger.error('Invalid sleepWithAbort duration', {\n        providedValue: ms,\n        providedType: typeof ms,\n        isFinite: isFinite(ms),\n        hasSignal: !!signal,\n      }, LOG_CATEGORIES.ERROR);\n    \n      throw error;\n    }\n\n    return new Promise((resolve, reject) => {\n    // Check if already aborted\n      if (signal?.aborted) {\n        const abortError = new Error('Sleep aborted before starting');\n      \n        logger.debug('Sleep aborted before starting', {\n          duration: ms,\n          abortReason: signal.reason || 'Unknown',\n        }, LOG_CATEGORIES.APP);\n      \n        reject(abortError);\n        return;\n      }\n    \n      const timeoutId = setTimeout(() => {\n        logger.debug('Sleep completed successfully', { duration: ms }, LOG_CATEGORIES.APP);\n        resolve();\n      }, ms);\n    \n      // Set up abort listener\n      const abortHandler = () => {\n        clearTimeout(timeoutId);\n      \n        const abortError = new Error('Sleep aborted');\n        abortError.cause = signal?.reason;\n      \n        logger.debug('Sleep aborted mid-flight', {\n          duration: ms,\n          abortReason: signal?.reason || 'Unknown',\n        }, LOG_CATEGORIES.APP);\n      \n        reject(abortError);\n      };\n    \n      signal?.addEventListener('abort', abortHandler, { once: true });\n    });\n  };\n\n/**\n * Parse a timestamp to epoch milliseconds with robust handling\n * Handles various timestamp formats consistently across the application\n * \n * @param {string|number|Date} timestamp - Timestamp in various formats\n * @returns {number|null} Epoch milliseconds or null if invalid\n * \n * @example\n * // String epoch timestamp\n * parseTimestamp('1640995200000') // → 1640995200000\n * \n * // ISO string\n * parseTimestamp('2022-01-01T00:00:00.000Z') // → 1640995200000\n * \n * // Number epoch\n * parseTimestamp(1640995200000) // → 1640995200000\n * \n * // Date object\n * parseTimestamp(new Date('2022-01-01')) // → 1640995200000\n * \n * // Invalid timestamp\n * parseTimestamp('invalid') // → null\n */\nexport const /**\n *\n * @param timestamp\n */\n  parseTimestamp = (timestamp) => {\n    if (!timestamp) return null;\n\n    const now = Date.now();\n    let syncTimeMs;\n\n    try {\n    // Handle different timestamp formats\n      if (typeof timestamp === 'string') {\n        if (/^\\d+$/.test(timestamp)) {\n        // Epoch timestamp as string (standard format)\n          syncTimeMs = parseInt(timestamp, 10);\n        } else {\n        // ISO string (legacy format) \n          syncTimeMs = new Date(timestamp).getTime();\n        }\n      } else if (typeof timestamp === 'number') {\n      // Epoch timestamp as number\n        syncTimeMs = timestamp;\n      } else {\n      // Date object or other types\n        syncTimeMs = new Date(timestamp).getTime();\n      }\n    \n      // Validate the parsed timestamp\n      if (Number.isNaN(syncTimeMs) || syncTimeMs <= 0) {\n        logger.debug('Invalid timestamp parsed to NaN or non-positive', {\n          originalTimestamp: timestamp,\n          originalType: typeof timestamp,\n          parsedValue: syncTimeMs,\n        }, LOG_CATEGORIES.APP);\n        return null;\n      }\n    \n      // Sanity check: reject timestamps too far in the future (more than 1 day)\n      if (syncTimeMs > now + 24 * 60 * 60 * 1000) {\n        logger.warn('Timestamp parsing: far future timestamp rejected', {\n          originalTimestamp: timestamp,\n          parsedDate: new Date(syncTimeMs).toISOString(),\n          futureByMs: syncTimeMs - now,\n        }, LOG_CATEGORIES.APP);\n        return null;\n      }\n    \n      return syncTimeMs;\n    \n    } catch (error) {\n      logger.error('Error parsing timestamp', {\n        originalTimestamp: timestamp,\n        originalType: typeof timestamp,\n        error: error.message,\n      }, LOG_CATEGORIES.ERROR);\n    \n      sentryUtils.captureException(error, {\n        tags: {\n          operation: 'parse_timestamp',\n        },\n        contexts: {\n          input: {\n            timestamp,\n            type: typeof timestamp,\n          },\n        },\n      });\n    \n      return null;\n    }\n  };","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/cacheCleanup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/cn.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":12,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":12,"column":1,"nodeType":"Block","endLine":15,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"classes\" description.","line":14,"column":1,"nodeType":"Block","endLine":14,"endColumn":1}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import clsx from 'clsx';\n\n/**\n * Utility function for conditionally joining class names\n * Uses clsx for better performance and conditional logic support\n * \n * Examples:\n * cn('base', condition && 'conditional', { 'active': isActive })\n * cn(['base', 'other'], { 'variant': true })\n */\n\n/**\n *\n * @param {...any} classes\n */\nexport function cn(...classes) {\n  return clsx(classes);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/contactGroups.js","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":1,"column":1,"nodeType":"Block","endLine":6,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"member\" description.","line":5,"column":1,"nodeType":"Block","endLine":5,"endColumn":1}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Utility function to group contact information from member data\n * Handles both flattened fields (contact__field) and nested contact_groups\n * Preserves falsy values (false, 0) that are meaningful for consents and flags\n * @param member\n */\nexport function groupContactInfo(member) {\n  const groups = {};\n\n  // Process flattened contact fields\n  Object.entries(member).forEach(([key, value]) => {\n    if (\n      key.includes('__') &&\n      value !== undefined &&\n      value !== null &&\n      !(typeof value === 'string' && value.trim() === '')\n    ) {\n      const [groupName, fieldName] = key.split('__');\n      if (!groups[groupName]) {\n        groups[groupName] = {};\n      }\n      groups[groupName][fieldName] = value;\n    }\n  });\n\n  // Add legacy fields to appropriate groups\n  const hasEmail = member.email !== undefined && member.email !== null && String(member.email).trim() !== '';\n  const hasPhone = member.phone !== undefined && member.phone !== null && String(member.phone).trim() !== '';\n  if (hasEmail || hasPhone) {\n    if (!groups.member_contact) {\n      groups.member_contact = {};\n    }\n    if (hasEmail) groups.member_contact.email = member.email;\n    if (hasPhone) groups.member_contact.phone = member.phone;\n  }\n\n  // Note: Backend now only creates flattened fields, no nested contact_groups processing needed\n\n  return groups;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/eventDashboardHelpers.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":16,"column":14,"nodeType":"Block","endLine":20,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":16,"column":14,"nodeType":"Block","endLine":20,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sections\" description.","line":18,"column":1,"nodeType":"Block","endLine":18,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":19,"column":1,"nodeType":"Block","endLine":19,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":80,"column":14,"nodeType":"Block","endLine":85,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":80,"column":14,"nodeType":"Block","endLine":85,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"section\" description.","line":82,"column":1,"nodeType":"Block","endLine":82,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":83,"column":1,"nodeType":"Block","endLine":83,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"allTerms\" description.","line":84,"column":1,"nodeType":"Block","endLine":84,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":187,"column":14,"nodeType":"Block","endLine":192,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":187,"column":14,"nodeType":"Block","endLine":192,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"event\" description.","line":189,"column":1,"nodeType":"Block","endLine":189,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"token\" description.","line":190,"column":1,"nodeType":"Block","endLine":190,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"_allEvents\" description.","line":191,"column":1,"nodeType":"Block","endLine":191,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":428,"column":14,"nodeType":"Block","endLine":431,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":428,"column":14,"nodeType":"Block","endLine":431,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":430,"column":1,"nodeType":"Block","endLine":430,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":452,"column":14,"nodeType":"Block","endLine":456,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":452,"column":14,"nodeType":"Block","endLine":456,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"eventName\" description.","line":454,"column":1,"nodeType":"Block","endLine":454,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":455,"column":1,"nodeType":"Block","endLine":455,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":477,"column":14,"nodeType":"Block","endLine":481,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":477,"column":14,"nodeType":"Block","endLine":481,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":479,"column":1,"nodeType":"Block","endLine":479,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"oneWeekAgo\" description.","line":480,"column":1,"nodeType":"Block","endLine":480,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":494,"column":14,"nodeType":"Block","endLine":497,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":494,"column":14,"nodeType":"Block","endLine":497,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"attendanceData\" description.","line":496,"column":1,"nodeType":"Block","endLine":496,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":511,"column":14,"nodeType":"Block","endLine":514,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":511,"column":14,"nodeType":"Block","endLine":514,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":513,"column":1,"nodeType":"Block","endLine":513,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":524,"column":14,"nodeType":"Block","endLine":527,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":524,"column":14,"nodeType":"Block","endLine":527,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sharedEventData\" description.","line":526,"column":1,"nodeType":"Block","endLine":526,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":616,"column":14,"nodeType":"Block","endLine":620,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":616,"column":14,"nodeType":"Block","endLine":620,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"events\" description.","line":618,"column":1,"nodeType":"Block","endLine":618,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"attendanceMap\" description.","line":619,"column":1,"nodeType":"Block","endLine":619,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":647,"column":14,"nodeType":"Block","endLine":652,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":647,"column":14,"nodeType":"Block","endLine":652,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sharedAttendanceData\" description.","line":649,"column":1,"nodeType":"Block","endLine":649,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionSpecificAttendanceData\" description.","line":650,"column":1,"nodeType":"Block","endLine":650,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionsToShow\" description.","line":651,"column":1,"nodeType":"Block","endLine":651,"endColumn":1}],"suppressedMessages":[],"errorCount":43,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Event Dashboard Helper Functions\n// Extracted from EventDashboard component for better testability and reusability\n\nimport { fetchMostRecentTermId, getEvents, getEventAttendance, getTerms, getEventSummary, getEventSharingStatus } from '../services/api/api.js';\nimport { getMostRecentTermId } from './termUtils.js';\nimport databaseService from '../services/storage/database.js';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\nimport { isDemoMode } from '../../config/demoMode.js';\n\n/**\n * Fetches events for all sections with optimized terms loading\n * @param {Array} sections - Array of section objects\n * @param {string|null} token - Authentication token (null for cache-only)\n * @returns {Promise<Array>} Array of all events from all sections\n */\nexport const /**\n *\n * @param sections\n * @param token\n */\n  fetchAllSectionEvents = async (sections, token) => {\n    const allEvents = [];\n  \n    // Load terms once for all sections (major optimization!)\n    let allTerms = null;\n    if (token) {\n      try {\n        logger.info('Loading terms once for all sections', {}, LOG_CATEGORIES.COMPONENT);\n        allTerms = await getTerms(token); // This will use cache from sync process\n        logger.info('Using cached terms', { sectionCount: Object.keys(allTerms || {}).length }, LOG_CATEGORIES.COMPONENT);\n      } catch (err) {\n        logger.error('Error loading terms, will use individual API calls as fallback', { error: err }, LOG_CATEGORIES.COMPONENT);\n      }\n    } else {\n    // Load offline cached terms once (avoid per-section localStorage parsing)\n      try {\n        if (typeof localStorage !== 'undefined') {\n          const demoMode = isDemoMode();\n          const termsKey = demoMode ? 'demo_viking_terms_offline' : 'viking_terms_offline';\n          const cachedTerms = localStorage.getItem(termsKey);\n          if (cachedTerms) {\n            allTerms = JSON.parse(cachedTerms);\n            logger.info('Using offline cached terms', { sectionCount: Object.keys(allTerms || {}).length }, LOG_CATEGORIES.COMPONENT);\n          }\n        }\n      } catch (err) {\n        logger.warn('Failed to parse offline terms from localStorage', { error: err }, LOG_CATEGORIES.COMPONENT);\n      }\n    }\n  \n    // Fetch events for all sections using cached terms\n    const results = await Promise.all(\n      sections.map(async (section) => {\n        try {\n          return await fetchSectionEvents(section, token, allTerms);\n        } catch (err) {\n          logger.error('Error processing section {sectionId}', { \n            error: err, \n            sectionId: section.sectionid,\n            sectionName: section.sectionname, \n          }, LOG_CATEGORIES.COMPONENT);\n          return [];\n        }\n      }),\n    );\n    for (const sectionEvents of results) {\n      allEvents.push(...sectionEvents);\n    }\n  \n    return allEvents;\n  };\n\n/**\n * Fetches events for a single section from API or cache\n * @param {object} section - Section object with sectionid and sectionname\n * @param {string|null} token - Authentication token (null for cache-only)\n * @param {object | null} allTerms - Pre-loaded terms data (optional optimization)\n * @returns {Promise<Array>} Array of events for the section\n */\nexport const /**\n *\n * @param section\n * @param token\n * @param allTerms\n */\n  fetchSectionEvents = async (section, token, allTerms = null) => {\n    try {\n      let events = [];\n    \n      if (token) {\n      // Rate limiting handled by queue\n      \n        // Fetch from API - use cached terms if available for major optimization\n        // Defensive check for section ID (allows valid falsy values like 0)\n        if (section.sectionid === null || section.sectionid === undefined) {\n          logger.warn('Skipping section with invalid ID in fetchSectionEvents', {\n            sectionid: section.sectionid,\n            sectionname: section.sectionname,\n            sectiontype: section.sectiontype,\n            section: section.section,\n          }, LOG_CATEGORIES.API);\n          return []; // Return empty array for invalid section\n        }\n      \n        let termId;\n        if (allTerms) {\n        // Use pre-loaded terms (avoids API call per section!)\n          termId = getMostRecentTermId(section.sectionid, allTerms);\n        } else {\n        // Fallback to individual API call\n          termId = await fetchMostRecentTermId(section.sectionid, token);\n        }\n      \n        if (termId) {\n        // Rate limiting now handled by RateLimitQueue\n          const sectionEvents = await getEvents(section.sectionid, termId, token);\n          if (sectionEvents && Array.isArray(sectionEvents)) {\n            events = sectionEvents.map(event => ({\n              ...event,\n              sectionid: section.sectionid,\n              sectionname: section.sectionname,\n              termid: termId,\n            }));\n          \n            // Save to cache (with termid included)\n            await databaseService.saveEvents(section.sectionid, events);\n          }\n        }\n      } else {\n      // Load from cache\n        const cachedEvents = (await databaseService.getEvents(section.sectionid)) || [];\n      \n        // Get termId for cached events too (same logic as API path)\n        let termId;\n        if (allTerms) {\n        // Use pre-loaded terms (avoids API call per section!)\n          termId = getMostRecentTermId(section.sectionid, allTerms);\n        } else {\n        // Fallback: try to get from cached event or fetch from API if needed\n          termId = cachedEvents[0]?.termid;\n        \n          // If still no termId, try to get from localStorage terms cache\n          if (!termId) {\n            try {\n              const demoMode = isDemoMode();\n              const termsKey = demoMode ? 'demo_viking_terms_offline' : 'viking_terms_offline';\n              const cachedTerms = localStorage.getItem(termsKey);\n              if (cachedTerms) {\n                const parsedTerms = JSON.parse(cachedTerms);\n                termId = getMostRecentTermId(section.sectionid, parsedTerms);\n              }\n            } catch (error) {\n              logger.warn('Failed to get termId from localStorage terms cache', { error }, LOG_CATEGORIES.COMPONENT);\n            }\n          }\n        }\n      \n        events = cachedEvents.map(event => ({\n          ...event,\n          sectionid: section.sectionid,  // CRITICAL FIX: Add missing sectionid \n          sectionname: section.sectionname,\n          termid: termId || event.termid, // Use fetched termId, fallback to cached termid (don't default to null)\n        }));\n      \n      }\n    \n      return events;\n    } catch (err) {\n      logger.error('Error fetching events for section {sectionId}', { \n        error: err, \n        sectionId: section.sectionid,\n        sectionName: section.sectionname,\n      }, LOG_CATEGORIES.API);\n      return [];\n    }\n  };\n\n/**\n * Fetches attendance data for a single event from API or cache\n * For shared events where user has access to owner section, fetches and merges shared attendance data\n * @param {object} event - Event object with eventid, sectionid, termid\n * @param {string|null} token - Authentication token (null for cache-only)\n * @param {Array|null} allEvents - Array of all events (needed for shared event processing)\n * @param _allEvents\n * @returns {Promise<Array|null>} Attendance data (merged for shared events) or null if failed\n */\nexport const /**\n *\n * @param event\n * @param token\n * @param _allEvents\n */\n  fetchEventAttendance = async (event, token, _allEvents = null) => {\n    try {\n    // Skip all API calls in demo mode to prevent rate limiting, but still process shared events\n      const demoMode = isDemoMode();\n      if (!token && !demoMode) {\n      // No token and not demo mode - load from database cache only\n        const cachedAttendance = await databaseService.getAttendance(event.eventid);\n        // Handle both array format (regular events) and object format (shared events)\n        if (Array.isArray(cachedAttendance)) {\n          return cachedAttendance;\n        } else if (cachedAttendance && cachedAttendance.items) {\n          return cachedAttendance.items;\n        }\n        return cachedAttendance || [];\n      }\n    \n      // In demo mode, first check localStorage cache (where demo data is stored)\n      if (demoMode) {\n        try {\n          const cacheKey = `demo_viking_attendance_${event.sectionid}_${event.termid}_${event.eventid}_offline`;\n          const cachedData = localStorage.getItem(cacheKey);\n          if (cachedData) {\n            const attendanceData = JSON.parse(cachedData);\n          \n            // Check if this is a shared event in demo mode by looking for shared metadata\n            const { isDemoMode } = await import('../../config/demoMode.js');\n            const prefix = isDemoMode() ? 'demo_' : '';\n            const sharedMetadataKey = `${prefix}viking_shared_metadata_${event.eventid}`;\n            const sharedMetadata = localStorage.getItem(sharedMetadataKey);\n            if (sharedMetadata) {\n              try {\n                const metadata = JSON.parse(sharedMetadata);\n                if (metadata._isSharedEvent) {\n                \n                  // For shared events in demo mode, we might need to combine with other sections\n                  // Check if there are other sections' data to combine\n                  const allSections = metadata._allSections || [];\n                  const combinedAttendanceData = [...attendanceData];\n                \n                  // Add synthetic attendance data for other sections if needed\n                  for (const section of allSections) {\n                    if (section.sectionid !== event.sectionid && section.attendance > 0) {\n                    // Generate synthetic attendees for this section\n                      for (let i = 0; i < section.attendance; i++) {\n                        combinedAttendanceData.push({\n                          scoutid: `synthetic-${section.sectionid}-${i}`,\n                          sectionid: section.sectionid,\n                          sectionname: section.sectionname,\n                          attending: 'Yes',\n                          firstname: `Member ${i + 1}`,\n                          lastname: `(${section.sectionname})`,\n                          groupname: section.groupname,\n                        });\n                      }\n                    }\n                  }\n                \n                  return combinedAttendanceData;\n                }\n              } catch (metadataError) {\n                if (import.meta.env.DEV) {\n                  logger.warn('Failed to parse shared metadata in demo mode', {\n                    eventId: event.eventid,\n                    error: metadataError.message,\n                  }, LOG_CATEGORIES.COMPONENT);\n                }\n              }\n            }\n          \n            return attendanceData;\n          }\n        } catch (error) {\n          if (import.meta.env.DEV) {\n            logger.warn('Failed to parse demo attendance data from localStorage', {\n              eventId: event.eventid,\n              error: error.message,\n            }, LOG_CATEGORIES.COMPONENT);\n          }\n        }\n      \n        // If no localStorage data found, return empty array for demo mode\n        return [];\n      }\n    \n      // Only log API calls, not every cache check\n      // Removed debug log to reduce console spam\n    \n      // Check for cached attendance first to avoid unnecessary API calls\n      const cachedAttendance = await databaseService.getAttendance(event.eventid);\n      if (cachedAttendance) {\n      // Check cache age to determine if we should refresh\n        const cacheKey = `viking_attendance_cache_time_${event.eventid}`;\n        const cacheTime = localStorage.getItem(cacheKey);\n        const cacheAge = cacheTime ? Date.now() - parseInt(cacheTime) : Infinity;\n        const maxCacheAge = 60 * 60 * 1000; // 1 hour\n      \n        if (cacheAge < maxCacheAge) {\n        // Use cached data if it's fresh\n          return Array.isArray(cachedAttendance) ? cachedAttendance : (cachedAttendance.items || []);\n        }\n      }\n    \n      // If termid is missing, get it from API\n      let termId = event.termid;\n      if (!termId) {\n        termId = await fetchMostRecentTermId(event.sectionid, token);\n      }\n    \n      if (!termId) {\n        return cachedAttendance || [];\n      }\n    \n      // Get basic attendance data first\n      const sectionSpecificAttendanceData = await getEventAttendance(\n        event.sectionid, \n        event.eventid, \n        termId, \n        token,\n      );\n    \n      if (!sectionSpecificAttendanceData) {\n        if (import.meta.env.DEV) {\n          logger.warn('No section-specific attendance data returned from API', {\n            eventId: event.eventid,\n            eventName: event.name,\n          }, LOG_CATEGORIES.COMPONENT);\n        }\n        return cachedAttendance || [];\n      }\n\n      // For production, limit shared event processing to reduce API calls\n      // Only check for shared events if explicitly enabled or in development\n      const checkForSharedEvents = import.meta.env.DEV || import.meta.env.VITE_ENABLE_SHARED_EVENT_DETECTION === 'true';\n    \n      if (!checkForSharedEvents) {\n      // Save basic attendance data to cache and return it\n        await databaseService.saveAttendance(event.eventid, sectionSpecificAttendanceData);\n        localStorage.setItem(`viking_attendance_cache_time_${event.eventid}`, Date.now().toString());\n        return sectionSpecificAttendanceData;\n      }\n    \n      // Check for shared event only if enabled (reduces API calls significantly)\n      try {\n        const eventSummary = await getEventSummary(event.eventid, token);\n      \n        // Check if this event has sharing information\n        if (eventSummary?.data?.sharing) {\n          if (import.meta.env.DEV) {\n            logger.debug('Event has sharing data', {\n              eventId: event.eventid,\n              isOwner: eventSummary.data.sharing.is_owner,\n            }, LOG_CATEGORIES.COMPONENT);\n          }\n        \n          // If this section is the owner or participant of a shared event\n          if (eventSummary.data.sharing.is_owner || eventSummary.data.sharing.is_owner === false) {\n            try {\n            // Get shared event data with section attendance counts\n              const sharedEventData = await getEventSharingStatus(event.eventid, event.sectionid, token);\n            \n              if (sharedEventData) {\n              // For shared events, create attendance data from section-level counts\n                const sharedAttendanceData = convertSharedEventToAttendanceFormat(sharedEventData);\n              \n                // Combine section-specific and shared data for maximum detail\n                const combinedAttendanceData = [\n                // Include real section-specific data (has No/Invited/NotInvited details)\n                  ...sectionSpecificAttendanceData,\n                  // Include synthetic data for sections we don't have access to\n                  ...sharedAttendanceData.items.filter(item => \n                    item.scoutid && item.scoutid.startsWith('synthetic-'),\n                  ),\n                ];\n              \n                // Save combined attendance data to cache\n                await databaseService.saveAttendance(event.eventid, combinedAttendanceData);\n                localStorage.setItem(`viking_attendance_cache_time_${event.eventid}`, Date.now().toString());\n              \n                // Store shared event metadata separately for event expansion\n                const { isDemoMode } = await import('../../config/demoMode.js');\n                const prefix = isDemoMode() ? 'demo_' : '';\n                const metadata = {\n                  _isSharedEvent: true,\n                  _allSections: sharedEventData.items,\n                  _sourceEvent: event,\n                };\n                localStorage.setItem(`${prefix}viking_shared_metadata_${event.eventid}`, JSON.stringify(metadata));\n              \n                return combinedAttendanceData;\n              }\n            } catch (sharedErr) {\n              if (import.meta.env.DEV) {\n                logger.warn('Failed to fetch shared event data, falling back to section-specific data', {\n                  eventId: event.eventid,\n                  error: sharedErr.message,\n                }, LOG_CATEGORIES.API);\n              }\n            // Fall through to use section-specific data only\n            }\n          }\n        }\n      } catch (summaryErr) {\n        if (import.meta.env.DEV) {\n          logger.warn('Failed to fetch event summary, treating as regular event', {\n            eventId: event.eventid,\n            error: summaryErr.message,\n          }, LOG_CATEGORIES.API);\n        }\n      // Continue to return section-specific data for regular events\n      }\n    \n      // Default: Save section-specific data to cache and return it\n      await databaseService.saveAttendance(event.eventid, sectionSpecificAttendanceData);\n      localStorage.setItem(`viking_attendance_cache_time_${event.eventid}`, Date.now().toString());\n      return sectionSpecificAttendanceData;\n    \n    } catch (err) {\n      logger.error('Error fetching attendance for event {eventId}', { \n        error: err, \n        eventId: event.eventid,\n        eventName: event.name,\n        sectionId: event.sectionid,\n      }, LOG_CATEGORIES.API);\n    \n      // Return cached data as fallback\n      const cachedAttendance = await databaseService.getAttendance(event.eventid);\n      return Array.isArray(cachedAttendance) ? cachedAttendance : (cachedAttendance?.items || []);\n    }\n  };\n\n/**\n * Groups events by their name\n * @param {Array} events - Array of event objects\n * @returns {Map} Map of event names to arrays of events\n */\nexport const /**\n *\n * @param events\n */\n  groupEventsByName = (events) => {\n    const eventGroups = new Map();\n  \n    for (const event of events) {\n      const eventName = event.name;\n      if (!eventGroups.has(eventName)) {\n        eventGroups.set(eventName, []);\n      }\n      eventGroups.get(eventName).push(event);\n    }\n  \n    return eventGroups;\n  };\n\n/**\n * Builds an individual event card from grouped events\n * @param {string} eventName - Name of the event\n * @param {Array} events - Array of events with the same name\n * @returns {object} Event card object\n */\nexport const /**\n *\n * @param eventName\n * @param events\n */\n  buildEventCard = (eventName, events) => {\n  // Sort events within group by date\n    const sorted = [...events].sort((a, b) => new Date(a.startdate) - new Date(b.startdate));\n  \n    // Create card with earliest event date for sorting\n    return {\n      id: `${eventName}-${sorted[0].eventid}`,\n      name: eventName,\n      events: sorted,\n      earliestDate: new Date(sorted[0].startdate),\n      sections: [...new Set(sorted.map(e => e.sectionname))],\n    };\n  };\n\n/**\n * Filters events to include only future events and events from the past week\n * @param {Array} events - Array of event objects\n * @param {Date} oneWeekAgo - Date representing one week ago\n * @returns {Array} Filtered events\n */\nexport const /**\n *\n * @param events\n * @param oneWeekAgo\n */\n  filterEventsByDateRange = (events, oneWeekAgo) => {\n    return events.filter(event => {\n      const eventDate = new Date(event.startdate);\n      return eventDate >= oneWeekAgo;\n    });\n  };\n\n/**\n * Detects if an event is a shared event owner based on attendance data\n * @param {object} attendanceData - Attendance data response from API\n * @returns {boolean} True if this section owns a shared event\n */\nexport const /**\n *\n * @param attendanceData\n */\n  isSharedEventOwner = (attendanceData) => {\n  // Check if the response has sharing info and is_owner is true\n    if (attendanceData && attendanceData.sharing && attendanceData.sharing.is_owner === true) {\n      return true;\n    }\n    return false;\n  };\n\n/**\n * Extracts sections that the user has direct access to from events\n * @param {Array} events - Array of event objects with sectionid  \n * @returns {Set} Set of section IDs the user has access to\n */\nexport const /**\n *\n * @param events\n */\n  getUserAccessibleSections = (events) => {\n    return new Set(events.map(event => event.sectionid));\n  };\n\n/**\n * Converts shared event data from getEventSharingStatus to attendance format for EventCard compatibility\n * @param {object} sharedEventData - Response from getEventSharingStatus API with section-level counts\n * @returns {object} Attendance data compatible with EventCard component\n */\nexport const /**\n *\n * @param sharedEventData\n */\n  convertSharedEventToAttendanceFormat = (sharedEventData) => {\n    try {\n    // Filter out null/empty section entries (these are totals/summaries)\n      const sections = (sharedEventData?.items || []).filter(section => \n        section.sectionid && section.sectionname && \n      section.sectionid !== null && section.sectionid !== 'null' &&\n      section.sectionname !== null && section.sectionname !== 'null',\n      );\n    \n      // Create synthetic attendance records for each section based on their counts\n      const attendanceItems = [];\n      const attendanceSummary = { Yes: 0, No: 0, 'Not invited': 0, total_members: 0 };\n      const sectionsInfo = [];\n    \n      sections.forEach(section => {\n      // Add section info\n        sectionsInfo.push({\n          sectionid: parseInt(section.sectionid),\n          section_name: section.sectionname,\n          member_count: section.attendance || 0,\n          hasDirectAccess: false, // For shared events, access level doesn't matter for display\n          status: section.status, // Owner, Accepted, Pending\n        });\n      \n        // For each attending member, create a synthetic attendance record  \n        for (let i = 0; i < (section.attendance || 0); i++) {\n          attendanceItems.push({\n            scoutid: `synthetic-${section.sectionid}-${i}`,\n            sectionid: section.sectionid,\n            sectionname: section.sectionname,\n            attending: 'Yes',\n            firstname: `Member ${i + 1}`, // Synthetic name for display count\n            lastname: `(${section.sectionname})`,\n            groupname: section.groupname,\n          });\n        }\n      \n        // Add to summary counts\n        attendanceSummary.Yes += section.attendance || 0;\n        attendanceSummary['Not invited'] += section.none || 0;\n        attendanceSummary.total_members += (section.attendance || 0) + (section.none || 0);\n      });\n    \n      if (import.meta.env.DEV) {\n        logger.info('Converted shared event data to attendance format', {\n          totalSections: sections.length,\n          totalAttendees: attendanceSummary.Yes,\n          totalNotInvited: attendanceSummary['Not invited'],\n          sectionsWithAttendance: sections.filter(s => s.attendance > 0).length,\n          attendanceItemsCreated: attendanceItems.length,\n          sectionsInfo: sectionsInfo.map(s => `${s.section_name}: ${s.member_count}`),\n          allSectionsData: sections.map(s => `${s.sectionname} (${s.sectionid}): ${s.attendance || 0} attending`),\n        }, LOG_CATEGORIES.COMPONENT);\n      }\n    \n      return {\n        items: attendanceItems,\n        summary: attendanceSummary,\n        sections: sectionsInfo,\n        sharing: {\n          isSharedEvent: true,\n          hasSharedData: true,\n        },\n      };\n    \n    } catch (error) {\n      logger.error('Error converting shared event data to attendance format', {\n        error: error.message,\n        hasData: !!sharedEventData,\n      }, LOG_CATEGORIES.COMPONENT);\n    \n      // Return empty structure on error\n      return {\n        items: [],\n        summary: { Yes: 0, No: 0, 'Not invited': 0, total_members: 0 },\n        sections: [],\n        sharing: { isSharedEvent: true, hasSharedData: false },\n      };\n    }\n  };\n\n/**\n * Expands shared events to include synthetic events for all participating sections\n * This allows EventCard to display attendance for all sections in shared events\n * @param {Array} events - Original events array (only user-accessible sections)\n * @param {Map} attendanceMap - Map of event IDs to attendance data\n * @returns {Array} Expanded events array including synthetic events for shared event sections\n */\nexport const /**\n *\n * @param events\n * @param attendanceMap\n */\n  expandSharedEvents = (events, attendanceMap) => {\n  // For shared events, we DON'T want to create synthetic events for each section\n  // Instead, we want the EventCard to handle displaying all sections within a single card\n  // So we'll just return the original events array without expansion\n  \n    if (import.meta.env.DEV) {\n      logger.debug('expandSharedEvents called - returning original events to prevent duplicate cards', {\n        eventsCount: events.length,\n        attendanceMapSize: attendanceMap.size,\n        eventNames: events.map(e => e.name).slice(0, 5), // First 5 event names\n      }, LOG_CATEGORIES.COMPONENT);\n    }\n\n    // The shared event data is already combined in the attendance data\n    // EventCard will handle displaying all sections using the combined attendance data\n    return events;\n  };\n\n/**\n * Merges shared event attendance with section-specific attendance data\n * Combines attendee names from shared API with complete counts from section-specific APIs\n * @param {object} sharedAttendanceData - Response from getSharedEventAttendance API\n * @param {Array} sectionSpecificAttendanceData - Array of attendance data from section-specific APIs\n * @param {Set} sectionsToShow - Set of section IDs to include in the output (all shared sections for shared events)\n * @returns {object} Merged attendance data with combined attendees and accurate counts\n */\nexport const /**\n *\n * @param sharedAttendanceData\n * @param sectionSpecificAttendanceData\n * @param sectionsToShow\n */\n  mergeSharedAndSectionAttendance = (sharedAttendanceData, sectionSpecificAttendanceData, sectionsToShow) => {\n    try {\n    // Get shared attendees (all \"Yes\" responses from all sections)\n    // The shared API returns combined attendance in 'items' property\n      const sharedAttendees = sharedAttendanceData?.items || [];\n    \n      // Get section-specific attendees (includes No/Maybe/Not invited for accessible sections)\n      const sectionAttendees = sectionSpecificAttendanceData.flatMap(data => data.items || []);\n    \n      logger.info('Merging attendance data', {\n        sharedCount: sharedAttendees.length,\n        sectionCount: sectionAttendees.length,\n        sectionsToShow: Array.from(sectionsToShow),\n      }, LOG_CATEGORIES.COMPONENT);\n    \n      // Create a map for quick lookup of shared attendees\n      const sharedAttendeesMap = new Map();\n      sharedAttendees.forEach(attendee => {\n      // Shared API uses scoutid, section API might use memberid\n        const id = attendee.scoutid || attendee.memberid;\n        const key = `${id}-${attendee.sectionid}`;\n        sharedAttendeesMap.set(key, attendee);\n      });\n    \n      // Merge logic: start with shared attendees, then add section-specific data that's not already included\n      const mergedAttendees = [...sharedAttendees];\n    \n      // Add section-specific attendees that aren't already in shared data\n      sectionAttendees.forEach(attendee => {\n      // Section API might use different ID field than shared API\n        const id = attendee.scoutid || attendee.memberid;\n        const key = `${id}-${attendee.sectionid}`;\n      \n        // If not already in shared data, add it\n        if (!sharedAttendeesMap.has(key)) {\n          mergedAttendees.push(attendee);\n        }\n      });\n    \n      // Calculate merged summary counts\n      const attendanceCountMap = {};\n      mergedAttendees.forEach(attendee => {\n        const attendance = attendee.attending || 'Unknown';\n        attendanceCountMap[attendance] = (attendanceCountMap[attendance] || 0) + 1;\n      });\n    \n      // Build sections summary from shared data and fill in gaps from section-specific data\n      const sectionsMap = new Map();\n    \n      // Extract sections from shared attendee data (since no separate sections array)\n      sharedAttendees.forEach(attendee => {\n        const sectionId = parseInt(attendee.sectionid);\n        if (!sectionsMap.has(sectionId)) {\n          sectionsMap.set(sectionId, {\n            sectionid: sectionId,\n            section_name: attendee.sectionname,\n            member_count: 0, // Will be calculated below\n            hasDirectAccess: false, // For shared events, we show all sections regardless of access\n          });\n        }\n      });\n    \n      // Count members per section from shared data\n      sharedAttendees.forEach(attendee => {\n        const sectionId = parseInt(attendee.sectionid);\n        if (sectionsMap.has(sectionId)) {\n          sectionsMap.get(sectionId).member_count += 1;\n        }\n      });\n    \n      // Add/update sections from section-specific data\n      sectionSpecificAttendanceData.forEach(data => {\n        if (data.items && data.items.length > 0) {\n          const firstItem = data.items[0];\n          const sectionId = firstItem.sectionid;\n        \n          // For shared events, include all sections that have data\n          if (sectionsToShow.has(sectionId)) {\n            sectionsMap.set(sectionId, {\n              sectionid: sectionId,\n              section_name: firstItem.sectionname,\n              member_count: data.items.length,\n              hasDirectAccess: false, // For shared events, access level doesn't matter for display\n            });\n          }\n        }\n      });\n    \n      const mergedData = {\n        items: mergedAttendees,\n        summary: {\n          total_members: mergedAttendees.length,\n          ...attendanceCountMap,\n        },\n        sections: Array.from(sectionsMap.values()),\n        sharing: {\n          isSharedEvent: true,\n          hasSharedData: true,\n        },\n      };\n    \n      logger.info('Attendance merge completed', {\n        totalAttendees: mergedAttendees.length,\n        sectionsCount: mergedData.sections.length,\n        summaryBreakdown: attendanceCountMap,\n      }, LOG_CATEGORIES.COMPONENT);\n    \n      return mergedData;\n    \n    } catch (error) {\n      logger.error('Error merging shared and section attendance data', {\n        error: error.message,\n        sharedDataAvailable: !!sharedAttendanceData,\n        sectionDataCount: sectionSpecificAttendanceData?.length || 0,\n      }, LOG_CATEGORIES.COMPONENT);\n    \n      // Fallback to section-specific data only\n      return sectionSpecificAttendanceData.flatMap(data => data.items || []);\n    }\n  };","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/flexiRecordTransforms.js","messages":[{"ruleId":"jsdoc/require-returns","severity":2,"message":"Found more than one @returns declaration.","line":457,"column":1,"nodeType":"Block","endLine":565,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file FlexiRecord transformation utilities for Viking Event Management\n * \n * This module provides pure functions for transforming OSM FlexiRecord data into\n * meaningful, structured formats for the Viking Event Management system. Handles\n * field mapping, data transformation, and specialized Viking Event data extraction.\n * \n * FlexiRecords are OSM's flexible record system that allows custom data fields.\n * For Viking Events, these are used to track camp groups, sign-in/out times, and\n * other event-specific data that supplements the standard member information.\n * \n * All functions are pure and focused on data transformation without side effects,\n * following functional programming principles for better testability and reliability.\n * \n * @module flexiRecordTransforms\n * @version 2.3.7\n * @since 2.0.0 - Initial FlexiRecord support\n * @author Vikings Event Management Team\n */\n\nimport { sentryUtils } from '../services/utils/sentry.js';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\n\n/**\n * Parses FlexiRecord structure configuration to create field mapping\n * \n * Converts OSM FlexiRecord structure configuration into a standardized Map\n * that maps generic field IDs (f_1, f_2, etc.) to meaningful field metadata\n * including names, widths, and display properties. This enables transformation\n * of raw FlexiRecord data into human-readable formats.\n * \n * The structure data comes from OSM's getFlexiStructure API and contains both\n * a config JSON string with field definitions and a structure array with\n * additional metadata for each field.\n * \n * @param {object} structureData - Structure data from OSM getFlexiStructure API\n * @param {string} [structureData.config] - JSON string containing field mappings\n * @param {Array} [structureData.structure] - Array of structure sections with field details\n * @param {string} [structureData.extraid] - FlexiRecord type identifier\n * @returns {Map<string, object>} Map of field ID to comprehensive field metadata\n * @throws {Error} If structure data is invalid or parsing fails\n * \n * @example\n * // Parse Viking Event FlexiRecord structure\n * const structureData = {\n *   config: '[{\"id\":\"f_1\",\"name\":\"CampGroup\",\"width\":\"100\"},{\"id\":\"f_2\",\"name\":\"SignedInBy\",\"width\":\"150\"}]',\n *   structure: [\n *     {\n *       rows: [\n *         { field: 'f_1', name: 'CampGroup', width: '100px', editable: true },\n *         { field: 'f_2', name: 'SignedInBy', width: '150px', editable: false }\n *       ]\n *     }\n *   ]\n * };\n * \n * const fieldMapping = parseFlexiStructure(structureData);\n * console.log(fieldMapping.get('f_1')); \n * // Output: { name: 'CampGroup', width: '100px', fieldId: 'f_1', editable: true }\n * \n * @example\n * // Handle multiple structure sections\n * const complexStructure = {\n *   config: '[{\"id\":\"f_1\",\"name\":\"CampGroup\"},{\"id\":\"f_3\",\"name\":\"SignedInWhen\"}]',\n *   structure: [\n *     { rows: [{ field: 'f_1', name: 'Camp Group', formatter: 'number' }] },\n *     { rows: [{ field: 'f_3', name: 'Sign In Time', formatter: 'datetime' }] }\n *   ]\n * };\n * \n * const mapping = parseFlexiStructure(complexStructure);\n * mapping.forEach((fieldInfo, fieldId) => {\n *   console.log(`${fieldId}: ${fieldInfo.name} (${fieldInfo.formatter || 'text'})`);\n * });\n * \n * @example\n * // Error handling for invalid structure\n * try {\n *   const mapping = parseFlexiStructure(null);\n * } catch (error) {\n *   console.error('Structure parsing failed:', error.message);\n *   // Handle gracefully - perhaps show default columns\n * }\n * \n * @since 2.0.0\n */\nexport function parseFlexiStructure(structureData) {\n  try {\n    if (!structureData || typeof structureData !== 'object') {\n      throw new Error('Invalid structure data: must be an object');\n    }\n\n    const fieldMapping = new Map();\n\n    // Parse config JSON if it exists (contains field mappings)\n    if (structureData.config) {\n      try {\n        const configArray = JSON.parse(structureData.config);\n        if (Array.isArray(configArray)) {\n          configArray.forEach(field => {\n            if (field.id && field.name) {\n              fieldMapping.set(field.id, {\n                name: field.name,\n                width: field.width || '150',\n                fieldId: field.id,\n              });\n            }\n          });\n        }\n      } catch (configError) {\n        logger.warn('Failed to parse flexirecord config JSON', {\n          config: structureData.config,\n          error: configError.message,\n        }, LOG_CATEGORIES.APP);\n      }\n    }\n\n    // Also parse structure array for additional metadata\n    if (structureData.structure && Array.isArray(structureData.structure)) {\n      structureData.structure.forEach(section => {\n        if (section.rows && Array.isArray(section.rows)) {\n          section.rows.forEach(row => {\n            if (row.field && row.field.startsWith('f_')) {\n              const existing = fieldMapping.get(row.field) || {};\n              fieldMapping.set(row.field, {\n                ...existing,\n                name: row.name || existing.name,\n                width: row.width || existing.width || '150px',\n                fieldId: row.field,\n                editable: row.editable || false,\n                formatter: row.formatter,\n              });\n            }\n          });\n        }\n      });\n    }\n\n    // Debug logging removed to prevent console spam\n    // Structure parsed successfully with fieldMapping.size fields\n\n    return fieldMapping;\n  } catch (error) {\n    logger.error('Error parsing flexirecord structure', {\n      error: error.message,\n      structureData: structureData,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'parse_flexi_structure',\n      },\n      contexts: {\n        structureData: {\n          hasConfig: !!(structureData && structureData.config),\n          hasStructure: !!(structureData && structureData.structure),\n          extraid: structureData?.extraid,\n        },\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Transforms FlexiRecord data by mapping generic field names to meaningful column names\n * \n * Converts raw OSM FlexiRecord data with generic field identifiers (f_1, f_2, etc.)\n * into structured data with meaningful property names (CampGroup, SignedInBy, etc.).\n * This transformation makes the data much easier to work with in components and\n * provides better type safety and developer experience.\n * \n * The transformation process preserves all original data while adding new properties\n * with meaningful names. Original field references are retained with _original_ prefix\n * for debugging and fallback purposes.\n * \n * @param {object} flexiData - Raw data from OSM getSingleFlexiRecord API\n * @param {Array} flexiData.items - Array of member records with generic field names\n * @param {string} [flexiData.extraid] - FlexiRecord type identifier\n * @param {object} [flexiData.meta] - Metadata about the FlexiRecord\n * @param {Map<string, object>} fieldMapping - Field mapping from parseFlexiStructure\n * @returns {object} Transformed data with meaningful field names and metadata\n * @throws {Error} If data is invalid or transformation fails\n * \n * @example\n * // Transform Viking Event FlexiRecord data\n * const flexiData = {\n *   items: [\n *     {\n *       scoutid: '12345',\n *       firstname: 'Alice',\n *       lastname: 'Smith',\n *       f_1: '3',           // Camp Group\n *       f_2: 'Leader Bob',  // Signed In By\n *       f_3: '2024-07-15 09:30:00' // Signed In When\n *     },\n *     {\n *       scoutid: '67890', \n *       firstname: 'Charlie',\n *       lastname: 'Brown',\n *       f_1: '1',\n *       f_2: 'Leader Alice',\n *       f_3: '2024-07-15 09:45:00'\n *     }\n *   ]\n * };\n * \n * const transformedData = transformFlexiRecordData(flexiData, fieldMapping);\n * \n * // Access data with meaningful names\n * transformedData.items.forEach(scout => {\n *   console.log(`${scout.firstname} is in Camp Group ${scout.CampGroup}`);\n *   console.log(`Signed in by ${scout.SignedInBy} at ${scout.SignedInWhen}`);\n *   \n *   // Original data still available for debugging\n *   console.log(`Original f_1 value: ${scout._original_f_1}`);\n * });\n * \n * @example\n * // Handle missing or invalid data gracefully\n * const incompleteData = {\n *   items: [\n *     { scoutid: '111', firstname: 'Dave', f_1: '2' }, // Missing some fields\n *     { scoutid: '222', firstname: 'Eve' }             // No FlexiRecord data\n *   ]\n * };\n * \n * const result = transformFlexiRecordData(incompleteData, fieldMapping);\n * // Transformation handles missing fields gracefully\n * console.log(result.items[1].CampGroup); // undefined (not an error)\n * \n * @example\n * // Access transformation metadata\n * const transformed = transformFlexiRecordData(flexiData, fieldMapping);\n * console.log(`Transformed ${transformed._metadata.totalItems} items`);\n * console.log(`Used ${transformed._metadata.originalFieldCount} field mappings`);\n * console.log(`Transformation completed at ${transformed._metadata.transformedAt}`);\n * \n * @since 2.0.0\n */\nexport function transformFlexiRecordData(flexiData, fieldMapping) {\n  try {\n    if (!flexiData || typeof flexiData !== 'object') {\n      throw new Error('Invalid flexiData: must be an object');\n    }\n\n    if (!fieldMapping || !(fieldMapping instanceof Map)) {\n      throw new Error('Invalid fieldMapping: must be a Map');\n    }\n\n    if (!flexiData.items || !Array.isArray(flexiData.items)) {\n      logger.warn('FlexiRecord data has no items array', {\n        hasItems: !!flexiData.items,\n        itemsType: typeof flexiData.items,\n      }, LOG_CATEGORIES.APP);\n      \n      return {\n        ...flexiData,\n        items: [],\n        fieldMapping: Object.fromEntries(fieldMapping),\n      };\n    }\n\n    const transformedItems = flexiData.items.map(item => {\n      const transformedItem = { ...item };\n\n      // Transform generic field names to meaningful names\n      fieldMapping.forEach((fieldInfo, fieldId) => {\n        if (Object.prototype.hasOwnProperty.call(item, fieldId)) {\n          const meaningfulName = fieldInfo.name;\n          transformedItem[meaningfulName] = item[fieldId];\n          \n          // Keep original field for reference if needed\n          transformedItem[`_original_${fieldId}`] = item[fieldId];\n        }\n      });\n\n      return transformedItem;\n    });\n\n    const result = {\n      ...flexiData,\n      items: transformedItems,\n      fieldMapping: Object.fromEntries(fieldMapping),\n      _metadata: {\n        originalFieldCount: fieldMapping.size,\n        transformedAt: new Date().toISOString(),\n        totalItems: transformedItems.length,\n      },\n    };\n\n    // FlexiRecord data transformed successfully\n\n    return result;\n  } catch (error) {\n    logger.error('Error transforming flexirecord data', {\n      error: error.message,\n      hasFlexiData: !!flexiData,\n      hasFieldMapping: !!fieldMapping,\n      fieldMappingSize: fieldMapping?.size || 0,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'transform_flexi_record_data',\n      },\n      contexts: {\n        data: {\n          hasItems: !!(flexiData && flexiData.items),\n          itemsCount: flexiData?.items?.length || 0,\n          fieldMappingSize: fieldMapping?.size || 0,\n        },\n      },\n    });\n\n    throw error;\n  }\n}\n\n/**\n * Extracts Viking Event Management specific fields from transformed FlexiRecord data\n * \n * Filters and organizes FlexiRecord data to focus specifically on Viking Event\n * Management fields: CampGroup, SignedInBy, SignedInWhen, SignedOutBy, SignedOutWhen.\n * This creates a clean data structure containing only the core scout information\n * plus Viking Event specific tracking data, perfect for event management interfaces.\n * \n * The function preserves essential scout identification and demographic data while\n * adding the Viking Event Management tracking fields that support camp group\n * organization, attendance tracking, and sign-in/out workflows.\n * \n * @param {object} consolidatedData - Consolidated and transformed FlexiRecord data\n * @param {Array} consolidatedData.items - Array of scout records with transformed field names\n * @param {object} [consolidatedData.fieldMapping] - Field mapping for reference\n * @returns {Array<object>} Array of scout data containing core info plus Viking Event fields\n * \n * @example\n * // Extract Viking Event fields for camp group management\n * const consolidatedData = {\n *   items: [\n *     {\n *       scoutid: '12345',\n *       firstname: 'Alice',\n *       lastname: 'Smith',\n *       dob: '2010-03-15',\n *       age: 14,\n *       patrol: 'Eagles',\n *       patrolid: 'P001',\n *       photo_guid: 'photo123',\n *       CampGroup: '3',\n *       SignedInBy: 'Leader Bob',\n *       SignedInWhen: '2024-07-15 09:30:00',\n *       SignedOutBy: null,\n *       SignedOutWhen: null,\n *       // ... other non-Viking fields excluded\n *     }\n *   ]\n * };\n * \n * const vikingData = extractVikingEventFields(consolidatedData);\n * \n * vikingData.forEach(scout => {\n *   console.log(`${scout.firstname} ${scout.lastname} (Age ${scout.age})`);\n *   console.log(`Camp Group: ${scout.CampGroup || 'Unassigned'}`);\n *   console.log(`Status: ${scout.SignedInWhen ? 'Signed In' : 'Not Arrived'}`);\n *   \n *   if (scout.SignedInWhen) {\n *     console.log(`Signed in by ${scout.SignedInBy} at ${scout.SignedInWhen}`);\n *   }\n *   \n *   if (scout.SignedOutWhen) {\n *     console.log(`Signed out by ${scout.SignedOutBy} at ${scout.SignedOutWhen}`);\n *   }\n * });\n * \n * @example\n * // Generate camp group attendance report\n * const vikingScouts = extractVikingEventFields(transformedData);\n * const campGroups = {};\n * \n * vikingScouts.forEach(scout => {\n *   const group = scout.CampGroup || 'Unassigned';\n *   if (!campGroups[group]) {\n *     campGroups[group] = { signedIn: [], notArrived: [] };\n *   }\n *   \n *   if (scout.SignedInWhen) {\n *     campGroups[group].signedIn.push(scout);\n *   } else {\n *     campGroups[group].notArrived.push(scout);\n *   }\n * });\n * \n * Object.entries(campGroups).forEach(([groupName, members]) => {\n *   console.log(`${groupName}: ${members.signedIn.length} present, ${members.notArrived.length} expected`);\n * });\n * \n * @example\n * // Handle missing or incomplete Viking Event data\n * const partialData = { items: [\n *   { scoutid: '111', firstname: 'Bob' }, // No Viking Event data\n *   { scoutid: '222', firstname: 'Sue', CampGroup: '1' } // Partial data\n * ]};\n * \n * const extracted = extractVikingEventFields(partialData);\n * // Returns scout objects with available fields, undefined for missing ones\n * console.log(extracted[0].CampGroup); // undefined\n * console.log(extracted[1].CampGroup); // '1'\n * \n * @since 2.0.0\n */\nexport function extractVikingEventFields(consolidatedData) {\n  try {\n    if (!consolidatedData || !consolidatedData.items) {\n      return [];\n    }\n\n    const vikingFields = ['CampGroup', 'SignedInBy', 'SignedInWhen', 'SignedOutBy', 'SignedOutWhen'];\n    \n    return consolidatedData.items.map(scout => {\n      const vikingScout = {\n        // Core scout info\n        scoutid: scout.scoutid,\n        firstname: scout.firstname,\n        lastname: scout.lastname,\n        dob: scout.dob,\n        age: scout.age,\n        patrol: scout.patrol,\n        patrolid: scout.patrolid,\n        photo_guid: scout.photo_guid,\n      };\n\n      // Add Viking Event Management fields\n      vikingFields.forEach(field => {\n        if (Object.prototype.hasOwnProperty.call(scout, field)) {\n          vikingScout[field] = scout[field];\n        }\n      });\n\n      return vikingScout;\n    });\n  } catch (error) {\n    logger.error('Error extracting Viking event fields', {\n      error: error.message,\n      hasConsolidatedData: !!consolidatedData,\n    }, LOG_CATEGORIES.ERROR);\n\n    return [];\n  }\n}\n\n// Helper function removed - now using person_type directly from getSummaryStats data\n\n/**\n * Organizes members by their assigned camp groups for Viking Event management\n * \n * Processes member data from getSummaryStats() to create organized camp groups\n * structure. Automatically filters out leaders (who supervise rather than participate\n * in camp groups) and organizes young people by their assigned camp group numbers.\n * \n * This function is essential for the camp group management interface, providing\n * structured data that enables group-based attendance tracking, activity organization,\n * and leadership supervision during Viking Events.\n * \n * The function maintains proper separation between leaders and young people,\n * ensures consistent sorting by name within each group, and provides comprehensive\n * metadata about group organization and Viking Event data availability.\n * \n * @param {Array<object>} processedMembers - Members with attached vikingEventData from getSummaryStats()\n * @param {string} processedMembers[].scoutid - Unique member identifier\n * @param {string} processedMembers[].name - Member full name\n * @param {string} processedMembers[].firstname - Member first name\n * @param {string} processedMembers[].lastname - Member last name\n * @param {string} processedMembers[].person_type - Member type ('Leaders', 'Young Leaders', 'Young People', etc.)\n * @param {object} [processedMembers[].vikingEventData] - Viking Event specific data from FlexiRecord\n * @param {string} [processedMembers[].vikingEventData.CampGroup] - Assigned camp group number\n * @returns {object} Organized camp groups with metadata\n * @returns {object} returns.groups - Camp groups organized by group name\n * @returns {object} returns.summary - Summary statistics and metadata\n * \n * @example\n * // Organize members from getSummaryStats into camp groups\n * const processedMembers = [\n *   {\n *     scoutid: '12345',\n *     name: 'Alice Smith',\n *     firstname: 'Alice',\n *     lastname: 'Smith',\n *     person_type: 'Young People',\n *     vikingEventData: { CampGroup: '3' }\n *   },\n *   {\n *     scoutid: '67890',\n *     name: 'Bob Johnson',\n *     firstname: 'Bob',\n *     lastname: 'Johnson',\n *     person_type: 'Leaders',\n *     vikingEventData: { CampGroup: '1' } // Leaders filtered out\n *   },\n *   {\n *     scoutid: '11111',\n *     name: 'Charlie Brown',\n *     firstname: 'Charlie',\n *     lastname: 'Brown',\n *     person_type: 'Young People',\n *     vikingEventData: { CampGroup: '3' }\n *   }\n * ];\n * \n * const organized = organizeMembersByCampGroups(processedMembers);\n * \n * // Access organized groups\n * console.log('Camp Groups:', Object.keys(organized.groups));\n * // Output: ['Group 3'] (Group 1 not included - only had leaders)\n * \n * organized.groups['Group 3'].youngPeople.forEach(member => {\n *   console.log(`${member.firstname} ${member.lastname} - Group ${member.campGroup}`);\n * });\n * // Output: \n * // Charlie Brown - Group 3\n * // Alice Smith - Group 3 (sorted by lastname)\n * \n * @example\n * // Access summary statistics\n * const result = organizeMembersByCampGroups(members);\n * \n * console.log(`Total Groups: ${result.summary.totalGroups}`);\n * console.log(`Total Young People: ${result.summary.totalYoungPeople}`);\n * console.log(`Has Unassigned: ${result.summary.hasUnassigned}`);\n * console.log(`Viking Data Available: ${result.summary.vikingEventDataAvailable}`);\n * \n * // Check for members without camp group assignments\n * if (result.summary.hasUnassigned) {\n *   const unassigned = result.groups['Group Unassigned'];\n *   console.log(`${unassigned.youngPeople.length} members need group assignment`);\n * }\n * \n * @example\n * // Generate camp group attendance report\n * const campGroupData = organizeMembersByCampGroups(members);\n * \n * Object.entries(campGroupData.groups).forEach(([groupName, group]) => {\n *   console.log(`\\n${groupName} (${group.totalMembers} members):`);\n *   \n *   group.youngPeople.forEach(member => {\n *     const status = member.vikingEventData?.SignedInWhen ? '✓ Present' : '○ Expected';\n *     console.log(`  ${member.firstname} ${member.lastname} - ${status}`);\n *   });\n * });\n * \n * @example\n * // Handle missing Viking Event data gracefully\n * const membersWithoutFlexiData = [\n *   { scoutid: '999', name: 'Dave Wilson', person_type: 'Young People' }\n * ];\n * \n * const result = organizeMembersByCampGroups(membersWithoutFlexiData);\n * // Members without vikingEventData go to 'Group Unassigned'\n * console.log(result.groups['Group Unassigned'].youngPeople.length); // 1\n * \n * @since 2.1.0\n */\nexport function organizeMembersByCampGroups(processedMembers) {\n  try {\n    if (!processedMembers || !Array.isArray(processedMembers)) {\n      logger.warn('Invalid processed members data provided', {\n        hasProcessedMembers: !!processedMembers,\n        isArray: Array.isArray(processedMembers),\n      }, LOG_CATEGORIES.APP);\n      \n      return { groups: {}, summary: { totalGroups: 0, totalMembers: 0 } };\n    }\n\n    logger.debug('Organizing members by camp groups', {\n      totalProcessedMembers: processedMembers.length,\n    }, LOG_CATEGORIES.APP);\n\n    const groups = {};\n    let processedCount = 0;\n    let allHaveVikingEventData = true;\n\n    // Process each member (they already have vikingEventData from getSummaryStats)\n    processedMembers.forEach(member => {\n      // Skip if no member data\n      if (!member) {\n        return;\n      }\n\n      // Filter out Leaders and Young Leaders using person_type from getSummaryStats\n      if (member.person_type === 'Leaders' || member.person_type === 'Young Leaders') {\n        logger.debug('Skipping leader from camp groups', {\n          scoutid: member.scoutid,\n          name: member.name,\n          personType: member.person_type,\n        }, LOG_CATEGORIES.APP);\n        return;\n      }\n\n      // Get camp group assignment - getSummaryStats attaches vikingEventData\n      const campGroupNumber = member.vikingEventData?.CampGroup;\n      const groupName = campGroupNumber ? `Group ${campGroupNumber}` : 'Group Unassigned';\n\n      // Initialize group if it doesn't exist\n      if (!groups[groupName]) {\n        groups[groupName] = {\n          name: groupName,\n          number: Number.isFinite(Number(campGroupNumber)) ? Number(campGroupNumber) : null,\n          leaders: [], // Keep empty - no leaders in camp groups\n          youngPeople: [],\n          totalMembers: 0,\n        };\n      }\n\n      // Add member to the appropriate group (leaders filtered out above)  \n      const memberWithGroup = {\n        ...member,\n        campGroup: campGroupNumber,\n        groupName: groupName,\n      };\n      \n      // Debug member name issue - log to Sentry\n      if (processedCount < 2) {\n        logger.info(`organizeMembersByCampGroups DEBUG: Processing member ${processedCount}. Original name: \"${member.name}\", After transform: \"${memberWithGroup.name}\", Name preserved: ${member.name === memberWithGroup.name}`, {\n          originalName: member.name,\n          transformedName: memberWithGroup.name,\n          namePreserved: member.name === memberWithGroup.name,\n          memberKeys: Object.keys(member).join(', '),\n        }, LOG_CATEGORIES.APP);\n      }\n      \n      groups[groupName].youngPeople.push(memberWithGroup);\n      groups[groupName].totalMembers++;\n      \n      // Track viking event data availability\n      allHaveVikingEventData &&= !!member.vikingEventData;\n      \n      processedCount++;\n    });\n\n    // Sort groups by number (Unassigned goes last)\n    const sortedGroupNames = Object.keys(groups).sort((a, b) => {\n      if (a === 'Group Unassigned') return 1;\n      if (b === 'Group Unassigned') return -1;\n      \n      const aNum = parseInt(a.replace('Group ', ''));\n      const bNum = parseInt(b.replace('Group ', ''));\n      return aNum - bNum;\n    });\n\n    // Create sorted groups object\n    const sortedGroups = {};\n    sortedGroupNames.forEach(groupName => {\n      const group = groups[groupName];\n      \n      // Sort members within each group by lastname, firstname\n      group.leaders.sort((a, b) => {\n        const aName = `${a.lastname || ''} ${a.firstname || ''}`.trim();\n        const bName = `${b.lastname || ''} ${b.firstname || ''}`.trim();\n        return aName.localeCompare(bName);\n      });\n      \n      group.youngPeople.sort((a, b) => {\n        const aName = `${a.lastname || ''} ${a.firstname || ''}`.trim();\n        const bName = `${b.lastname || ''} ${b.firstname || ''}`.trim();\n        return aName.localeCompare(bName);\n      });\n      \n      sortedGroups[groupName] = group;\n    });\n\n    const summary = {\n      totalGroups: Object.keys(sortedGroups).length,\n      totalMembers: processedCount,\n      totalLeaders: Object.values(sortedGroups).reduce((sum, group) => sum + group.leaders.length, 0),\n      totalYoungPeople: Object.values(sortedGroups).reduce((sum, group) => sum + group.youngPeople.length, 0),\n      hasUnassigned: !!sortedGroups['Group Unassigned'],\n      vikingEventDataAvailable: allHaveVikingEventData, // Derived from actual member data\n    };\n\n    logger.debug('Successfully organized members by camp groups', {\n      totalGroups: summary.totalGroups,\n      totalMembers: summary.totalMembers,\n      totalLeaders: summary.totalLeaders,\n      totalYoungPeople: summary.totalYoungPeople,\n      hasUnassigned: summary.hasUnassigned,\n      groupNames: Object.keys(sortedGroups),\n    }, LOG_CATEGORIES.APP);\n\n    return {\n      groups: sortedGroups,\n      summary,\n    };\n  } catch (error) {\n    logger.error('Error organizing members by camp groups', {\n      error: error.message,\n      hasProcessedMembers: !!processedMembers,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'organize_members_by_camp_groups',\n      },\n      contexts: {\n        data: {\n          processedMembersCount: processedMembers?.length || 0,\n        },\n      },\n    });\n\n    // Return empty structure on error\n    return { groups: {}, summary: { totalGroups: 0, totalMembers: 0 } };\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/medicalDataUtils.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":57,"column":1,"nodeType":"Block","endLine":60,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":57,"column":1,"nodeType":"Block","endLine":60,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"dateString\" description.","line":59,"column":1,"nodeType":"Block","endLine":59,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":75,"column":1,"nodeType":"Block","endLine":79,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":75,"column":1,"nodeType":"Block","endLine":79,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"value\" description.","line":77,"column":1,"nodeType":"Block","endLine":77,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"fieldName\" description.","line":78,"column":1,"nodeType":"Block","endLine":78,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":143,"column":1,"nodeType":"Block","endLine":147,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":143,"column":1,"nodeType":"Block","endLine":147,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"value\" description.","line":145,"column":1,"nodeType":"Block","endLine":145,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"fieldName\" description.","line":146,"column":1,"nodeType":"Block","endLine":146,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":153,"column":1,"nodeType":"Block","endLine":157,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":153,"column":1,"nodeType":"Block","endLine":157,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"value\" description.","line":155,"column":1,"nodeType":"Block","endLine":155,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"fieldName\" description.","line":156,"column":1,"nodeType":"Block","endLine":156,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":212,"column":1,"nodeType":"Block","endLine":215,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":212,"column":1,"nodeType":"Block","endLine":215,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"member\" description.","line":214,"column":1,"nodeType":"Block","endLine":214,"endColumn":1}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const MEDICAL_DATA_STATES = {\n  MISSING: 'missing',\n  CONFIRMED_NONE: 'confirmed_none', \n  SYSTEM_DEFAULT: 'system_default',\n  HAS_DATA: 'has_data',\n};\n\nexport const MEDICAL_DATA_INDICATORS = {\n  [MEDICAL_DATA_STATES.MISSING]: {\n    color: 'text-gray-900',\n    showPill: true,\n    pillColor: 'bg-scout-yellow text-gray-900',\n    icon: '⚠️',\n    label: '---',\n    csvValue: '---',\n    description: 'Information needs to be collected',\n  },\n  [MEDICAL_DATA_STATES.CONFIRMED_NONE]: {\n    color: 'text-gray-700', \n    showPill: false,\n    pillColor: '',\n    icon: '',\n    label: 'None',\n    csvValue: 'None',\n    description: 'Confirmed no medical requirements',\n  },\n  [MEDICAL_DATA_STATES.SYSTEM_DEFAULT]: {\n    color: 'text-gray-900',\n    showPill: true,\n    pillColor: 'bg-scout-yellow text-gray-900', \n    icon: '⚠️',\n    label: '---',\n    csvValue: '---',\n    description: 'Information needs to be collected',\n  },\n  [MEDICAL_DATA_STATES.HAS_DATA]: {\n    color: 'text-gray-900',\n    showPill: true,\n    pillColor: 'bg-scout-red text-white',\n    icon: '●',\n    label: '',\n    csvValue: '', // Use actual value\n    description: 'Medical information present - review carefully',\n  },\n};\n\nconst NONE_VARIATIONS = [\n  'none', 'nil', 'nothing',\n  // Keep phrases for documentation parity; detection handled by regexes\n  'not required', 'no allergies', 'no medical issues', 'no dietary requirements',\n];\n\nconst SYSTEM_DEFAULTS = [\n  'n/a', 'not applicable', 'default', 'system',\n];\n\n/**\n *\n * @param dateString\n */\nfunction isDateOverOneYearOld(dateString) {\n  if (!dateString || typeof dateString !== 'string') return false;\n  \n  // Extract date from start of string (format like \"2025-08-26 12:24:57:Simon Clark\")\n  const dateMatch = dateString.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n  if (!dateMatch) return false;\n  \n  const confirmDate = new Date(dateMatch[1]);\n  const oneYearAgo = new Date();\n  oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n  \n  return confirmDate < oneYearAgo;\n}\n\n/**\n *\n * @param value\n * @param fieldName\n */\nexport function categorizeMedicalData(value, fieldName = '') {\n  // Special handling for non-medical fields that shouldn't be colored\n  const nonMedicalFields = ['tetanus_year_of_last_jab', 'other_useful_information'];\n  if (nonMedicalFields.includes(fieldName.toLowerCase())) {\n    // These fields show data without coloring (just plain text)\n    if (!value || value === null || value === undefined || String(value).trim() === '') {\n      return MEDICAL_DATA_STATES.MISSING; // Will show yellow \"---\"\n    }\n    return MEDICAL_DATA_STATES.CONFIRMED_NONE; // Will show plain text without pill\n  }\n  \n  // Special handling for swimmer field - treat as safety indicator\n  if (fieldName.toLowerCase() === 'swimmer') {\n    if (!value || value === null || value === undefined || String(value).trim() === '') {\n      return MEDICAL_DATA_STATES.MISSING; // Yellow \"---\" for missing swimming ability\n    }\n    \n    const normalizedValue = String(value).toLowerCase().trim();\n    if (normalizedValue === 'yes') {\n      return MEDICAL_DATA_STATES.CONFIRMED_NONE; // No color for \"Yes\" - good swimming ability\n    }\n    if (normalizedValue === 'no') {\n      return MEDICAL_DATA_STATES.HAS_DATA; // Red for \"No\" - cannot swim, safety concern\n    }\n    \n    return MEDICAL_DATA_STATES.CONFIRMED_NONE; // Default to no color for other values\n  }\n  \n  // Special handling for confirmed_by_parents - check date age\n  if (fieldName.toLowerCase() === 'confirmed_by_parents') {\n    if (!value || value === null || value === undefined || String(value).trim() === '') {\n      return MEDICAL_DATA_STATES.MISSING; // Yellow \"---\"\n    }\n    \n    if (isDateOverOneYearOld(String(value))) {\n      return MEDICAL_DATA_STATES.HAS_DATA; // Red - confirmation is over a year old\n    }\n    \n    return MEDICAL_DATA_STATES.CONFIRMED_NONE; // No color - recent confirmation\n  }\n  \n  // Standard medical field handling (allergies, medical_details, dietary_requirements)\n  if (!value || value === null || value === undefined) {\n    return MEDICAL_DATA_STATES.MISSING;\n  }\n\n  const normalizedValue = String(value).toLowerCase().trim();\n  \n  if (normalizedValue === '') {\n    return MEDICAL_DATA_STATES.MISSING;\n  }\n\n  if (SYSTEM_DEFAULTS.some(defaultVal => normalizedValue === defaultVal)) {\n    return MEDICAL_DATA_STATES.SYSTEM_DEFAULT;\n  }\n\n  if (NONE_VARIATIONS.some(noneVal => normalizedValue.includes(noneVal))) {\n    return MEDICAL_DATA_STATES.CONFIRMED_NONE;\n  }\n\n  return MEDICAL_DATA_STATES.HAS_DATA;\n}\n\n/**\n *\n * @param value\n * @param fieldName\n */\nexport function getMedicalDataIndicator(value, fieldName = '') {\n  const state = categorizeMedicalData(value, fieldName);\n  return MEDICAL_DATA_INDICATORS[state];\n}\n\n/**\n *\n * @param value\n * @param fieldName\n */\nexport function formatMedicalDataForDisplay(value, fieldName = '') {\n  const indicator = getMedicalDataIndicator(value, fieldName);\n  const state = categorizeMedicalData(value, fieldName);\n  \n  if (state === MEDICAL_DATA_STATES.MISSING || state === MEDICAL_DATA_STATES.SYSTEM_DEFAULT) {\n    return {\n      display: '---',\n      value: '',\n      indicator,\n      csvValue: '---',\n    };\n  }\n\n  if (state === MEDICAL_DATA_STATES.CONFIRMED_NONE) {\n    // For non-medical fields like swimmer, show actual value instead of \"None\"\n    const nonMedicalFields = ['tetanus_year_of_last_jab', 'other_useful_information', 'swimmer', 'confirmed_by_parents'];\n    const actualValue = Array.isArray(value)\n      ? value.filter(Boolean).join('; ')\n      : (value ?? '').toString().trim();\n    \n    if (nonMedicalFields.includes(fieldName.toLowerCase()) && actualValue) {\n      return {\n        display: actualValue,\n        value: actualValue,\n        indicator,\n        csvValue: actualValue,\n      };\n    }\n    \n    // For actual medical fields, show \"None\" when confirmed as no issues\n    return {\n      display: 'None',\n      value: 'None',\n      indicator,\n      csvValue: 'None',\n    };\n  }\n\n  // HAS_DATA - show actual value\n  return {\n    // Join arrays; coerce other types; trim for cleanliness\n    display: Array.isArray(value)\n      ? value.filter(Boolean).join('; ')\n      : (value ?? '').toString().trim(),\n    value: Array.isArray(value)\n      ? value.filter(Boolean).join('; ')\n      : (value ?? '').toString().trim(),\n    indicator,\n    csvValue: Array.isArray(value)\n      ? value.filter(Boolean).join(', ')\n      : (value ?? '').toString().trim(),\n  };\n}\n\n/**\n *\n * @param member\n */\nexport function getMedicalFieldsFromMember(member) {\n  const fields = {\n    allergies: member.allergies || \n               member.essential_information?.allergies || \n               member.essential_information__allergies || '',\n    medical_details: member.medical_details || \n                    member.essential_information?.medical_details || \n                    member.essential_information__medical_details || \n                    member.medical_notes || '',\n    dietary_requirements: member.dietary_requirements || \n                         member.essential_information?.dietary_requirements || \n                         member.essential_information__dietary_requirements || '',\n    emergency_contacts: member.emergency_contacts || [],\n  };\n\n  return Object.entries(fields).reduce((acc, [key, value]) => {\n    acc[key] = formatMedicalDataForDisplay(value, key);\n    return acc;\n  }, {});\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/networkUtils.js","messages":[{"ruleId":"jsdoc/check-param-names","severity":2,"message":"@param \"status\" does not match an existing function parameter.","line":164,"column":1,"nodeType":"Block","endLine":164,"endColumn":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Network Utility Functions\n * \n * Cross-platform network detection and monitoring utilities for Vikings Event Management Mobile.\n * Provides consistent network status checking across web and native mobile platforms using\n * Capacitor Network plugin for native and browser APIs for web environments.\n * \n * Features:\n * - Cross-platform network status detection\n * - Detailed network information (connection type, speed, WiFi details)\n * - Network change monitoring with event listeners\n * - Comprehensive error handling and Sentry integration\n * - Support for both online/offline detection and quality assessment\n * \n * @module networkUtils\n * @version 2.3.7\n * @since 2.3.7\n * @author Vikings Event Management Team\n */\n\nimport { Capacitor } from '@capacitor/core';\nimport { Network } from '@capacitor/network';\nimport { sentryUtils } from '../services/utils/sentry.js';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\n\n/**\n * Check current network status across platforms with error handling\n * Works on both web browsers and native mobile platforms (iOS/Android)\n * \n * @returns {Promise<boolean>} True if network is available, false if offline\n * @throws {Error} If network status cannot be determined\n * \n * @example\n * // Check network before making API calls\n * const isOnline = await checkNetworkStatus();\n * if (isOnline) {\n *   await fetchDataFromAPI();\n * } else {\n *   loadFromCache();\n * }\n */\nexport async function checkNetworkStatus() {\n  try {\n    if (Capacitor.isNativePlatform()) {\n      // Native platform - use Capacitor Network plugin\n      const status = await Network.getStatus();\n      \n      // Only log when network status changes (not every check)\n      \n      return status.connected;\n    } else {\n      // Web browser - use navigator.onLine\n      const isOnline = navigator.onLine;\n      \n      // Only log network changes, not routine checks\n      \n      return isOnline;\n    }\n  } catch (error) {\n    // Log network check failure\n    logger.error('Failed to check network status', {\n      platform: Capacitor.isNativePlatform() ? 'native' : 'web',\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    // Capture exception with Sentry\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'network_status_check',\n        platform: Capacitor.isNativePlatform() ? 'native' : 'web',\n      },\n      contexts: {\n        device: {\n          platform: Capacitor.getPlatform(),\n          isNative: Capacitor.isNativePlatform(),\n        },\n      },\n    });\n\n    // Rethrow to allow caller to handle\n    throw new Error(`Network status check failed: ${error.message}`);\n  }\n}\n\n/**\n * Get detailed network information with connection type and speed details\n * Provides enhanced network information for native platforms, basic info for web\n * \n * @returns {Promise<NetworkStatus>} Network status object with detailed information\n * @throws {Error} If network information cannot be retrieved\n * \n * @typedef {object} NetworkStatus\n * @property {boolean} connected - Whether device is connected to network\n * @property {string} connectionType - Type of connection ('wifi', 'cellular', 'ethernet', 'unknown')\n * @property {string} [ssid] - WiFi network name (native only, if available)\n * @property {string} [bssid] - WiFi network BSSID (native only, if available)\n * \n * @example\n * // Get detailed network info for connection quality decisions\n * const networkInfo = await getDetailedNetworkStatus();\n * if (networkInfo.connected && networkInfo.connectionType === 'wifi') {\n *   // High-quality connection - fetch full resolution images\n *   await loadHighResImages();\n * } else if (networkInfo.connected && networkInfo.connectionType === 'cellular') {\n *   // Mobile connection - optimize for data usage\n *   await loadOptimizedContent();\n * }\n */\nexport async function getDetailedNetworkStatus() {\n  try {\n    if (Capacitor.isNativePlatform()) {\n      // Native platform - get detailed network information\n      const status = await Network.getStatus();\n      \n      // Network status retrieved - routine operation\n      \n      return status;\n    } else {\n      // Web browser - limited information available\n      const networkInfo = {\n        connected: navigator.onLine,\n        connectionType: 'unknown',\n      };\n      \n      // Try to get connection info if available (experimental)\n      if (navigator.connection) {\n        networkInfo.connectionType = navigator.connection.effectiveType || 'unknown';\n        networkInfo.downlink = navigator.connection.downlink;\n        networkInfo.effectiveType = navigator.connection.effectiveType;\n      }\n      \n      // Network status retrieved - routine operation\n      \n      return networkInfo;\n    }\n  } catch (error) {\n    logger.error('Failed to get detailed network status', {\n      platform: Capacitor.isNativePlatform() ? 'native' : 'web',\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'detailed_network_status',\n        platform: Capacitor.isNativePlatform() ? 'native' : 'web',\n      },\n    });\n\n    throw new Error(`Failed to get network details: ${error.message}`);\n  }\n}\n\n/**\n * Add network status change listener with error handling\n * Sets up monitoring for network connectivity changes across platforms\n * \n * @param {NetworkChangeCallback} callback - Function to call when network status changes\n * @returns {Function} Cleanup function to remove the listener\n * @throws {Error} If listener setup fails\n * \n * @callback NetworkChangeCallback\n * @param {NetworkStatus} status - Network status object containing connection info\n * \n * @example\n * // Monitor network changes and update UI\n * const removeListener = addNetworkListener((status) => {\n *   if (status.connected) {\n *     console.log('Back online!');\n *     syncPendingData();\n *   } else {\n *     console.log('Gone offline');\n *     showOfflineIndicator();\n *   }\n * });\n * \n * // Later, clean up the listener\n * removeListener();\n */\nexport function addNetworkListener(callback) {\n  if (typeof callback !== 'function') {\n    const error = new Error('Network listener callback must be a function');\n    \n    logger.error('Invalid network listener callback', {\n      providedType: typeof callback,\n      isFunction: typeof callback === 'function',\n    }, LOG_CATEGORIES.ERROR);\n    \n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'network_listener_setup',\n        validation_error: true,\n      },\n    });\n    \n    throw error;\n  }\n\n  try {\n    if (Capacitor.isNativePlatform()) {\n      // Native platform - use Capacitor Network plugin\n      // Setting up native network listener\n      \n      const listener = Network.addListener('networkStatusChange', (status) => {\n        // Network status changed - callback will handle\n        \n        callback(status);\n      });\n      \n      return () => {\n        // Removing network listener\n        listener.remove();\n      };\n    } else {\n      // Web browser - use native browser events\n      // Setting up web network listeners\n      \n      const onlineHandler = () => {\n        const status = { connected: true, connectionType: 'unknown' };\n        \n        // Network came online - callback will handle\n        callback(status);\n      };\n      \n      const offlineHandler = () => {\n        const status = { connected: false, connectionType: 'unknown' };\n        \n        // Network went offline - callback will handle\n        callback(status);\n      };\n      \n      window.addEventListener('online', onlineHandler);\n      window.addEventListener('offline', offlineHandler);\n      \n      return () => {\n        // Removing web network listeners\n        window.removeEventListener('online', onlineHandler);\n        window.removeEventListener('offline', offlineHandler);\n      };\n    }\n  } catch (error) {\n    logger.error('Failed to setup network listener', {\n      platform: Capacitor.isNativePlatform() ? 'native' : 'web',\n      error: error.message,\n      stack: error.stack,\n    }, LOG_CATEGORIES.ERROR);\n\n    sentryUtils.captureException(error, {\n      tags: {\n        operation: 'network_listener_setup',\n        platform: Capacitor.isNativePlatform() ? 'native' : 'web',\n      },\n    });\n\n    throw new Error(`Failed to setup network listener: ${error.message}`);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/notifications.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":87,"column":14,"nodeType":"Block","endLine":90,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":87,"column":14,"nodeType":"Block","endLine":90,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":89,"column":1,"nodeType":"Block","endLine":89,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":155,"column":14,"nodeType":"Block","endLine":159,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":155,"column":14,"nodeType":"Block","endLine":159,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":157,"column":1,"nodeType":"Block","endLine":157,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"error\" description.","line":158,"column":1,"nodeType":"Block","endLine":158,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":225,"column":14,"nodeType":"Block","endLine":228,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":225,"column":14,"nodeType":"Block","endLine":228,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":227,"column":1,"nodeType":"Block","endLine":227,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":280,"column":14,"nodeType":"Block","endLine":283,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":280,"column":14,"nodeType":"Block","endLine":283,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":282,"column":1,"nodeType":"Block","endLine":282,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":357,"column":14,"nodeType":"Block","endLine":360,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":357,"column":14,"nodeType":"Block","endLine":360,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"message\" description.","line":359,"column":1,"nodeType":"Block","endLine":359,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":447,"column":14,"nodeType":"Block","endLine":451,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":447,"column":14,"nodeType":"Block","endLine":451,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"promise\" description.","line":449,"column":1,"nodeType":"Block","endLine":449,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"messages\" description.","line":450,"column":1,"nodeType":"Block","endLine":450,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":536,"column":14,"nodeType":"Block","endLine":539,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"toastId\" description.","line":538,"column":1,"nodeType":"Block","endLine":538,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":588,"column":14,"nodeType":"Block","endLine":590,"endColumn":4}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Scout-themed notification utilities using react-hot-toast\n * \n * This module provides notification functions with Scout color theming and\n * consistent styling across the application. Replaces the previous complex\n * notification system as part of the codebase simplification (Tasks 31-34).\n * \n * All notifications use Scout brand colors and are positioned top-right with\n * consistent styling, duration, and accessibility features.\n * \n * @module notifications\n * @version 2.3.7\n * @since 2.3.7 - Created during notification system simplification\n * @author Vikings Event Management Team\n */\n\nimport { toast } from 'react-hot-toast';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\n\n// Scout theme colors matching Tailwind CSS configuration\nconst SCOUT_COLORS = {\n  blue: '#1e40af',      // scout-blue\n  green: '#16a34a',     // scout-green  \n  red: '#dc2626',       // scout-red\n  amber: '#d97706',     // amber-600 for warning\n  white: '#ffffff',\n  gray: '#6b7280',      // gray-500\n};\n\n// Default toast options with scout theme styling\nconst defaultToastOptions = {\n  duration: 4000,\n  position: 'top-right',\n  style: {\n    background: SCOUT_COLORS.white,\n    border: '1px solid #e5e7eb',\n    borderRadius: '8px',\n    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',\n    fontSize: '14px',\n    fontWeight: '500',\n    padding: '12px 16px',\n    maxWidth: '400px',\n  },\n  // Custom icon styles\n  iconTheme: {\n    primary: SCOUT_COLORS.white,\n    secondary: SCOUT_COLORS.gray,\n  },\n};\n\n/**\n * Displays a success notification with Scout green theme\n * \n * Shows a success toast notification with Scout brand green color theming.\n * Automatically positioned top-right with 4-second duration. Use for positive\n * user actions like saving data, successful uploads, or completed operations.\n * \n * @param {string} message - Success message to display to the user\n * @returns {string} Toast ID that can be used to dismiss the notification manually\n * \n * @example\n * // Basic success notification\n * notifySuccess('Event saved successfully!');\n * \n * @example\n * // Store toast ID for conditional dismissal\n * const toastId = notifySuccess('Upload complete');\n * // Later dismiss if needed\n * if (needToCancel) {\n *   dismissToast(toastId);\n * }\n * \n * @example\n * // Typical usage in form submission\n * const handleSave = async () => {\n *   try {\n *     await saveEvent(eventData);\n *     notifySuccess('Scout event created successfully!');\n *     navigate('/events');\n *   } catch (error) {\n *     notifyError('Failed to save event', error);\n *   }\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param message\n */\n  notifySuccess = (message) => {\n    return toast.success(message, {\n      ...defaultToastOptions,\n      style: {\n        ...defaultToastOptions.style,\n        borderLeft: `4px solid ${SCOUT_COLORS.green}`,\n      },\n      iconTheme: {\n        primary: SCOUT_COLORS.green,\n        secondary: SCOUT_COLORS.white,\n      },\n    });\n  };\n\n/**\n * Displays an error notification with Scout red theme and extended duration\n * \n * Shows an error toast notification with Scout brand red color theming.\n * Has extended 6-second duration for better error visibility. Automatically\n * logs error details to the logger service and Sentry for debugging.\n * \n * @param {string} message - Error message to display to the user\n * @param {Error} [error=null] - Optional Error object for detailed logging\n * @returns {string} Toast ID that can be used to dismiss the notification manually\n * \n * @example\n * // Basic error notification\n * notifyError('Failed to load scout members');\n * \n * @example\n * // Error with detailed logging\n * try {\n *   await loadMembers();\n * } catch (error) {\n *   notifyError('Unable to sync member data', error);\n * }\n * \n * @example\n * // API error handling with user-friendly message\n * const handleAPIError = (apiError) => {\n *   const userMessage = apiError.status === 403 \n *     ? 'Access denied. Please check your permissions.'\n *     : 'Network error. Please try again.';\n *   notifyError(userMessage, apiError);\n * };\n * \n * @example\n * // Offline error handling\n * const loadData = async () => {\n *   try {\n *     const data = await fetchFromAPI('events');\n *     return data;\n *   } catch (error) {\n *     if (!navigator.onLine) {\n *       notifyError('No internet connection. Showing cached data.', error);\n *     } else {\n *       notifyError('Failed to load events from server', error);\n *     }\n *     throw error;\n *   }\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param message\n * @param error\n */\n  notifyError = (message, error = null) => {\n  // Log error to logger service for debugging and Sentry\n    if (error) {\n      logger.error('Toast notification error', { \n        message, \n        error: {\n          message: error.message,\n          stack: error.stack,\n          name: error.name,\n        },\n      }, LOG_CATEGORIES.ERROR);\n    } else {\n      logger.error('Toast notification error', { message }, LOG_CATEGORIES.ERROR);\n    }\n\n    return toast.error(message, {\n      ...defaultToastOptions,\n      duration: 6000, // Extended duration for errors\n      style: {\n        ...defaultToastOptions.style,\n        borderLeft: `4px solid ${SCOUT_COLORS.red}`,\n      },\n      iconTheme: {\n        primary: SCOUT_COLORS.red,\n        secondary: SCOUT_COLORS.white,\n      },\n    });\n  };\n\n/**\n * Displays a warning notification with amber theme\n * \n * Shows a warning toast notification with amber color theming and warning icon.\n * Use for situations that need user attention but aren't errors - like validation\n * warnings, permission notices, or data conflicts that need user input.\n * \n * @param {string} message - Warning message to display to the user\n * @returns {string} Toast ID that can be used to dismiss the notification manually\n * \n * @example\n * // Basic warning notification\n * notifyWarning('Some members have incomplete badge records');\n * \n * @example\n * // Validation warning\n * const validateEventDate = (date) => {\n *   if (new Date(date) < new Date()) {\n *     notifyWarning('Event date is in the past. Please verify.');\n *     return false;\n *   }\n *   return true;\n * };\n * \n * @example\n * // Permission warning\n * const checkPermissions = (userRole, action) => {\n *   if (userRole === 'viewer' && action === 'edit') {\n *     notifyWarning('You have view-only access. Contact your section leader for edit permissions.');\n *     return false;\n *   }\n *   return true;\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param message\n */\n  notifyWarning = (message) => {\n    return toast(message, {\n      ...defaultToastOptions,\n      icon: '⚠️',\n      style: {\n        ...defaultToastOptions.style,\n        borderLeft: `4px solid ${SCOUT_COLORS.amber}`,\n      },\n    });\n  };\n\n/**\n * Displays an informational notification with Scout blue theme\n * \n * Shows an info toast notification with Scout brand blue color theming and info icon.\n * Use for helpful information, tips, or non-critical updates that enhance user\n * understanding without requiring immediate action.\n * \n * @param {string} message - Informational message to display to the user\n * @returns {string} Toast ID that can be used to dismiss the notification manually\n * \n * @example\n * // Basic info notification\n * notifyInfo('Data automatically synced from OSM');\n * \n * @example\n * // Feature tip notification\n * const showTip = () => {\n *   notifyInfo('Tip: Use the filter to find members by section or badge progress');\n * };\n * \n * @example\n * // Status update notification\n * const handleDataSync = () => {\n *   notifyInfo('Showing cached data while offline');\n *   // Load cached data\n * };\n * \n * @example\n * // Help context notification\n * const showHelp = (context) => {\n *   const helpMessages = {\n *     badges: 'Badge progress is updated weekly from OSM',\n *     events: 'Events show attendance status and remaining spaces',\n *     members: 'Member data includes contact details and medical info'\n *   };\n *   notifyInfo(helpMessages[context]);\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param message\n */\n  notifyInfo = (message) => {\n    return toast(message, {\n      ...defaultToastOptions,\n      icon: 'ℹ️',\n      style: {\n        ...defaultToastOptions.style,\n        borderLeft: `4px solid ${SCOUT_COLORS.blue}`,\n      },\n    });\n  };\n\n/**\n * Displays a loading notification for async operations\n * \n * Shows a loading toast notification with Scout blue theme and spinner icon.\n * Use for long-running operations to indicate progress. The notification persists\n * until manually dismissed, typically when the operation completes or fails.\n * \n * @param {string} message - Loading message to display to the user\n * @returns {string} Toast ID that MUST be used to dismiss when operation completes\n * \n * @example\n * // Basic loading notification\n * const loadingId = notifyLoading('Syncing member data...');\n * try {\n *   await syncMembers();\n *   dismissToast(loadingId);\n *   notifySuccess('Member data synced successfully');\n * } catch (error) {\n *   dismissToast(loadingId);\n *   notifyError('Failed to sync member data', error);\n * }\n * \n * @example\n * // File upload with progress\n * const uploadBadgePhotos = async (files) => {\n *   const loadingId = notifyLoading(`Uploading ${files.length} badge photos...`);\n *   \n *   try {\n *     for (const file of files) {\n *       await uploadFile(file);\n *     }\n *     dismissToast(loadingId);\n *     notifySuccess('All badge photos uploaded successfully');\n *   } catch (error) {\n *     dismissToast(loadingId);\n *     notifyError('Some uploads failed', error);\n *   }\n * };\n * \n * @example\n * // API call with timeout\n * const fetchWithLoading = async (apiCall, message) => {\n *   const loadingId = notifyLoading(message);\n *   const timeoutId = setTimeout(() => {\n *     dismissToast(loadingId);\n *     notifyWarning('Operation is taking longer than expected...');\n *   }, 10000);\n *   \n *   try {\n *     const result = await apiCall();\n *     clearTimeout(timeoutId);\n *     dismissToast(loadingId);\n *     return result;\n *   } catch (error) {\n *     clearTimeout(timeoutId);\n *     dismissToast(loadingId);\n *     throw error;\n *   }\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param message\n */\n  notifyLoading = (message) => {\n    return toast.loading(message, {\n      ...defaultToastOptions,\n      style: {\n        ...defaultToastOptions.style,\n        borderLeft: `4px solid ${SCOUT_COLORS.blue}`,\n      },\n    });\n  };\n\n/**\n * Displays promise-based notifications that automatically transition states\n * \n * Shows loading notification initially, then automatically transitions to success\n * or error notification based on promise resolution. Handles the complete lifecycle\n * of async operations with Scout-themed styling for each state.\n * \n * @param {Promise} promise - Promise to monitor for state changes\n * @param {object} messages - Messages for each notification state\n * @param {string} messages.loading - Message to show while promise is pending\n * @param {string} messages.success - Message to show when promise resolves\n * @param {string} messages.error - Message to show when promise rejects\n * @returns {Promise} The original promise (allows chaining)\n * \n * @example\n * // Basic promise notification\n * const saveEvent = () => {\n *   const savePromise = api.saveEvent(eventData);\n *   \n *   return notifyPromise(savePromise, {\n *     loading: 'Saving scout event...',\n *     success: 'Event saved successfully!',\n *     error: 'Failed to save event'\n *   });\n * };\n * \n * @example\n * // File upload with promise notification\n * const uploadBadgeImage = async (file) => {\n *   const uploadPromise = api.uploadFile(file);\n *   \n *   try {\n *     const result = await notifyPromise(uploadPromise, {\n *       loading: `Uploading ${file.name}...`,\n *       success: 'Badge image uploaded successfully',\n *       error: 'Upload failed. Please try again.'\n *     });\n *     \n *     // Promise resolves with the original result\n *     console.log('Upload completed:', result);\n *     return result;\n *   } catch (error) {\n *     // Error is still thrown for additional handling\n *     console.error('Upload failed:', error);\n *     throw error;\n *   }\n * };\n * \n * @example\n * // Data sync with contextual messages\n * const syncMemberData = (sectionId) => {\n *   const syncPromise = api.syncMembers(sectionId);\n *   \n *   return notifyPromise(syncPromise, {\n *     loading: 'Syncing member data from OSM...',\n *     success: (data) => `Synced ${data.length} members successfully`,\n *     error: (error) => `Sync failed: ${error.message}`\n *   });\n * };\n * \n * @example\n * // Bulk operation with promise notification\n * const processBulkAction = async (items, action) => {\n *   const bulkPromise = Promise.all(\n *     items.map(item => api.processItem(item, action))\n *   );\n *   \n *   return notifyPromise(bulkPromise, {\n *     loading: `Processing ${items.length} items...`,\n *     success: `All ${items.length} items processed successfully`,\n *     error: 'Some items failed to process'\n *   });\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param promise\n * @param messages\n */\n  notifyPromise = (promise, messages) => {\n    return toast.promise(promise, messages, {\n      ...defaultToastOptions,\n      success: {\n        style: {\n          ...defaultToastOptions.style,\n          borderLeft: `4px solid ${SCOUT_COLORS.green}`,\n        },\n        iconTheme: {\n          primary: SCOUT_COLORS.green,\n          secondary: SCOUT_COLORS.white,\n        },\n      },\n      error: {\n        duration: 6000,\n        style: {\n          ...defaultToastOptions.style,\n          borderLeft: `4px solid ${SCOUT_COLORS.red}`,\n        },\n        iconTheme: {\n          primary: SCOUT_COLORS.red,\n          secondary: SCOUT_COLORS.white,\n        },\n      },\n      loading: {\n        style: {\n          ...defaultToastOptions.style,\n          borderLeft: `4px solid ${SCOUT_COLORS.blue}`,\n        },\n      },\n    });\n  };\n\n/**\n * Dismisses a specific toast notification by ID\n * \n * Manually dismisses a toast notification using its unique ID. Useful for\n * dismissing loading notifications when operations complete, or for programmatic\n * control over notification visibility.\n * \n * @param {string} toastId - The unique ID of the toast to dismiss\n * \n * @example\n * // Dismiss loading notification on completion\n * const loadingId = notifyLoading('Processing...');\n * try {\n *   await processData();\n *   dismissToast(loadingId);\n *   notifySuccess('Processing complete');\n * } catch (error) {\n *   dismissToast(loadingId);\n *   notifyError('Processing failed', error);\n * }\n * \n * @example\n * // Conditional dismissal\n * const showTemporaryNotification = () => {\n *   const notificationId = notifyInfo('This will disappear in 2 seconds');\n *   \n *   setTimeout(() => {\n *     dismissToast(notificationId);\n *   }, 2000);\n * };\n * \n * @example\n * // Component cleanup\n * const MyComponent = () => {\n *   const [activeToasts, setActiveToasts] = useState([]);\n *   \n *   useEffect(() => {\n *     return () => {\n *       // Cleanup: dismiss all component-specific toasts\n *       activeToasts.forEach(toastId => dismissToast(toastId));\n *     };\n *   }, [activeToasts]);\n *   \n *   const handleNotify = () => {\n *     const id = notifyInfo('Component notification');\n *     setActiveToasts(prev => [...prev, id]);\n *   };\n * };\n * \n * @since 2.3.7\n */\nexport const /**\n *\n * @param toastId\n */\n  dismissToast = (toastId) => {\n    toast.dismiss(toastId);\n  };\n\n/**\n * Dismisses all currently visible toast notifications\n * \n * Clears all active toast notifications from the screen. Useful for cleanup\n * operations, navigation events, or when you need to clear the notification\n * area for important new messages.\n * \n * @example\n * // Clear all notifications on page navigation\n * const navigateToPage = (page) => {\n *   dismissAllToasts();\n *   navigate(page);\n * };\n * \n * @example\n * // Clear notifications before critical action\n * const handleCriticalAction = () => {\n *   dismissAllToasts();\n *   notifyWarning('This action cannot be undone. Continue?');\n *   // Show confirmation dialog\n * };\n * \n * @example\n * // Component unmount cleanup\n * const AppComponent = () => {\n *   useEffect(() => {\n *     return () => {\n *       // Clear all notifications when app unmounts\n *       dismissAllToasts();\n *     };\n *   }, []);\n * };\n * \n * @example\n * // Error boundary cleanup\n * class ErrorBoundary extends React.Component {\n *   componentDidCatch(error, errorInfo) {\n *     dismissAllToasts();\n *     notifyError('An unexpected error occurred');\n *   }\n * }\n * \n * @since 2.3.7\n */\nexport const /**\n *\n */\n  dismissAllToasts = () => {\n    toast.dismiss();\n  };\n\nexport default {\n  notifySuccess,\n  notifyError,\n  notifyWarning,\n  notifyInfo,\n  notifyLoading,\n  notifyPromise,\n  dismissToast,\n  dismissAllToasts,\n};","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/phoneUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/platform.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":6,"column":14,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":6,"column":14,"nodeType":"Block","endLine":8,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":14,"column":14,"nodeType":"Block","endLine":16,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":14,"column":14,"nodeType":"Block","endLine":16,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":22,"column":14,"nodeType":"Block","endLine":24,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":22,"column":14,"nodeType":"Block","endLine":24,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":30,"column":14,"nodeType":"Block","endLine":32,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":30,"column":14,"nodeType":"Block","endLine":32,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":38,"column":14,"nodeType":"Block","endLine":40,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":38,"column":14,"nodeType":"Block","endLine":40,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":48,"column":14,"nodeType":"Block","endLine":50,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":48,"column":14,"nodeType":"Block","endLine":50,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":56,"column":14,"nodeType":"Block","endLine":58,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":56,"column":14,"nodeType":"Block","endLine":58,"endColumn":4},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":71,"column":14,"nodeType":"Block","endLine":73,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":71,"column":14,"nodeType":"Block","endLine":73,"endColumn":4}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Platform detection utilities\nimport React from 'react';\nimport { Capacitor } from '@capacitor/core';\n\n// Detect if running on native mobile platform\nexport const /**\n *\n */\n  isNativeMobile = () => {\n    return Capacitor.isNativePlatform();\n  };\n\n// Detect if device has mobile screen size\nexport const /**\n *\n */\n  isMobileScreen = () => {\n    return window.innerWidth < 768;\n  };\n\n// Detect if should use mobile layout (native app OR small screen)\nexport const /**\n *\n */\n  isMobileLayout = () => {\n    return isNativeMobile() || isMobileScreen();\n  };\n\n// Detect if should use desktop layout\nexport const /**\n *\n */\n  isDesktopLayout = () => {\n    return !isMobileLayout();\n  };\n\n// Get platform type for conditional rendering\nexport const /**\n *\n */\n  getPlatform = () => {\n    if (isNativeMobile()) return 'native-mobile';\n    if (isMobileScreen()) return 'mobile-web';\n    return 'desktop';\n  };\n\n// Check if running in browser (for web-specific features)\nexport const /**\n *\n */\n  isBrowser = () => {\n    return !Capacitor.isNativePlatform();\n  };\n\n// Check if print functionality should be available\nexport const /**\n *\n */\n  canPrint = () => {\n    return isBrowser() && isDesktopLayout();\n  };\n\n// Responsive breakpoints\nexport const breakpoints = {\n  mobile: 768,\n  tablet: 1024,\n  desktop: 1200,\n};\n\n// Hook for responsive behavior\nexport const /**\n *\n */\n  useResponsive = () => {\n    const [screenSize, setScreenSize] = React.useState(window.innerWidth);\n  \n    React.useEffect(() => {\n      const handleResize = () => setScreenSize(window.innerWidth);\n      window.addEventListener('resize', handleResize);\n      return () => window.removeEventListener('resize', handleResize);\n    }, []);\n\n    return {\n      isMobile: screenSize < breakpoints.mobile,\n      isTablet: screenSize >= breakpoints.mobile && screenSize < breakpoints.desktop,\n      isDesktop: screenSize >= breakpoints.desktop,\n      screenSize,\n    };\n  };\n\nexport default {\n  isNativeMobile,\n  isMobileScreen,\n  isMobileLayout,\n  isDesktopLayout,\n  getPlatform,\n  isBrowser,\n  canPrint,\n  breakpoints,\n  useResponsive,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/rateLimitQueue.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":11,"column":3,"nodeType":"Block","endLine":14,"endColumn":6},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"options\" description.","line":13,"column":1,"nodeType":"Block","endLine":13,"endColumn":1},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":125,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":141,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":141,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'clearTimeout' is not defined.","line":309,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":309,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'setTimeout' is not defined.","line":312,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":312,"endColumn":37},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":371,"column":14,"nodeType":"Block","endLine":375,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":371,"column":14,"nodeType":"Block","endLine":375,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"apiCall\" description.","line":373,"column":1,"nodeType":"Block","endLine":373,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"options\" description.","line":374,"column":1,"nodeType":"Block","endLine":374,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":382,"column":14,"nodeType":"Block","endLine":384,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":382,"column":14,"nodeType":"Block","endLine":384,"endColumn":4}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced Rate Limit Queue with intelligent retry and user feedback\nimport { sleep } from './asyncUtils.js';\nimport logger, { LOG_CATEGORIES } from '../services/utils/logger.js';\nimport { sentryUtils } from '../services/utils/sentry.js';\n\n/**\n * Intelligent rate limit queue that handles 429 responses with exponential backoff\n * Provides user feedback and queuing for rate-limited requests\n */\nexport class RateLimitQueue {\n  /**\n   *\n   * @param options\n   */\n  constructor(options = {}) {\n    this.queue = [];\n    this.processing = false;\n    this.requestCount = 0;\n    this.retryCount = 0;\n    this.rateLimitedUntil = null;\n    this.listeners = new Set();\n    \n    // Configuration\n    this.maxRetries = options.maxRetries || 3;\n    this.baseDelay = options.baseDelay || 1000; // 1 second base delay\n    this.maxDelay = options.maxDelay || 30000; // 30 seconds max delay\n    this.queueTimeout = options.queueTimeout || 300000; // 5 minutes max queue time\n  }\n\n  /**\n   * Add a listener for queue status updates\n   * @param {Function} listener - Callback function for status updates\n   */\n  addStatusListener(listener) {\n    this.listeners.add(listener);\n    // Send current status immediately\n    try {\n      listener(this.getStatus());\n    } catch (error) {\n      logger.error('Error in rate limit queue listener (initial emit)', { error }, LOG_CATEGORIES.ERROR);\n    }\n  }\n\n  /**\n   * Remove a status listener\n   * @param {Function} listener - Callback function to remove\n   */\n  removeStatusListener(listener) {\n    this.listeners.delete(listener);\n  }\n\n  /**\n   * Notify all listeners of status changes\n   * @param {object} status - Current queue status\n   */\n  notifyListeners(status) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(status);\n      } catch (error) {\n        logger.error('Error in rate limit queue listener', { error }, LOG_CATEGORIES.ERROR);\n      }\n    });\n  }\n\n  /**\n   * Get current queue status for UI display\n   * @returns {object} Queue status information\n   */\n  getStatus() {\n    const now = Date.now();\n    const rateLimitRemaining = this.rateLimitedUntil ? Math.max(0, this.rateLimitedUntil - now) : 0;\n    \n    return {\n      queueLength: this.queue.length,\n      processing: this.processing,\n      totalRequests: this.requestCount,\n      retryCount: this.retryCount,\n      rateLimited: rateLimitRemaining > 0,\n      rateLimitRemaining: Math.ceil(rateLimitRemaining / 1000), // seconds\n      estimatedWaitTime: this.rateLimitedUntil ? Math.max(0, Math.ceil((this.rateLimitedUntil - Date.now()) / 1000)) : 0,\n    };\n  }\n\n\n  /**\n   * Add a request to the queue with intelligent retry handling\n   * @param {Function} apiCall - Function that makes the API call\n   * @param {object} options - Request options (priority, timeout, etc.)\n   * @returns {Promise} Promise that resolves when request completes\n   */\n  enqueue(apiCall, options = {}) {\n    return new Promise((resolve, reject) => {\n      const request = {\n        apiCall,\n        resolve,\n        reject,\n        priority: options.priority || 0,\n        attempts: 0,\n        createdAt: Date.now(),\n        timeout: options.timeout ?? this.queueTimeout,\n        id: Math.random().toString(36).substr(2, 9),\n      };\n\n      // Insert based on priority (higher priority first)\n      const insertIndex = this.queue.findIndex(item => item.priority < request.priority);\n      if (insertIndex === -1) {\n        this.queue.push(request);\n      } else {\n        this.queue.splice(insertIndex, 0, request);\n      }\n\n      // Only log when queue is getting large (potential issues)\n      if (this.queue.length > 10) {\n        logger.warn('Large API queue detected', {\n          queueLength: this.queue.length,\n          processing: this.processing,\n        }, LOG_CATEGORIES.API);\n      }\n\n      this.notifyListeners(this.getStatus());\n      this.process();\n\n      // Set timeout for request and store timeout ID to prevent memory leaks\n      request._timeoutId = setTimeout(() => {\n        if (this.queue.includes(request)) {\n          this.removeFromQueue(request);\n          reject(new Error('Request timeout: queued too long'));\n        }\n      }, request.timeout);\n    });\n  }\n\n  /**\n   * Clear request timeout to prevent memory leaks\n   * @private\n   * @param {object} request - Request to clear timeout for\n   */\n  _clearRequestTimeout(request) {\n    if (Object.prototype.hasOwnProperty.call(request, '_timeoutId')) {\n      clearTimeout(request._timeoutId);\n      delete request._timeoutId;\n    }\n  }\n\n  /**\n   * Remove a request from the queue\n   * @param {object} request - Request to remove\n   */\n  removeFromQueue(request) {\n    const index = this.queue.indexOf(request);\n    if (index > -1) {\n      this.queue.splice(index, 1);\n      this.notifyListeners(this.getStatus());\n    }\n    \n    // Clear timeout to prevent memory leak and timer firing for completed requests\n    this._clearRequestTimeout(request);\n  }\n\n  /**\n   * Process the queue with intelligent rate limit handling\n   */\n  async process() {\n    if (this.processing || this.queue.length === 0) {\n      return;\n    }\n\n    // Starting to process queued requests\n    this.processing = true;\n    this.notifyListeners(this.getStatus());\n\n    try {\n      while (this.queue.length > 0) {\n        // Check if we're currently rate limited\n        if (this.rateLimitedUntil && Date.now() < this.rateLimitedUntil) {\n          const waitTime = this.rateLimitedUntil - Date.now();\n          // Waiting for rate limit to reset\n          logger.info('Waiting for rate limit to reset', {\n            waitTimeMs: waitTime,\n            waitTimeSeconds: Math.ceil(waitTime / 1000),\n          }, LOG_CATEGORIES.API);\n          \n          await sleep(waitTime);\n        }\n\n        const request = this.queue.shift();\n        if (!request) continue;\n\n        try {\n          this.requestCount++;\n          request.attempts++;\n\n          // Only log retry attempts (not every single request)\n          if (request.attempts > 1) {\n            logger.debug('Retrying API request', {\n              attempt: request.attempts,\n              maxRetries: this.maxRetries,\n            }, LOG_CATEGORIES.API);\n          }\n\n          const result = await request.apiCall();\n          \n          // Clear timeout on successful completion to prevent memory leak\n          this._clearRequestTimeout(request);\n          \n          request.resolve(result);\n\n          // Small delay between successful requests to ensure proper ordering\n          if (this.queue.length > 0) {\n            const delayMs = 50; // Minimal delay just for request ordering\n            await sleep(delayMs);\n          }\n\n        } catch (error) {\n          const is429 = error.message?.includes('rate limit') || error.status === 429;\n          // Request failed, checking if retryable\n          \n          if (is429 && request.attempts < this.maxRetries) {\n            // Handle rate limiting with exponential backoff\n            await this.handleRateLimit(request, error);\n            // CRITICAL FIX: Break out of processing loop immediately after rate limit\n            // The rate limit timeout will be handled at the top of the next process() call\n            break;\n          } else {\n            // Max retries reached or non-rate-limit error\n            logger.error('Request failed after retries', {\n              requestId: request.id,\n              attempts: request.attempts,\n              error: error.message,\n              is429,\n            }, LOG_CATEGORIES.ERROR);\n            \n            // Clear timeout on final failure to prevent memory leak\n            this._clearRequestTimeout(request);\n            \n            request.reject(error);\n          }\n        }\n\n        this.notifyListeners(this.getStatus());\n      }\n    } finally {\n      // Queue processing completed\n      this.processing = false;\n      this.notifyListeners(this.getStatus());\n    }\n  }\n\n  /**\n   * Handle rate limit error with intelligent backoff\n   * @param {object} request - The failed request\n   * @param {Error} error - The rate limit error\n   */\n  async handleRateLimit(request, error) {\n    this.retryCount++;\n    \n    // Use backend-provided retry-after time from 429 response\n    let retryAfter = this.baseDelay; // Fallback only if no backend time provided\n    \n    // Check if error contains specific retry-after time from backend response\n    if (error.retryAfter && typeof error.retryAfter === 'number') {\n      retryAfter = error.retryAfter * 1000; // Convert to milliseconds\n    } else {\n      // Check if error message contains retry-after time\n      const retryAfterMatch = error.message?.match(/wait (\\d+) seconds?/);\n      if (retryAfterMatch) {\n        retryAfter = parseInt(retryAfterMatch[1]) * 1000;\n      }\n    }\n    // Enforce configured bounds\n    retryAfter = Math.min(Math.max(retryAfter, this.baseDelay), this.maxDelay);\n\n    // Set global rate limit timeout\n    this.rateLimitedUntil = Date.now() + retryAfter;\n    this.notifyListeners(this.getStatus());\n\n    logger.warn('Rate limited - queuing for retry', {\n      requestId: request.id,\n      attempt: request.attempts,\n      retryAfterMs: retryAfter,\n      retryAfterSeconds: Math.ceil(retryAfter / 1000),\n    }, LOG_CATEGORIES.API);\n\n    sentryUtils.addBreadcrumb({\n      category: 'rate_limit',\n      message: 'Request rate limited, queuing for retry',\n      level: 'warning',\n      data: {\n        requestId: request.id,\n        attempt: request.attempts,\n        retryAfter: Math.ceil(retryAfter / 1000),\n      },\n    });\n\n    // Re-queue the request with higher priority\n    request.priority += 1;\n    const insertIndex = this.queue.findIndex(item => item.priority < request.priority);\n    if (insertIndex === -1) {\n      this.queue.push(request);\n    } else {\n      this.queue.splice(insertIndex, 0, request);\n    }\n    \n    // Request re-queued for retry after rate limit timeout\n    \n    // CRITICAL FIX: Schedule automatic resume of processing after rate limit timeout\n    if (this._resumeTimerId) {\n      clearTimeout(this._resumeTimerId);\n      this._resumeTimerId = null;\n    }\n    this._resumeTimerId = setTimeout(() => {\n      this._resumeTimerId = null;\n      if (this.queue.length > 0 && !this.processing) {\n        // Auto-resuming processing after rate limit timeout\n        this.process();\n      }\n    }, retryAfter + 100); // Small buffer to ensure rate limit has expired\n  }\n\n  /**\n   * Clear all queued requests\n   * @param {string} reason - Reason for clearing (for logging)\n   */\n  clear(reason = 'Manual clear') {\n    const clearedCount = this.queue.length;\n    \n    // Reject all pending requests and clear their timeouts\n    this.queue.forEach(request => {\n      // Clear timeout to prevent memory leak\n      this._clearRequestTimeout(request);\n      request.reject(new Error(`Queue cleared: ${reason}`));\n    });\n    \n    this.queue = [];\n    this.rateLimitedUntil = null;\n    \n    logger.info('Queue cleared', {\n      reason,\n      clearedCount,\n    }, LOG_CATEGORIES.API);\n    \n    this.notifyListeners(this.getStatus());\n  }\n\n  /**\n   * Get statistics for monitoring and debugging\n   * @returns {object} Detailed statistics\n   */\n  getDetailedStats() {\n    return {\n      ...this.getStatus(),\n      oldestRequestAge: this.queue.length > 0\n        ? Date.now() - Math.min(...this.queue.map(r => r.createdAt || 0))\n        : 0,\n      averageRetryCount: this.requestCount > 0 ? this.retryCount / this.requestCount : 0,\n      listenerCount: this.listeners.size,\n    };\n  }\n}\n\n// Global instance\nexport const globalRateLimitQueue = new RateLimitQueue({\n  maxRetries: 3,\n  baseDelay: 1000,\n  maxDelay: 30000,\n  queueTimeout: 300000,\n});\n\n// Helper function to wrap API calls with rate limit queue\nexport const /**\n *\n * @param apiCall\n * @param options\n */\n  withRateLimitQueue = (apiCall, options = {}) => {\n  // Rate limit queue wrapping API call\n    return globalRateLimitQueue.enqueue(apiCall, options);\n  };\n\n// Export queue stats for dashboard display\nexport const /**\n *\n */\n  getRateLimitQueueStats = () => globalRateLimitQueue.getStatus();","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/sectionHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/sectionMovements/ageCalculations.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/sectionMovements/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/sectionMovements/movementHelpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/sectionMovements/sectionGrouping.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":10,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":10,"column":1,"nodeType":"Block","endLine":13,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionType\" description.","line":12,"column":1,"nodeType":"Block","endLine":12,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":20,"column":1,"nodeType":"Block","endLine":24,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":20,"column":1,"nodeType":"Block","endLine":24,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionSummaries\" description.","line":22,"column":1,"nodeType":"Block","endLine":22,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionsData\" description.","line":23,"column":1,"nodeType":"Block","endLine":23,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":56,"column":1,"nodeType":"Block","endLine":59,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":56,"column":1,"nodeType":"Block","endLine":59,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"sectionName\" description.","line":58,"column":1,"nodeType":"Block","endLine":58,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":74,"column":1,"nodeType":"Block","endLine":78,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":74,"column":1,"nodeType":"Block","endLine":78,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"movers\" description.","line":76,"column":1,"nodeType":"Block","endLine":76,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"groupedSections\" description.","line":77,"column":1,"nodeType":"Block","endLine":77,"endColumn":1}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const SECTION_TYPE_MAPPING = {\n  'earlyyears': 'Squirrels',\n  'squirrels': 'Squirrels', \n  'beavers': 'Beavers',\n  'cubs': 'Cubs',\n  'scouts': 'Scouts',\n  'explorers': 'Explorers',\n};\n\n/**\n *\n * @param sectionType\n */\nexport function mapSectionType(sectionType) {\n  if (!sectionType) return 'Unknown';\n  const normalized = sectionType.toLowerCase();\n  return SECTION_TYPE_MAPPING[normalized] || sectionType;\n}\n\n/**\n *\n * @param sectionSummaries\n * @param sectionsData\n */\nexport function groupSectionsByType(sectionSummaries, sectionsData) {\n  const grouped = new Map();\n  \n  const summariesArray = Array.from(sectionSummaries.values());\n  \n  summariesArray.forEach(summary => {\n    const section = sectionsData.find(s => s.sectionid === summary.sectionId);\n    const sectionType = mapSectionType(section?.sectiontype || getSectionTypeFromName(summary.sectionName));\n    \n    if (!grouped.has(sectionType)) {\n      grouped.set(sectionType, {\n        type: sectionType,\n        sections: [],\n        totalIncoming: 0,\n        totalOutgoing: 0,\n        totalCurrent: 0,\n        totalRemaining: 0,\n      });\n    }\n    \n    const group = grouped.get(sectionType);\n    group.sections.push(summary);\n    group.totalIncoming += summary.incomingMovers.length;\n    group.totalOutgoing += summary.outgoingMovers.length;\n    group.totalCurrent += summary.currentMembers.length;\n    group.totalRemaining += summary.remainingCount;\n  });\n  \n  return grouped;\n}\n\n/**\n *\n * @param sectionName\n */\nfunction getSectionTypeFromName(sectionName) {\n  if (!sectionName) return null;\n  \n  const normalized = sectionName.toLowerCase();\n  \n  if (normalized.includes('squirrel') || normalized.includes('early')) return 'squirrels';\n  if (normalized.includes('beaver')) return 'beavers';\n  if (normalized.includes('cub')) return 'cubs';\n  if (normalized.includes('scout')) return 'scouts';\n  if (normalized.includes('explorer')) return 'explorers';\n  \n  return null;\n}\n\n/**\n *\n * @param movers\n * @param groupedSections\n */\nexport function calculateGroupTotals(movers, groupedSections) {\n  const groupTotals = new Map();\n  \n  groupedSections.forEach((group, sectionType) => {\n    const incomingFromPrevious = movers.filter(mover => \n      mover.targetSection && mapSectionType(mover.targetSection.toLowerCase()) === sectionType,\n    ).length;\n    \n    const outgoingToNext = group.totalOutgoing;\n    \n    groupTotals.set(sectionType, {\n      incoming: incomingFromPrevious,\n      outgoing: outgoingToNext,\n    });\n  });\n  \n  return groupTotals;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/sectionMovements/termCalculations.js","messages":[{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":15,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":15,"column":1,"nodeType":"Block","endLine":18,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"currentDate\" description.","line":17,"column":1,"nodeType":"Block","endLine":17,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":49,"column":1,"nodeType":"Block","endLine":52,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":49,"column":1,"nodeType":"Block","endLine":52,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"currentTerm\" description.","line":51,"column":1,"nodeType":"Block","endLine":51,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":80,"column":1,"nodeType":"Block","endLine":84,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":80,"column":1,"nodeType":"Block","endLine":84,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"numberOfTerms\" description.","line":82,"column":1,"nodeType":"Block","endLine":82,"endColumn":1},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"currentDate\" description.","line":83,"column":1,"nodeType":"Block","endLine":83,"endColumn":1},{"ruleId":"jsdoc/require-description","severity":2,"message":"Missing JSDoc block description.","line":100,"column":1,"nodeType":"Block","endLine":103,"endColumn":4},{"ruleId":"jsdoc/require-returns","severity":2,"message":"Missing JSDoc @returns declaration.","line":100,"column":1,"nodeType":"Block","endLine":103,"endColumn":4},{"ruleId":"jsdoc/require-param-description","severity":2,"message":"Missing JSDoc @param \"term\" description.","line":102,"column":1,"nodeType":"Block","endLine":102,"endColumn":1}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { format, isAfter } from 'date-fns';\n\nexport const TERM_TYPES = {\n  AUTUMN: 'Autumn',\n  SPRING: 'Spring', \n  SUMMER: 'Summer',\n};\n\nexport const TERM_START_DATES = {\n  AUTUMN: { month: 9, day: 1 },    // September 1st\n  SPRING: { month: 1, day: 1 },    // January 1st\n  SUMMER: { month: 4, day: 15 },   // April 15th\n};\n\n/**\n *\n * @param currentDate\n */\nexport function getCurrentTerm(currentDate = new Date()) {\n  const year = currentDate.getFullYear();\n  const month = currentDate.getMonth() + 1;\n  const day = currentDate.getDate();\n  \n  const autumnStart = new Date(year, 8, 1); // September 1st\n  const springStart = new Date(year, 0, 1); // January 1st  \n  const summerStart = new Date(year, 3, 15); // April 15th\n  \n  if (isAfter(currentDate, autumnStart) || month === 9 && day >= 1) {\n    return {\n      type: TERM_TYPES.AUTUMN,\n      year: year,\n      startDate: format(autumnStart, 'yyyy-MM-dd'),\n    };\n  } else if (isAfter(currentDate, summerStart) || (month === 4 && day >= 15)) {\n    return {\n      type: TERM_TYPES.SUMMER,\n      year: year,\n      startDate: format(summerStart, 'yyyy-MM-dd'),\n    };\n  } else {\n    return {\n      type: TERM_TYPES.SPRING,\n      year: year,\n      startDate: format(springStart, 'yyyy-MM-dd'),\n    };\n  }\n}\n\n/**\n *\n * @param currentTerm\n */\nexport function getNextTerm(currentTerm) {\n  const { type, year } = currentTerm;\n  \n  switch (type) {\n  case TERM_TYPES.AUTUMN:\n    return {\n      type: TERM_TYPES.SPRING,\n      year: year + 1,\n      startDate: `${year + 1}-01-01`,\n    };\n  case TERM_TYPES.SPRING:\n    return {\n      type: TERM_TYPES.SUMMER,\n      year: year,\n      startDate: `${year}-04-15`,\n    };\n  case TERM_TYPES.SUMMER:\n    return {\n      type: TERM_TYPES.AUTUMN,\n      year: year,\n      startDate: `${year}-09-01`,\n    };\n  default:\n    throw new Error(`Unknown term type: ${type}`);\n  }\n}\n\n/**\n *\n * @param numberOfTerms\n * @param currentDate\n */\nexport function getFutureTerms(numberOfTerms = 2, currentDate = new Date()) {\n  const terms = [];\n  let currentTerm = getCurrentTerm(currentDate);\n  \n  for (let i = 0; i < numberOfTerms; i++) {\n    currentTerm = getNextTerm(currentTerm);\n    terms.push({\n      ...currentTerm,\n      displayName: `${currentTerm.type} ${currentTerm.year}`,\n    });\n  }\n  \n  return terms;\n}\n\n/**\n *\n * @param term\n */\nexport function getTermDisplayName(term) {\n  return `${term.type} ${term.year}`;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/storageUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/simon/vsCodeProjects/VikingEventMgmt/vikings-eventmgmt-mobile/src/shared/utils/termUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]